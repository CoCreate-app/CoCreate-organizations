/*! For license information please see CoCreate-organizations.js.LICENSE.txt */
!function(n,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.CoCreate=t():(n.CoCreate=n.CoCreate||{},n.CoCreate.organizations=t())}(this,(function(){return(()=>{var __webpack_modules__={"../CoCreate-crdt/node_modules/isomorphic.js/iso-browser.js":(__unused_webpack_module,exports)=>{eval("/* eslint-env browser */\nconst perf = typeof performance === 'undefined' ? null : performance\n\nconst isoCrypto = typeof crypto === 'undefined' ? null : crypto\n\n/**\n * @type {function(number):ArrayBuffer}\n */\nconst cryptoRandomBuffer = isoCrypto !== null\n  ? len => {\n    // browser\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    isoCrypto.getRandomValues(arr)\n    return buf\n  }\n  : len => {\n    // polyfill\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    for (let i = 0; i < len; i++) {\n      arr[i] = Math.ceil((Math.random() * 0xFFFFFFFF) >>> 0)\n    }\n    return buf\n  }\n\nexports.performance = perf\nexports.cryptoRandomBuffer = cryptoRandomBuffer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2lzb21vcnBoaWMuanMvaXNvLWJyb3dzZXIuanM/OTU1OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLDBCQUEwQiIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9pc29tb3JwaGljLmpzL2lzby1icm93c2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5jb25zdCBwZXJmID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBwZXJmb3JtYW5jZVxuXG5jb25zdCBpc29DcnlwdG8gPSB0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBjcnlwdG9cblxuLyoqXG4gKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKTpBcnJheUJ1ZmZlcn1cbiAqL1xuY29uc3QgY3J5cHRvUmFuZG9tQnVmZmVyID0gaXNvQ3J5cHRvICE9PSBudWxsXG4gID8gbGVuID0+IHtcbiAgICAvLyBicm93c2VyXG4gICAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKGxlbilcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgaXNvQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG4gIDogbGVuID0+IHtcbiAgICAvLyBwb2x5ZmlsbFxuICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pXG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFycltpXSA9IE1hdGguY2VpbCgoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGRkYpID4+PiAwKVxuICAgIH1cbiAgICByZXR1cm4gYnVmXG4gIH1cblxuZXhwb3J0cy5wZXJmb3JtYW5jZSA9IHBlcmZcbmV4cG9ydHMuY3J5cHRvUmFuZG9tQnVmZmVyID0gY3J5cHRvUmFuZG9tQnVmZmVyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/isomorphic.js/iso-browser.js\n")},"../CoCreate-crdt/node_modules/lib0/array.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "last": () => (/* binding */ last),\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "copy": () => (/* binding */ copy),\n/* harmony export */   "appendTo": () => (/* binding */ appendTo),\n/* harmony export */   "from": () => (/* binding */ from),\n/* harmony export */   "every": () => (/* binding */ every),\n/* harmony export */   "some": () => (/* binding */ some),\n/* harmony export */   "equalFlat": () => (/* binding */ equalFlat),\n/* harmony export */   "flatten": () => (/* binding */ flatten)\n/* harmony export */ });\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {Array<L>} arr\n * @return {L}\n */\nconst last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nconst create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nconst copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nconst appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n *\n * @param {Array<ITEM>} arr\n * @param {function(ITEM, number, Array<ITEM>):boolean} f\n * @return {boolean}\n */\nconst every = (arr, f) => arr.every(f)\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @param {Array<S>} arr\n * @param {function(S, number, Array<S>):boolean} f\n * @return {boolean}\n */\nconst some = (arr, f) => arr.some(f)\n\n/**\n * @template ELEM\n *\n * @param {Array<ELEM>} a\n * @param {Array<ELEM>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nconst flatten = arr => arr.reduce((acc, val) => acc.concat(val), [])\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvYXJyYXkuanM/ZmMxZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTyxnQ0FBZ0MsU0FBUzs7QUFFaEQ7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTyw2QkFBNkIsU0FBUzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ087QUFDUCxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsNENBQTRDO0FBQ3ZELFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxzQ0FBc0M7QUFDakQsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWTtBQUNaO0FBQ08iLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9hcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIEFycmF5cy5cbiAqXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gVGhlIGVsZW1lbnQgbXVzdCBleGlzdFxuICpcbiAqIEB0ZW1wbGF0ZSBMXG4gKiBAcGFyYW0ge0FycmF5PEw+fSBhcnJcbiAqIEByZXR1cm4ge0x9XG4gKi9cbmV4cG9ydCBjb25zdCBsYXN0ID0gYXJyID0+IGFyclthcnIubGVuZ3RoIC0gMV1cblxuLyoqXG4gKiBAdGVtcGxhdGUgQ1xuICogQHJldHVybiB7QXJyYXk8Qz59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiAvKiogQHR5cGUge0FycmF5PEM+fSAqLyAoW10pXG5cbi8qKlxuICogQHRlbXBsYXRlIERcbiAqIEBwYXJhbSB7QXJyYXk8RD59IGFcbiAqIEByZXR1cm4ge0FycmF5PEQ+fVxuICovXG5leHBvcnQgY29uc3QgY29weSA9IGEgPT4gLyoqIEB0eXBlIHtBcnJheTxEPn0gKi8gKGEuc2xpY2UoKSlcblxuLyoqXG4gKiBBcHBlbmQgZWxlbWVudHMgZnJvbSBzcmMgdG8gZGVzdFxuICpcbiAqIEB0ZW1wbGF0ZSBNXG4gKiBAcGFyYW0ge0FycmF5PE0+fSBkZXN0XG4gKiBAcGFyYW0ge0FycmF5PE0+fSBzcmNcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZFRvID0gKGRlc3QsIHNyYykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QucHVzaChzcmNbaV0pXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHNvbWV0aGluZyBhcnJheS1saWtlIHRvIGFuIGFjdHVhbCBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPnxJdGVyYWJsZTxUPn0gYXJyYXlsaWtlXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3QgZnJvbSA9IEFycmF5LmZyb21cblxuLyoqXG4gKiBUcnVlIGlmZiBjb25kaXRpb24gaG9sZHMgb24gZXZlcnkgZWxlbWVudCBpbiB0aGUgQXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgSVRFTVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8SVRFTT59IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihJVEVNLCBudW1iZXIsIEFycmF5PElURU0+KTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXZlcnkgPSAoYXJyLCBmKSA9PiBhcnIuZXZlcnkoZilcblxuLyoqXG4gKiBUcnVlIGlmZiBjb25kaXRpb24gaG9sZHMgb24gc29tZSBlbGVtZW50IGluIHRoZSBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBTXG4gKiBAcGFyYW0ge0FycmF5PFM+fSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUywgbnVtYmVyLCBBcnJheTxTPik6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IHNvbWUgPSAoYXJyLCBmKSA9PiBhcnIuc29tZShmKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBFTEVNXG4gKlxuICogQHBhcmFtIHtBcnJheTxFTEVNPn0gYVxuICogQHBhcmFtIHtBcnJheTxFTEVNPn0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsRmxhdCA9IChhLCBiKSA9PiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgZXZlcnkoYSwgKGl0ZW0sIGluZGV4KSA9PiBpdGVtID09PSBiW2luZGV4XSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgRUxFTVxuICogQHBhcmFtIHtBcnJheTxBcnJheTxFTEVNPj59IGFyclxuICogQHJldHVybiB7QXJyYXk8RUxFTT59XG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gYXJyID0+IGFyci5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCksIFtdKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/array.js\n')},"../CoCreate-crdt/node_modules/lib0/binary.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "BIT1": () => (/* binding */ BIT1),\n/* harmony export */   "BIT2": () => (/* binding */ BIT2),\n/* harmony export */   "BIT3": () => (/* binding */ BIT3),\n/* harmony export */   "BIT4": () => (/* binding */ BIT4),\n/* harmony export */   "BIT5": () => (/* binding */ BIT5),\n/* harmony export */   "BIT6": () => (/* binding */ BIT6),\n/* harmony export */   "BIT7": () => (/* binding */ BIT7),\n/* harmony export */   "BIT8": () => (/* binding */ BIT8),\n/* harmony export */   "BIT9": () => (/* binding */ BIT9),\n/* harmony export */   "BIT10": () => (/* binding */ BIT10),\n/* harmony export */   "BIT11": () => (/* binding */ BIT11),\n/* harmony export */   "BIT12": () => (/* binding */ BIT12),\n/* harmony export */   "BIT13": () => (/* binding */ BIT13),\n/* harmony export */   "BIT14": () => (/* binding */ BIT14),\n/* harmony export */   "BIT15": () => (/* binding */ BIT15),\n/* harmony export */   "BIT16": () => (/* binding */ BIT16),\n/* harmony export */   "BIT17": () => (/* binding */ BIT17),\n/* harmony export */   "BIT18": () => (/* binding */ BIT18),\n/* harmony export */   "BIT19": () => (/* binding */ BIT19),\n/* harmony export */   "BIT20": () => (/* binding */ BIT20),\n/* harmony export */   "BIT21": () => (/* binding */ BIT21),\n/* harmony export */   "BIT22": () => (/* binding */ BIT22),\n/* harmony export */   "BIT23": () => (/* binding */ BIT23),\n/* harmony export */   "BIT24": () => (/* binding */ BIT24),\n/* harmony export */   "BIT25": () => (/* binding */ BIT25),\n/* harmony export */   "BIT26": () => (/* binding */ BIT26),\n/* harmony export */   "BIT27": () => (/* binding */ BIT27),\n/* harmony export */   "BIT28": () => (/* binding */ BIT28),\n/* harmony export */   "BIT29": () => (/* binding */ BIT29),\n/* harmony export */   "BIT30": () => (/* binding */ BIT30),\n/* harmony export */   "BIT31": () => (/* binding */ BIT31),\n/* harmony export */   "BIT32": () => (/* binding */ BIT32),\n/* harmony export */   "BITS0": () => (/* binding */ BITS0),\n/* harmony export */   "BITS1": () => (/* binding */ BITS1),\n/* harmony export */   "BITS2": () => (/* binding */ BITS2),\n/* harmony export */   "BITS3": () => (/* binding */ BITS3),\n/* harmony export */   "BITS4": () => (/* binding */ BITS4),\n/* harmony export */   "BITS5": () => (/* binding */ BITS5),\n/* harmony export */   "BITS6": () => (/* binding */ BITS6),\n/* harmony export */   "BITS7": () => (/* binding */ BITS7),\n/* harmony export */   "BITS8": () => (/* binding */ BITS8),\n/* harmony export */   "BITS9": () => (/* binding */ BITS9),\n/* harmony export */   "BITS10": () => (/* binding */ BITS10),\n/* harmony export */   "BITS11": () => (/* binding */ BITS11),\n/* harmony export */   "BITS12": () => (/* binding */ BITS12),\n/* harmony export */   "BITS13": () => (/* binding */ BITS13),\n/* harmony export */   "BITS14": () => (/* binding */ BITS14),\n/* harmony export */   "BITS15": () => (/* binding */ BITS15),\n/* harmony export */   "BITS16": () => (/* binding */ BITS16),\n/* harmony export */   "BITS17": () => (/* binding */ BITS17),\n/* harmony export */   "BITS18": () => (/* binding */ BITS18),\n/* harmony export */   "BITS19": () => (/* binding */ BITS19),\n/* harmony export */   "BITS20": () => (/* binding */ BITS20),\n/* harmony export */   "BITS21": () => (/* binding */ BITS21),\n/* harmony export */   "BITS22": () => (/* binding */ BITS22),\n/* harmony export */   "BITS23": () => (/* binding */ BITS23),\n/* harmony export */   "BITS24": () => (/* binding */ BITS24),\n/* harmony export */   "BITS25": () => (/* binding */ BITS25),\n/* harmony export */   "BITS26": () => (/* binding */ BITS26),\n/* harmony export */   "BITS27": () => (/* binding */ BITS27),\n/* harmony export */   "BITS28": () => (/* binding */ BITS28),\n/* harmony export */   "BITS29": () => (/* binding */ BITS29),\n/* harmony export */   "BITS30": () => (/* binding */ BITS30),\n/* harmony export */   "BITS31": () => (/* binding */ BITS31),\n/* harmony export */   "BITS32": () => (/* binding */ BITS32)\n/* harmony export */ });\n/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nconst BIT1 = 1\nconst BIT2 = 2\nconst BIT3 = 4\nconst BIT4 = 8\nconst BIT5 = 16\nconst BIT6 = 32\nconst BIT7 = 64\nconst BIT8 = 128\nconst BIT9 = 256\nconst BIT10 = 512\nconst BIT11 = 1024\nconst BIT12 = 2048\nconst BIT13 = 4096\nconst BIT14 = 8192\nconst BIT15 = 16384\nconst BIT16 = 32768\nconst BIT17 = 65536\nconst BIT18 = 1 << 17\nconst BIT19 = 1 << 18\nconst BIT20 = 1 << 19\nconst BIT21 = 1 << 20\nconst BIT22 = 1 << 21\nconst BIT23 = 1 << 22\nconst BIT24 = 1 << 23\nconst BIT25 = 1 << 24\nconst BIT26 = 1 << 25\nconst BIT27 = 1 << 26\nconst BIT28 = 1 << 27\nconst BIT29 = 1 << 28\nconst BIT30 = 1 << 29\nconst BIT31 = 1 << 30\nconst BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nconst BITS0 = 0\nconst BITS1 = 1\nconst BITS2 = 3\nconst BITS3 = 7\nconst BITS4 = 15\nconst BITS5 = 31\nconst BITS6 = 63\nconst BITS7 = 127\nconst BITS8 = 255\nconst BITS9 = 511\nconst BITS10 = 1023\nconst BITS11 = 2047\nconst BITS12 = 4095\nconst BITS13 = 8191\nconst BITS14 = 16383\nconst BITS15 = 32767\nconst BITS16 = 65535\nconst BITS17 = BIT18 - 1\nconst BITS18 = BIT19 - 1\nconst BITS19 = BIT20 - 1\nconst BITS20 = BIT21 - 1\nconst BITS21 = BIT22 - 1\nconst BITS22 = BIT23 - 1\nconst BITS23 = BIT24 - 1\nconst BITS24 = BIT25 - 1\nconst BITS25 = BIT26 - 1\nconst BITS26 = BIT27 - 1\nconst BITS27 = BIT28 - 1\nconst BITS28 = BIT29 - 1\nconst BITS29 = BIT30 - 1\nconst BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nconst BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nconst BITS32 = 0xFFFFFFFF\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvYmluYXJ5LmpzPzU5MmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQSxVQUFVO0FBQ1Y7QUFDTyIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9saWIwL2JpbmFyeS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIEJpbmFyeSBkYXRhIGNvbnN0YW50cy5cbiAqXG4gKiBAbW9kdWxlIGJpbmFyeVxuICovXG5cbi8qKlxuICogbi10aCBiaXQgYWN0aXZhdGVkLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBCSVQxID0gMVxuZXhwb3J0IGNvbnN0IEJJVDIgPSAyXG5leHBvcnQgY29uc3QgQklUMyA9IDRcbmV4cG9ydCBjb25zdCBCSVQ0ID0gOFxuZXhwb3J0IGNvbnN0IEJJVDUgPSAxNlxuZXhwb3J0IGNvbnN0IEJJVDYgPSAzMlxuZXhwb3J0IGNvbnN0IEJJVDcgPSA2NFxuZXhwb3J0IGNvbnN0IEJJVDggPSAxMjhcbmV4cG9ydCBjb25zdCBCSVQ5ID0gMjU2XG5leHBvcnQgY29uc3QgQklUMTAgPSA1MTJcbmV4cG9ydCBjb25zdCBCSVQxMSA9IDEwMjRcbmV4cG9ydCBjb25zdCBCSVQxMiA9IDIwNDhcbmV4cG9ydCBjb25zdCBCSVQxMyA9IDQwOTZcbmV4cG9ydCBjb25zdCBCSVQxNCA9IDgxOTJcbmV4cG9ydCBjb25zdCBCSVQxNSA9IDE2Mzg0XG5leHBvcnQgY29uc3QgQklUMTYgPSAzMjc2OFxuZXhwb3J0IGNvbnN0IEJJVDE3ID0gNjU1MzZcbmV4cG9ydCBjb25zdCBCSVQxOCA9IDEgPDwgMTdcbmV4cG9ydCBjb25zdCBCSVQxOSA9IDEgPDwgMThcbmV4cG9ydCBjb25zdCBCSVQyMCA9IDEgPDwgMTlcbmV4cG9ydCBjb25zdCBCSVQyMSA9IDEgPDwgMjBcbmV4cG9ydCBjb25zdCBCSVQyMiA9IDEgPDwgMjFcbmV4cG9ydCBjb25zdCBCSVQyMyA9IDEgPDwgMjJcbmV4cG9ydCBjb25zdCBCSVQyNCA9IDEgPDwgMjNcbmV4cG9ydCBjb25zdCBCSVQyNSA9IDEgPDwgMjRcbmV4cG9ydCBjb25zdCBCSVQyNiA9IDEgPDwgMjVcbmV4cG9ydCBjb25zdCBCSVQyNyA9IDEgPDwgMjZcbmV4cG9ydCBjb25zdCBCSVQyOCA9IDEgPDwgMjdcbmV4cG9ydCBjb25zdCBCSVQyOSA9IDEgPDwgMjhcbmV4cG9ydCBjb25zdCBCSVQzMCA9IDEgPDwgMjlcbmV4cG9ydCBjb25zdCBCSVQzMSA9IDEgPDwgMzBcbmV4cG9ydCBjb25zdCBCSVQzMiA9IDEgPDwgMzFcblxuLyoqXG4gKiBGaXJzdCBuIGJpdHMgYWN0aXZhdGVkLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBCSVRTMCA9IDBcbmV4cG9ydCBjb25zdCBCSVRTMSA9IDFcbmV4cG9ydCBjb25zdCBCSVRTMiA9IDNcbmV4cG9ydCBjb25zdCBCSVRTMyA9IDdcbmV4cG9ydCBjb25zdCBCSVRTNCA9IDE1XG5leHBvcnQgY29uc3QgQklUUzUgPSAzMVxuZXhwb3J0IGNvbnN0IEJJVFM2ID0gNjNcbmV4cG9ydCBjb25zdCBCSVRTNyA9IDEyN1xuZXhwb3J0IGNvbnN0IEJJVFM4ID0gMjU1XG5leHBvcnQgY29uc3QgQklUUzkgPSA1MTFcbmV4cG9ydCBjb25zdCBCSVRTMTAgPSAxMDIzXG5leHBvcnQgY29uc3QgQklUUzExID0gMjA0N1xuZXhwb3J0IGNvbnN0IEJJVFMxMiA9IDQwOTVcbmV4cG9ydCBjb25zdCBCSVRTMTMgPSA4MTkxXG5leHBvcnQgY29uc3QgQklUUzE0ID0gMTYzODNcbmV4cG9ydCBjb25zdCBCSVRTMTUgPSAzMjc2N1xuZXhwb3J0IGNvbnN0IEJJVFMxNiA9IDY1NTM1XG5leHBvcnQgY29uc3QgQklUUzE3ID0gQklUMTggLSAxXG5leHBvcnQgY29uc3QgQklUUzE4ID0gQklUMTkgLSAxXG5leHBvcnQgY29uc3QgQklUUzE5ID0gQklUMjAgLSAxXG5leHBvcnQgY29uc3QgQklUUzIwID0gQklUMjEgLSAxXG5leHBvcnQgY29uc3QgQklUUzIxID0gQklUMjIgLSAxXG5leHBvcnQgY29uc3QgQklUUzIyID0gQklUMjMgLSAxXG5leHBvcnQgY29uc3QgQklUUzIzID0gQklUMjQgLSAxXG5leHBvcnQgY29uc3QgQklUUzI0ID0gQklUMjUgLSAxXG5leHBvcnQgY29uc3QgQklUUzI1ID0gQklUMjYgLSAxXG5leHBvcnQgY29uc3QgQklUUzI2ID0gQklUMjcgLSAxXG5leHBvcnQgY29uc3QgQklUUzI3ID0gQklUMjggLSAxXG5leHBvcnQgY29uc3QgQklUUzI4ID0gQklUMjkgLSAxXG5leHBvcnQgY29uc3QgQklUUzI5ID0gQklUMzAgLSAxXG5leHBvcnQgY29uc3QgQklUUzMwID0gQklUMzEgLSAxXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBCSVRTMzEgPSAweDdGRkZGRkZGXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBCSVRTMzIgPSAweEZGRkZGRkZGXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/binary.js\n')},"../CoCreate-crdt/node_modules/lib0/broadcastchannel.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribe\": () => (/* binding */ subscribe),\n/* harmony export */   \"unsubscribe\": () => (/* binding */ unsubscribe),\n/* harmony export */   \"publish\": () => (/* binding */ publish)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ \"../CoCreate-crdt/node_modules/lib0/map.js\");\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ \"../CoCreate-crdt/node_modules/lib0/buffer.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage.js */ \"../CoCreate-crdt/node_modules/lib0/storage.js\");\n/* eslint-env browser */\n\n/**\n * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.\n *\n * ```js\n * // In browser window A:\n * broadcastchannel.subscribe('my events', data => console.log(data))\n * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab\n *\n * // In browser window B:\n * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'\n * ```\n *\n * @module broadcastchannel\n */\n\n// @todo before next major: use Uint8Array instead as buffer object\n\n\n\n\n\n/**\n * @typedef {Object} Channel\n * @property {Set<Function>} Channel.subs\n * @property {any} Channel.bc\n */\n\n/**\n * @type {Map<string, Channel>}\n */\nconst channels = new Map()\n\nclass LocalStoragePolyfill {\n  /**\n   * @param {string} room\n   */\n  constructor (room) {\n    this.room = room\n    /**\n     * @type {null|function({data:ArrayBuffer}):void}\n     */\n    this.onmessage = null\n    addEventListener('storage', e => e.key === room && this.onmessage !== null && this.onmessage({ data: _buffer_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64(e.newValue || '') }))\n  }\n\n  /**\n   * @param {ArrayBuffer} buf\n   */\n  postMessage (buf) {\n    _storage_js__WEBPACK_IMPORTED_MODULE_1__.varStorage.setItem(this.room, _buffer_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayFromArrayBuffer(buf)))\n  }\n}\n\n// Use BroadcastChannel or Polyfill\nconst BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel\n\n/**\n * @param {string} room\n * @return {Channel}\n */\nconst getChannel = room =>\n  _map_js__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(channels, room, () => {\n    const subs = new Set()\n    const bc = new BC(room)\n    /**\n     * @param {{data:ArrayBuffer}} e\n     */\n    bc.onmessage = e => subs.forEach(sub => sub(e.data))\n    return {\n      bc, subs\n    }\n  })\n\n/**\n * Subscribe to global `publish` events.\n *\n * @function\n * @param {string} room\n * @param {function(any):any} f\n */\nconst subscribe = (room, f) => getChannel(room).subs.add(f)\n\n/**\n * Unsubscribe from `publish` global events.\n *\n * @function\n * @param {string} room\n * @param {function(any):any} f\n */\nconst unsubscribe = (room, f) => getChannel(room).subs.delete(f)\n\n/**\n * Publish data to all subscribers (including subscribers on this tab)\n *\n * @function\n * @param {string} room\n * @param {any} data\n */\nconst publish = (room, data) => {\n  const c = getChannel(room)\n  c.bc.postMessage(data)\n  c.subs.forEach(sub => sub(data))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvYnJvYWRjYXN0Y2hhbm5lbC5qcz8xMzI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRStCO0FBQ007QUFDRTs7QUFFdkM7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsSUFBSTtBQUNsQjs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWUsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxrR0FBa0csT0FBTyxrREFBaUIsb0JBQW9CO0FBQzlJOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLDJEQUEwQixZQUFZLGdEQUFlLENBQUMsdUVBQXNDO0FBQ2hHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBLEVBQUUsbURBQWtCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxrQkFBa0I7QUFDN0I7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGtCQUFrQjtBQUM3QjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsSUFBSTtBQUNmO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9saWIwL2Jyb2FkY2FzdGNoYW5uZWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBIZWxwZXJzIGZvciBjcm9zcy10YWIgY29tbXVuaWNhdGlvbiB1c2luZyBicm9hZGNhc3RjaGFubmVsIHdpdGggTG9jYWxTdG9yYWdlIGZhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBJbiBicm93c2VyIHdpbmRvdyBBOlxuICogYnJvYWRjYXN0Y2hhbm5lbC5zdWJzY3JpYmUoJ215IGV2ZW50cycsIGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSkpXG4gKiBicm9hZGNhc3RjaGFubmVsLnB1Ymxpc2goJ215IGV2ZW50cycsICdIZWxsbyB3b3JsZCEnKSAvLyA9PiBBOiAnSGVsbG8gd29ybGQhJyBmaXJlcyBzeW5jaHJvbm91c2x5IGluIHNhbWUgdGFiXG4gKlxuICogLy8gSW4gYnJvd3NlciB3aW5kb3cgQjpcbiAqIGJyb2FkY2FzdGNoYW5uZWwucHVibGlzaCgnbXkgZXZlbnRzJywgJ2hlbGxvIGZyb20gdGFiIEInKSAvLyA9PiBBOiAnaGVsbG8gZnJvbSB0YWIgQidcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgYnJvYWRjYXN0Y2hhbm5lbFxuICovXG5cbi8vIEB0b2RvIGJlZm9yZSBuZXh0IG1ham9yOiB1c2UgVWludDhBcnJheSBpbnN0ZWFkIGFzIGJ1ZmZlciBvYmplY3RcblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJy4vYnVmZmVyLmpzJ1xuaW1wb3J0ICogYXMgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhbm5lbFxuICogQHByb3BlcnR5IHtTZXQ8RnVuY3Rpb24+fSBDaGFubmVsLnN1YnNcbiAqIEBwcm9wZXJ0eSB7YW55fSBDaGFubmVsLmJjXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7TWFwPHN0cmluZywgQ2hhbm5lbD59XG4gKi9cbmNvbnN0IGNoYW5uZWxzID0gbmV3IE1hcCgpXG5cbmNsYXNzIExvY2FsU3RvcmFnZVBvbHlmaWxsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocm9vbSkge1xuICAgIHRoaXMucm9vbSA9IHJvb21cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbHxmdW5jdGlvbih7ZGF0YTpBcnJheUJ1ZmZlcn0pOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsXG4gICAgYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGUgPT4gZS5rZXkgPT09IHJvb20gJiYgdGhpcy5vbm1lc3NhZ2UgIT09IG51bGwgJiYgdGhpcy5vbm1lc3NhZ2UoeyBkYXRhOiBidWZmZXIuZnJvbUJhc2U2NChlLm5ld1ZhbHVlIHx8ICcnKSB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZcbiAgICovXG4gIHBvc3RNZXNzYWdlIChidWYpIHtcbiAgICBzdG9yYWdlLnZhclN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnJvb20sIGJ1ZmZlci50b0Jhc2U2NChidWZmZXIuY3JlYXRlVWludDhBcnJheUZyb21BcnJheUJ1ZmZlcihidWYpKSlcbiAgfVxufVxuXG4vLyBVc2UgQnJvYWRjYXN0Q2hhbm5lbCBvciBQb2x5ZmlsbFxuY29uc3QgQkMgPSB0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgPyBMb2NhbFN0b3JhZ2VQb2x5ZmlsbCA6IEJyb2FkY2FzdENoYW5uZWxcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHJldHVybiB7Q2hhbm5lbH1cbiAqL1xuY29uc3QgZ2V0Q2hhbm5lbCA9IHJvb20gPT5cbiAgbWFwLnNldElmVW5kZWZpbmVkKGNoYW5uZWxzLCByb29tLCAoKSA9PiB7XG4gICAgY29uc3Qgc3VicyA9IG5ldyBTZXQoKVxuICAgIGNvbnN0IGJjID0gbmV3IEJDKHJvb20pXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt7ZGF0YTpBcnJheUJ1ZmZlcn19IGVcbiAgICAgKi9cbiAgICBiYy5vbm1lc3NhZ2UgPSBlID0+IHN1YnMuZm9yRWFjaChzdWIgPT4gc3ViKGUuZGF0YSkpXG4gICAgcmV0dXJuIHtcbiAgICAgIGJjLCBzdWJzXG4gICAgfVxuICB9KVxuXG4vKipcbiAqIFN1YnNjcmliZSB0byBnbG9iYWwgYHB1Ymxpc2hgIGV2ZW50cy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSk6YW55fSBmXG4gKi9cbmV4cG9ydCBjb25zdCBzdWJzY3JpYmUgPSAocm9vbSwgZikgPT4gZ2V0Q2hhbm5lbChyb29tKS5zdWJzLmFkZChmKVxuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gYHB1Ymxpc2hgIGdsb2JhbCBldmVudHMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3QgdW5zdWJzY3JpYmUgPSAocm9vbSwgZikgPT4gZ2V0Q2hhbm5lbChyb29tKS5zdWJzLmRlbGV0ZShmKVxuXG4vKipcbiAqIFB1Ymxpc2ggZGF0YSB0byBhbGwgc3Vic2NyaWJlcnMgKGluY2x1ZGluZyBzdWJzY3JpYmVycyBvbiB0aGlzIHRhYilcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcGFyYW0ge2FueX0gZGF0YVxuICovXG5leHBvcnQgY29uc3QgcHVibGlzaCA9IChyb29tLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGMgPSBnZXRDaGFubmVsKHJvb20pXG4gIGMuYmMucG9zdE1lc3NhZ2UoZGF0YSlcbiAgYy5zdWJzLmZvckVhY2goc3ViID0+IHN1YihkYXRhKSlcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/broadcastchannel.js\n")},"../CoCreate-crdt/node_modules/lib0/buffer.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createUint8ArrayFromLen": () => (/* binding */ createUint8ArrayFromLen),\n/* harmony export */   "createUint8ArrayViewFromArrayBuffer": () => (/* binding */ createUint8ArrayViewFromArrayBuffer),\n/* harmony export */   "createUint8ArrayFromArrayBuffer": () => (/* binding */ createUint8ArrayFromArrayBuffer),\n/* harmony export */   "toBase64": () => (/* binding */ toBase64),\n/* harmony export */   "fromBase64": () => (/* binding */ fromBase64),\n/* harmony export */   "copyUint8Array": () => (/* binding */ copyUint8Array),\n/* harmony export */   "encodeAny": () => (/* binding */ encodeAny),\n/* harmony export */   "decodeAny": () => (/* binding */ decodeAny)\n/* harmony export */ });\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string.js */ "../CoCreate-crdt/node_modules/lib0/string.js");\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ "../CoCreate-crdt/node_modules/lib0/environment.js");\n/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "../CoCreate-crdt/node_modules/lib0/encoding.js");\n/* harmony import */ var _decoding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decoding.js */ "../CoCreate-crdt/node_modules/lib0/decoding.js");\n/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\n\n\n\n\n\n/**\n * @param {number} len\n */\nconst createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nconst createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nconst createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* istanbul ignore next */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = \'\'\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += _string_js__WEBPACK_IMPORTED_MODULE_0__.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString(\'base64\')\n\n/* istanbul ignore next */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, \'base64\')\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* istanbul ignore next */\nconst toBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? toBase64Browser : toBase64Node\n\n/* istanbul ignore next */\nconst fromBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nconst copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It\'s a pun on typescripts\'s `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nconst encodeAny = data => {\n  const encoder = _encoding_js__WEBPACK_IMPORTED_MODULE_2__.createEncoder()\n  _encoding_js__WEBPACK_IMPORTED_MODULE_2__.writeAny(encoder, data)\n  return _encoding_js__WEBPACK_IMPORTED_MODULE_2__.toUint8Array(encoder)\n}\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nconst decodeAny = buf => _decoding_js__WEBPACK_IMPORTED_MODULE_3__.readAny(_decoding_js__WEBPACK_IMPORTED_MODULE_3__.createDecoder(buf))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvYnVmZmVyLmpzPzkyMmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDRTtBQUNFO0FBQ0E7O0FBRXpDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDLFNBQVMsb0RBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ08saUJBQWlCLHNEQUFhOztBQUVyQztBQUNPLG1CQUFtQixzREFBYTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZO0FBQ1o7QUFDTztBQUNQLGtCQUFrQix1REFBc0I7QUFDeEMsRUFBRSxrREFBaUI7QUFDbkIsU0FBUyxzREFBcUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNPLHlCQUF5QixpREFBZ0IsQ0FBQyx1REFBc0IiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9idWZmZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCBidWZmZXJzIChVaW50OEFycmF5KS5cbiAqXG4gKiBAbW9kdWxlIGJ1ZmZlclxuICovXG5cbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZy5qcydcbmltcG9ydCAqIGFzIGVudiBmcm9tICcuL2Vudmlyb25tZW50LmpzJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnLi9lbmNvZGluZy5qcydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJy4vZGVjb2RpbmcuanMnXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVWludDhBcnJheUZyb21MZW4gPSBsZW4gPT4gbmV3IFVpbnQ4QXJyYXkobGVuKVxuXG4vKipcbiAqIENyZWF0ZSBVaW50OEFycmF5IHdpdGggaW5pdGlhbCBjb250ZW50IGZyb20gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVWludDhBcnJheVZpZXdGcm9tQXJyYXlCdWZmZXIgPSAoYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpID0+IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuXG4vKipcbiAqIENyZWF0ZSBVaW50OEFycmF5IHdpdGggaW5pdGlhbCBjb250ZW50IGZyb20gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyID0gYnVmZmVyID0+IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NEJyb3dzZXIgPSBieXRlcyA9PiB7XG4gIGxldCBzID0gJydcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBzICs9IHN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pXG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHJldHVybiBidG9hKHMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NE5vZGUgPSBieXRlcyA9PiBCdWZmZXIuZnJvbShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZnJvbUJhc2U2NEJyb3dzZXIgPSBzID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIGNvbnN0IGEgPSBhdG9iKHMpXG4gIGNvbnN0IGJ5dGVzID0gY3JlYXRlVWludDhBcnJheUZyb21MZW4oYS5sZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gYS5jaGFyQ29kZUF0KGkpXG4gIH1cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqL1xuY29uc3QgZnJvbUJhc2U2NE5vZGUgPSBzID0+IHtcbiAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20ocywgJ2Jhc2U2NCcpXG4gIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdG9CYXNlNjQgPSBlbnYuaXNCcm93c2VyID8gdG9CYXNlNjRCcm93c2VyIDogdG9CYXNlNjROb2RlXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZnJvbUJhc2U2NCA9IGVudi5pc0Jyb3dzZXIgPyBmcm9tQmFzZTY0QnJvd3NlciA6IGZyb21CYXNlNjROb2RlXG5cbi8qKlxuICogQ29weSB0aGUgY29udGVudCBvZiBhbiBVaW50OEFycmF5IHZpZXcgdG8gYSBuZXcgQXJyYXlCdWZmZXIuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgY29weVVpbnQ4QXJyYXkgPSB1aW50OEFycmF5ID0+IHtcbiAgY29uc3QgbmV3QnVmID0gY3JlYXRlVWludDhBcnJheUZyb21MZW4odWludDhBcnJheS5ieXRlTGVuZ3RoKVxuICBuZXdCdWYuc2V0KHVpbnQ4QXJyYXkpXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLyoqXG4gKiBFbmNvZGUgYW55dGhpbmcgYXMgYSBVSW50OEFycmF5LiBJdCdzIGEgcHVuIG9uIHR5cGVzY3JpcHRzJ3MgYGFueWAgdHlwZS5cbiAqIFNlZSBlbmNvZGluZy53cml0ZUFueSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2FueX0gZGF0YVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZUFueSA9IGRhdGEgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGVuY29kaW5nLndyaXRlQW55KGVuY29kZXIsIGRhdGEpXG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBEZWNvZGUgYW4gYW55LWVuY29kZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUFueSA9IGJ1ZiA9PiBkZWNvZGluZy5yZWFkQW55KGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/buffer.js\n')},"../CoCreate-crdt/node_modules/lib0/conditions.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "undefinedToNull": () => (/* binding */ undefinedToNull)\n/* harmony export */ });\n/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* istanbul ignore next */\nconst undefinedToNull = v => v === undefined ? null : v\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvY29uZGl0aW9ucy5qcz9lNmY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDQTtBQUNPIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvY29uZGl0aW9ucy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT2Z0ZW4gdXNlZCBjb25kaXRpb25zLlxuICpcbiAqIEBtb2R1bGUgY29uZGl0aW9uc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VHxudWxsfHVuZGVmaW5lZH0gdlxuICogQHJldHVybiB7VHxudWxsfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHVuZGVmaW5lZFRvTnVsbCA9IHYgPT4gdiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/conditions.js\n')},"../CoCreate-crdt/node_modules/lib0/decoding.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Decoder": () => (/* binding */ Decoder),\n/* harmony export */   "createDecoder": () => (/* binding */ createDecoder),\n/* harmony export */   "hasContent": () => (/* binding */ hasContent),\n/* harmony export */   "clone": () => (/* binding */ clone),\n/* harmony export */   "readUint8Array": () => (/* binding */ readUint8Array),\n/* harmony export */   "readVarUint8Array": () => (/* binding */ readVarUint8Array),\n/* harmony export */   "readTailAsUint8Array": () => (/* binding */ readTailAsUint8Array),\n/* harmony export */   "skip8": () => (/* binding */ skip8),\n/* harmony export */   "readUint8": () => (/* binding */ readUint8),\n/* harmony export */   "readUint16": () => (/* binding */ readUint16),\n/* harmony export */   "readUint32": () => (/* binding */ readUint32),\n/* harmony export */   "readUint32BigEndian": () => (/* binding */ readUint32BigEndian),\n/* harmony export */   "peekUint8": () => (/* binding */ peekUint8),\n/* harmony export */   "peekUint16": () => (/* binding */ peekUint16),\n/* harmony export */   "peekUint32": () => (/* binding */ peekUint32),\n/* harmony export */   "readVarUint": () => (/* binding */ readVarUint),\n/* harmony export */   "readVarInt": () => (/* binding */ readVarInt),\n/* harmony export */   "peekVarUint": () => (/* binding */ peekVarUint),\n/* harmony export */   "peekVarInt": () => (/* binding */ peekVarInt),\n/* harmony export */   "readVarString": () => (/* binding */ readVarString),\n/* harmony export */   "peekVarString": () => (/* binding */ peekVarString),\n/* harmony export */   "readFromDataView": () => (/* binding */ readFromDataView),\n/* harmony export */   "readFloat32": () => (/* binding */ readFloat32),\n/* harmony export */   "readFloat64": () => (/* binding */ readFloat64),\n/* harmony export */   "readBigInt64": () => (/* binding */ readBigInt64),\n/* harmony export */   "readBigUint64": () => (/* binding */ readBigUint64),\n/* harmony export */   "readAny": () => (/* binding */ readAny),\n/* harmony export */   "RleDecoder": () => (/* binding */ RleDecoder),\n/* harmony export */   "IntDiffDecoder": () => (/* binding */ IntDiffDecoder),\n/* harmony export */   "RleIntDiffDecoder": () => (/* binding */ RleIntDiffDecoder),\n/* harmony export */   "UintOptRleDecoder": () => (/* binding */ UintOptRleDecoder),\n/* harmony export */   "IncUintOptRleDecoder": () => (/* binding */ IncUintOptRleDecoder),\n/* harmony export */   "IntDiffOptRleDecoder": () => (/* binding */ IntDiffOptRleDecoder),\n/* harmony export */   "StringDecoder": () => (/* binding */ StringDecoder)\n/* harmony export */ });\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "../CoCreate-crdt/node_modules/lib0/buffer.js");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ "../CoCreate-crdt/node_modules/lib0/binary.js");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "../CoCreate-crdt/node_modules/lib0/math.js");\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang\'s binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, \'Hello world!\')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => \'Hello world!\'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\n\n\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nconst hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nconst clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nconst skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0\n  let len = 0\n  while (true) {\n    const r = decoder.arr[decoder.pos++]\n    num = num | ((r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS7) << len)\n    len += 7\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT8) {\n      return num >>> 0 // return unsigned number!\n    }\n    /* istanbul ignore if */\n    if (len > 35) {\n      throw new Error(\'Integer out of range!\')\n    }\n  }\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if unmber is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS6\n  let len = 6\n  const sign = (r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT7) > 0 ? -1 : 1\n  if ((r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT8) === 0) {\n    // don\'t continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++]\n    num = num | ((r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS7) << len)\n    len += 7\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT8) {\n      return sign * (num >>> 0)\n    }\n    /* istanbul ignore if */\n    if (len > 41) {\n      throw new Error(\'Integer out of range!\')\n    }\n  }\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\nconst readVarString = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return \'\'\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nconst readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0)\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nconst readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nclass RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nclass IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nclass RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_2__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_2__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nclass IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = diff >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nclass StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZGVjb2RpbmcuanM/MzdhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNBO0FBQ0o7O0FBRWpDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQLGVBQWUsMkVBQTBDO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FB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QWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBOztBQUVPO0FBQ1A7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFTztBQUNQO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9kZWNvZGluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBkZWNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZGVjb2RpbmddIHdpdGggW2xpYjAvZW5jb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBuZXcgZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gKiBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMjU2KVxuICogZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgJ0hlbGxvIHdvcmxkIScpXG4gKiBjb25zdCBidWYgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWNvZGluZyBzdGVwXG4gKiBjb25zdCBkZWNvZGVyID0gbmV3IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBkZWNvZGluZ1xuICovXG5cbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuXG4vKipcbiAqIEEgRGVjb2RlciBoYW5kbGVzIHRoZSBkZWNvZGluZyBvZiBhbiBVaW50OEFycmF5LlxuICovXG5leHBvcnQgY2xhc3MgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXkgQmluYXJ5IGRhdGEgdG8gZGVjb2RlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIC8qKlxuICAgICAqIERlY29kaW5nIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXJyID0gdWludDhBcnJheVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZGVjb2RpbmcgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMFxuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge0RlY29kZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWNvZGVyID0gdWludDhBcnJheSA9PiBuZXcgRGVjb2Rlcih1aW50OEFycmF5KVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaGFzQ29udGVudCA9IGRlY29kZXIgPT4gZGVjb2Rlci5wb3MgIT09IGRlY29kZXIuYXJyLmxlbmd0aFxuXG4vKipcbiAqIENsb25lIGEgZGVjb2RlciBpbnN0YW5jZS5cbiAqIE9wdGlvbmFsbHkgc2V0IGEgbmV3IHBvc2l0aW9uIHBhcmFtZXRlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IFtuZXdQb3NdIERlZmF1bHRzIHRvIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0RlY29kZXJ9IEEgY2xvbmUgb2YgYGRlY29kZXJgXG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZSA9IChkZWNvZGVyLCBuZXdQb3MgPSBkZWNvZGVyLnBvcykgPT4ge1xuICBjb25zdCBfZGVjb2RlciA9IGNyZWF0ZURlY29kZXIoZGVjb2Rlci5hcnIpXG4gIF9kZWNvZGVyLnBvcyA9IG5ld1Bvc1xuICByZXR1cm4gX2RlY29kZXJcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gVWludDhBcnJheSB2aWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzIGFuZCBhZHZhbmNlIHRoZSBwb3NpdGlvbiBieSBgbGVuYC5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVGhlIGxlbmd0aCBvZiBieXRlcyB0byByZWFkXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQ4QXJyYXkgPSAoZGVjb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IHZpZXcgPSBidWZmZXIuY3JlYXRlVWludDhBcnJheVZpZXdGcm9tQXJyYXlCdWZmZXIoZGVjb2Rlci5hcnIuYnVmZmVyLCBkZWNvZGVyLnBvcyArIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQsIGxlbilcbiAgZGVjb2Rlci5wb3MgKz0gbGVuXG4gIHJldHVybiB2aWV3XG59XG5cbi8qKlxuICogUmVhZCB2YXJpYWJsZSBsZW5ndGggVWludDhBcnJheS5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVmFyVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpXG5cbi8qKlxuICogUmVhZCB0aGUgcmVzdCBvZiB0aGUgY29udGVudCBhcyBhbiBBcnJheUJ1ZmZlclxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVGFpbEFzVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgZGVjb2Rlci5hcnIubGVuZ3RoIC0gZGVjb2Rlci5wb3MpXG5cbi8qKlxuICogU2tpcCBvbmUgYnl0ZSwganVtcCB0byB0aGUgbmV4dCBwb3NpdGlvbi5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZXh0IHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBza2lwOCA9IGRlY29kZXIgPT4gZGVjb2Rlci5wb3MrK1xuXG4vKipcbiAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50OCA9IGRlY29kZXIgPT4gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cblxuLyoqXG4gKiBSZWFkIDIgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQxNiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpXG4gIGRlY29kZXIucG9zICs9IDJcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBSZWFkIDQgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQzMiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMl0gPDwgMTYpICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSA8PCAyNCkpID4+PiAwXG4gIGRlY29kZXIucG9zICs9IDRcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBSZWFkIDQgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlciBpbiBiaWcgZW5kaWFuIG9yZGVyLlxuICogKG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdClcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQzMkJpZ0VuZGlhbiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMl0gPDwgOCkgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDE2KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSA8PCAyNCkpID4+PiAwXG4gIGRlY29kZXIucG9zICs9IDRcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uLlxuICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zXVxuXG4vKipcbiAqIExvb2sgYWhlYWQgd2l0aG91dCBpbmNyZW1lbnRpbmcgcG9zaXRpb24uXG4gKiB0byB0aGUgbmV4dCBieXRlIGFuZCByZWFkIGl0IGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtVaW50MTYgPSBkZWNvZGVyID0+XG4gIGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpXG5cbi8qKlxuICogTG9vayBhaGVhZCB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvbi5cbiAqIHRvIHRoZSBuZXh0IGJ5dGUgYW5kIHJlYWQgaXQgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcGVla1VpbnQzMiA9IGRlY29kZXIgPT4gKFxuICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDE2KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDNdIDw8IDI0KVxuKSA+Pj4gMFxuXG4vKipcbiAqIFJlYWQgdW5zaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IG51bSA9IDBcbiAgbGV0IGxlbiA9IDBcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgICBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBsZW4gKz0gN1xuICAgIGlmIChyIDwgYmluYXJ5LkJJVDgpIHtcbiAgICAgIHJldHVybiBudW0gPj4+IDAgLy8gcmV0dXJuIHVuc2lnbmVkIG51bWJlciFcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGxlbiA+IDM1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgb3V0IG9mIHJhbmdlIScpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVhZCBzaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHByb2JhYmx5IGNyZWF0ZSB0aGUgaW52ZXJzZSB+bnVtIGlmIHVubWJlciBpcyBuZWdhdGl2ZSAtIGJ1dCB0aGlzIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIubGVuZ3RoXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVmFySW50ID0gZGVjb2RlciA9PiB7XG4gIGxldCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgbGV0IG51bSA9IHIgJiBiaW5hcnkuQklUUzZcbiAgbGV0IGxlbiA9IDZcbiAgY29uc3Qgc2lnbiA9IChyICYgYmluYXJ5LkJJVDcpID4gMCA/IC0xIDogMVxuICBpZiAoKHIgJiBiaW5hcnkuQklUOCkgPT09IDApIHtcbiAgICAvLyBkb24ndCBjb250aW51ZSByZWFkaW5nXG4gICAgcmV0dXJuIHNpZ24gKiBudW1cbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXVxuICAgIG51bSA9IG51bSB8ICgociAmIGJpbmFyeS5CSVRTNykgPDwgbGVuKVxuICAgIGxlbiArPSA3XG4gICAgaWYgKHIgPCBiaW5hcnkuQklUOCkge1xuICAgICAgcmV0dXJuIHNpZ24gKiAobnVtID4+PiAwKVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAobGVuID4gNDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlciBvdXQgb2YgcmFuZ2UhJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIGFuZCByZWFkIHZhclVpbnQgd2l0aG91dCBpbmNyZW1lbnRpbmcgcG9zaXRpb25cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcGVla1ZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3NcbiAgY29uc3QgcyA9IHJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGRlY29kZXIucG9zID0gcG9zXG4gIHJldHVybiBzXG59XG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJVaW50IHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtWYXJJbnQgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3NcbiAgY29uc3QgcyA9IHJlYWRWYXJJbnQoZGVjb2RlcilcbiAgZGVjb2Rlci5wb3MgPSBwb3NcbiAgcmV0dXJuIHNcbn1cblxuLyoqXG4gKiBSZWFkIHN0cmluZyBvZiB2YXJpYWJsZSBsZW5ndGhcbiAqICogdmFyVWludCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xuICpcbiAqIFRyYW5zZm9ybWluZyB1dGY4IHRvIGEgc3RyaW5nIGlzIHByZXR0eSBleHBlbnNpdmUuIFRoZSBjb2RlIHBlcmZvcm1zIDEweCBiZXR0ZXJcbiAqIHdoZW4gU3RyaW5nLmZyb21Db2RlUG9pbnQgaXMgZmVkIHdpdGggYWxsIGNoYXJhY3RlcnMgYXMgYXJndW1lbnRzLlxuICogQnV0IG1vc3QgZW52aXJvbm1lbnRzIGhhdmUgYSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGVyIGZ1bmN0aW9ucy5cbiAqIEZvciBlZmZpZW5jeSByZWFzb25zIHdlIGFwcGx5IGEgbWF4aW11bSBvZiAxMDAwMCBjaGFyYWN0ZXJzIGF0IG9uY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhclN0cmluZyA9IGRlY29kZXIgPT4ge1xuICBsZXQgcmVtYWluaW5nTGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgaWYgKHJlbWFpbmluZ0xlbiA9PT0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9IGVsc2Uge1xuICAgIGxldCBlbmNvZGVkU3RyaW5nID0gU3RyaW5nLmZyb21Db2RlUG9pbnQocmVhZFVpbnQ4KGRlY29kZXIpKSAvLyByZW1lbWJlciB0byBkZWNyZWFzZSByZW1haW5pbmdMZW5cbiAgICBpZiAoLS1yZW1haW5pbmdMZW4gPCAxMDApIHsgLy8gZG8gbm90IGNyZWF0ZSBhIFVpbnQ4QXJyYXkgZm9yIHNtYWxsIHN0cmluZ3NcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4tLSkge1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbiA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dExlbiA9IHJlbWFpbmluZ0xlbiA8IDEwMDAwID8gcmVtYWluaW5nTGVuIDogMTAwMDBcbiAgICAgICAgLy8gdGhpcyBpcyBkYW5nZXJvdXMsIHdlIGNyZWF0ZSBhIGZyZXNoIGFycmF5IHZpZXcgZnJvbSB0aGUgZXhpc3RpbmcgYnVmZmVyXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZGVjb2Rlci5hcnIuc3ViYXJyYXkoZGVjb2Rlci5wb3MsIGRlY29kZXIucG9zICsgbmV4dExlbilcbiAgICAgICAgZGVjb2Rlci5wb3MgKz0gbmV4dExlblxuICAgICAgICAvLyBTdGFydGluZyB3aXRoIEVTNS4xIHdlIGNhbiBzdXBwbHkgYSBnZW5lcmljIGFycmF5LWxpa2Ugb2JqZWN0IGFzIGFyZ3VtZW50c1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIC8qKiBAdHlwZSB7YW55fSAqLyAoYnl0ZXMpKVxuICAgICAgICByZW1haW5pbmdMZW4gLT0gbmV4dExlblxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlbmNvZGVkU3RyaW5nKSlcbiAgfVxufVxuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyU3RyaW5nIHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtWYXJTdHJpbmcgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3NcbiAgY29uc3QgcyA9IHJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgZGVjb2Rlci5wb3MgPSBwb3NcbiAgcmV0dXJuIHNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEByZXR1cm4ge0RhdGFWaWV3fVxuICovXG5leHBvcnQgY29uc3QgcmVhZEZyb21EYXRhVmlldyA9IChkZWNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcoZGVjb2Rlci5hcnIuYnVmZmVyLCBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0ICsgZGVjb2Rlci5wb3MsIGxlbilcbiAgZGVjb2Rlci5wb3MgKz0gbGVuXG4gIHJldHVybiBkdlxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEZsb2F0MzIgPSBkZWNvZGVyID0+IHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgNCkuZ2V0RmxvYXQzMigwKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEZsb2F0NjQgPSBkZWNvZGVyID0+IHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkuZ2V0RmxvYXQ2NCgwKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEJpZ0ludDY0ID0gZGVjb2RlciA9PiAvKiogQHR5cGUge2FueX0gKi8gKHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkpLmdldEJpZ0ludDY0KDApXG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQmlnVWludDY0ID0gZGVjb2RlciA9PiAvKiogQHR5cGUge2FueX0gKi8gKHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkpLmdldEJpZ1VpbnQ2NCgwKVxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihEZWNvZGVyKTphbnk+fVxuICovXG5jb25zdCByZWFkQW55TG9va3VwVGFibGUgPSBbXG4gIGRlY29kZXIgPT4gdW5kZWZpbmVkLCAvLyBDQVNFIDEyNzogdW5kZWZpbmVkXG4gIGRlY29kZXIgPT4gbnVsbCwgLy8gQ0FTRSAxMjY6IG51bGxcbiAgcmVhZFZhckludCwgLy8gQ0FTRSAxMjU6IGludGVnZXJcbiAgcmVhZEZsb2F0MzIsIC8vIENBU0UgMTI0OiBmbG9hdDMyXG4gIHJlYWRGbG9hdDY0LCAvLyBDQVNFIDEyMzogZmxvYXQ2NFxuICByZWFkQmlnSW50NjQsIC8vIENBU0UgMTIyOiBiaWdpbnRcbiAgZGVjb2RlciA9PiBmYWxzZSwgLy8gQ0FTRSAxMjE6IGJvb2xlYW4gKGZhbHNlKVxuICBkZWNvZGVyID0+IHRydWUsIC8vIENBU0UgMTIwOiBib29sZWFuICh0cnVlKVxuICByZWFkVmFyU3RyaW5nLCAvLyBDQVNFIDExOTogc3RyaW5nXG4gIGRlY29kZXIgPT4geyAvLyBDQVNFIDExODogb2JqZWN0PHN0cmluZyxhbnk+XG4gICAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gcmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgb2JqW2tleV0gPSByZWFkQW55KGRlY29kZXIpXG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfSxcbiAgZGVjb2RlciA9PiB7IC8vIENBU0UgMTE3OiBhcnJheTxhbnk+XG4gICAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBhcnIgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyci5wdXNoKHJlYWRBbnkoZGVjb2RlcikpXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfSxcbiAgcmVhZFZhclVpbnQ4QXJyYXkgLy8gQ0FTRSAxMTY6IFVpbnQ4QXJyYXlcbl1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRBbnkgPSBkZWNvZGVyID0+IHJlYWRBbnlMb29rdXBUYWJsZVsxMjcgLSByZWFkVWludDgoZGVjb2RlcildKGRlY29kZXIpXG5cbi8qKlxuICogVCBtdXN0IG5vdCBiZSBudWxsLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbihEZWNvZGVyKTpUfSByZWFkZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5LCByZWFkZXIpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIFRoZSByZWFkZXJcbiAgICAgKi9cbiAgICB0aGlzLnJlYWRlciA9IHJlYWRlclxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7VHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucyA9IG51bGxcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHRoaXMucmVhZGVyKHRoaXMpXG4gICAgICBpZiAoaGFzQ29udGVudCh0aGlzKSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAxIC8vIHNlZSBlbmNvZGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgcmVhc29uIHdoeSB0aGlzIGlzIGluY3JlbWVudGVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50ID0gLTEgLy8gcmVhZCB0aGUgY3VycmVudCB2YWx1ZSBmb3JldmVyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge1R9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludERpZmZEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgc3RhcnQpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IHN0YXJ0XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgdGhpcy5zICs9IHJlYWRWYXJJbnQodGhpcylcbiAgICByZXR1cm4gdGhpcy5zXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJsZUludERpZmZEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgc3RhcnQpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IHN0YXJ0XG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zICs9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIGlmIChoYXNDb250ZW50KHRoaXMpKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDEgLy8gc2VlIGVuY29kZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSByZWFzb24gd2h5IHRoaXMgaXMgaW5jcmVtZW50ZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAtMSAvLyByZWFkIHRoZSBjdXJyZW50IHZhbHVlIGZvcmV2ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVaW50T3B0UmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIHJlYWQgKCkge1xuICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnMgPSByZWFkVmFySW50KHRoaXMpXG4gICAgICAvLyBpZiB0aGUgc2lnbiBpcyBuZWdhdGl2ZSwgd2UgcmVhZCB0aGUgY291bnQgdG9vLCBvdGhlcndpc2UgY291bnQgaXMgMVxuICAgICAgY29uc3QgaXNOZWdhdGl2ZSA9IG1hdGguaXNOZWdhdGl2ZVplcm8odGhpcy5zKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIHRoaXMucyA9IC10aGlzLnNcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMlxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEluY1VpbnRPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIC8vIGlmIHRoZSBzaWduIGlzIG5lZ2F0aXZlLCB3ZSByZWFkIHRoZSBjb3VudCB0b28sIG90aGVyd2lzZSBjb3VudCBpcyAxXG4gICAgICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyh0aGlzLnMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgdGhpcy5zID0gLXRoaXMuc1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucysrKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbnREaWZmT3B0UmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgICB0aGlzLmRpZmYgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIGNvbnN0IGRpZmYgPSByZWFkVmFySW50KHRoaXMpXG4gICAgICAvLyBpZiB0aGUgZmlyc3QgYml0IGlzIHNldCwgd2UgcmVhZCBtb3JlIGRhdGFcbiAgICAgIGNvbnN0IGhhc0NvdW50ID0gZGlmZiAmIDFcbiAgICAgIHRoaXMuZGlmZiA9IGRpZmYgPj4gMVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIGlmIChoYXNDb3VudCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucyArPSB0aGlzLmRpZmZcbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gdGhpcy5zXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0cmluZ0RlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBVaW50T3B0UmxlRGVjb2Rlcih1aW50OEFycmF5KVxuICAgIHRoaXMuc3RyID0gcmVhZFZhclN0cmluZyh0aGlzLmRlY29kZXIpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNwb3MgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgY29uc3QgZW5kID0gdGhpcy5zcG9zICsgdGhpcy5kZWNvZGVyLnJlYWQoKVxuICAgIGNvbnN0IHJlcyA9IHRoaXMuc3RyLnNsaWNlKHRoaXMuc3BvcywgZW5kKVxuICAgIHRoaXMuc3BvcyA9IGVuZFxuICAgIHJldHVybiByZXNcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/decoding.js\n')},"../CoCreate-crdt/node_modules/lib0/dom.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doc": () => (/* binding */ doc),\n/* harmony export */   "createElement": () => (/* binding */ createElement),\n/* harmony export */   "createDocumentFragment": () => (/* binding */ createDocumentFragment),\n/* harmony export */   "createTextNode": () => (/* binding */ createTextNode),\n/* harmony export */   "domParser": () => (/* binding */ domParser),\n/* harmony export */   "emitCustomEvent": () => (/* binding */ emitCustomEvent),\n/* harmony export */   "setAttributes": () => (/* binding */ setAttributes),\n/* harmony export */   "setAttributesMap": () => (/* binding */ setAttributesMap),\n/* harmony export */   "fragment": () => (/* binding */ fragment),\n/* harmony export */   "append": () => (/* binding */ append),\n/* harmony export */   "remove": () => (/* binding */ remove),\n/* harmony export */   "addEventListener": () => (/* binding */ addEventListener),\n/* harmony export */   "removeEventListener": () => (/* binding */ removeEventListener),\n/* harmony export */   "addEventListeners": () => (/* binding */ addEventListeners),\n/* harmony export */   "removeEventListeners": () => (/* binding */ removeEventListeners),\n/* harmony export */   "element": () => (/* binding */ element),\n/* harmony export */   "canvas": () => (/* binding */ canvas),\n/* harmony export */   "text": () => (/* binding */ text),\n/* harmony export */   "pairToStyleString": () => (/* binding */ pairToStyleString),\n/* harmony export */   "pairsToStyleString": () => (/* binding */ pairsToStyleString),\n/* harmony export */   "mapToStyleString": () => (/* binding */ mapToStyleString),\n/* harmony export */   "querySelector": () => (/* binding */ querySelector),\n/* harmony export */   "querySelectorAll": () => (/* binding */ querySelectorAll),\n/* harmony export */   "getElementById": () => (/* binding */ getElementById),\n/* harmony export */   "parseFragment": () => (/* binding */ parseFragment),\n/* harmony export */   "parseElement": () => (/* binding */ parseElement),\n/* harmony export */   "replaceWith": () => (/* binding */ replaceWith),\n/* harmony export */   "insertBefore": () => (/* binding */ insertBefore),\n/* harmony export */   "appendChild": () => (/* binding */ appendChild),\n/* harmony export */   "ELEMENT_NODE": () => (/* binding */ ELEMENT_NODE),\n/* harmony export */   "TEXT_NODE": () => (/* binding */ TEXT_NODE),\n/* harmony export */   "CDATA_SECTION_NODE": () => (/* binding */ CDATA_SECTION_NODE),\n/* harmony export */   "COMMENT_NODE": () => (/* binding */ COMMENT_NODE),\n/* harmony export */   "DOCUMENT_NODE": () => (/* binding */ DOCUMENT_NODE),\n/* harmony export */   "DOCUMENT_TYPE_NODE": () => (/* binding */ DOCUMENT_TYPE_NODE),\n/* harmony export */   "DOCUMENT_FRAGMENT_NODE": () => (/* binding */ DOCUMENT_FRAGMENT_NODE),\n/* harmony export */   "checkNodeType": () => (/* binding */ checkNodeType),\n/* harmony export */   "isParentOf": () => (/* binding */ isParentOf)\n/* harmony export */ });\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pair.js */ "../CoCreate-crdt/node_modules/lib0/pair.js");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.js */ "../CoCreate-crdt/node_modules/lib0/map.js");\n/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\n\n\n\n\n/* istanbul ignore next */\n/**\n * @type {Document}\n */\nconst doc = /** @type {Document} */ (typeof document !== \'undefined\' ? document : {})\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst createElement = name => doc.createElement(name)\n\n/**\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst createDocumentFragment = () => doc.createDocumentFragment()\n\n/**\n * @param {string} text\n * @return {Text}\n */\n/* istanbul ignore next */\nconst createTextNode = text => doc.createTextNode(text)\n\n/* istanbul ignore next */\nconst domParser = /** @type {DOMParser} */ (typeof DOMParser !== \'undefined\' ? new DOMParser() : null)\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\n/* istanbul ignore next */\nconst emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts))\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributes = (el, attrs) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key)\n    } else if (value === true) {\n      el.setAttribute(key, \'\')\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value)\n    }\n  })\n  return el\n}\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value) })\n  return el\n}\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst fragment = children => {\n  const fragment = createDocumentFragment()\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i])\n  }\n  return fragment\n}\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\n/* istanbul ignore next */\nconst append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes))\n  return parent\n}\n\n/**\n * @param {HTMLElement} el\n */\n/* istanbul ignore next */\nconst remove = el => el.remove()\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst addEventListener = (el, name, f) => el.addEventListener(name, f)\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst removeEventListener = (el, name, f) => el.removeEventListener(name, f)\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst addEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => addEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst removeEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => removeEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\n/* istanbul ignore next */\nconst element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children)\n\n/**\n * @param {number} width\n * @param {number} height\n */\n/* istanbul ignore next */\nconst canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement(\'canvas\'))\n  c.height = height\n  c.width = width\n  return c\n}\n\n/**\n * @param {string} t\n * @return {Text}\n */\n/* istanbul ignore next */\nconst text = createTextNode\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\n/* istanbul ignore next */\nconst pairToStyleString = pair => `${pair.left}:${pair.right};`\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\n/* istanbul ignore next */\nconst pairsToStyleString = pairs => pairs.map(pairToStyleString).join(\'\')\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\n/* istanbul ignore next */\nconst mapToStyleString = m => _map_js__WEBPACK_IMPORTED_MODULE_1__.map(m, (value, key) => `${key}:${value};`).join(\'\')\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\n/* istanbul ignore next */\nconst querySelector = (el, query) => el.querySelector(query)\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\n/* istanbul ignore next */\nconst querySelectorAll = (el, query) => el.querySelectorAll(query)\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, \'text/html\').body\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild)\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\n/* istanbul ignore next */\nconst replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl)\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst insertBefore = (parent, el, ref) => parent.insertBefore(el, ref)\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\n/* istanbul ignore next */\nconst appendChild = (parent, child) => parent.appendChild(child)\n\nconst ELEMENT_NODE = doc.ELEMENT_NODE\nconst TEXT_NODE = doc.TEXT_NODE\nconst CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE\nconst COMMENT_NODE = doc.COMMENT_NODE\nconst DOCUMENT_NODE = doc.DOCUMENT_NODE\nconst DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE\nconst DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE\n\n/**\n * @param {any} node\n * @param {number} type\n */\nconst checkNodeType = (node, type) => node.nodeType === type\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nconst isParentOf = (parent, child) => {\n  let p = child.parentNode\n  while (p && p !== parent) {\n    p = p.parentNode\n  }\n  return p === parent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZG9tLmpzPzliMzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDO0FBQ0Y7O0FBRS9CO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTyx1QkFBdUIsU0FBUyxvREFBb0Q7O0FBRTNGO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDTyw2QkFBNkIsVUFBVTs7QUFFOUM7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx3Q0FBd0M7QUFDbkQsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQLEVBQUUsNkNBQVk7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0JBQW9CO0FBQy9CLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsOEJBQThCO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLHVDQUF1QztBQUNsRCxZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1AsRUFBRSw2Q0FBWTtBQUNkO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyx1Q0FBdUM7QUFDbEQsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQLEVBQUUsNkNBQVk7QUFDZDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsMERBQTBEO0FBQ3JFLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDTztBQUNQLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDTyxxQ0FBcUMsVUFBVSxHQUFHLFlBQVk7O0FBRXJFO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0MsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVk7QUFDWjtBQUNBO0FBQ08sOEJBQThCLHdDQUFPLHVCQUF1QixJQUFJLEdBQUcsT0FBTzs7QUFFakY7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPLHdDQUF3QyxZQUFZOztBQUUzRDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBLGdFQUFnRSxLQUFLOztBQUVyRTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPLGtEQUFrRCxJQUFJOztBQUU3RDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLE9BQU87QUFDbEI7QUFDTzs7QUFFUDtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFlBQVk7QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9saWIwL2RvbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCB0aGUgRE9NLlxuICpcbiAqIEBtb2R1bGUgZG9tXG4gKi9cblxuaW1wb3J0ICogYXMgcGFpciBmcm9tICcuL3BhaXIuanMnXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEB0eXBlIHtEb2N1bWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRvYyA9IC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlRWxlbWVudCA9IG5hbWUgPT4gZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSlcblxuLyoqXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSAoKSA9PiBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1RleHR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlVGV4dE5vZGUgPSB0ZXh0ID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGRvbVBhcnNlciA9IC8qKiBAdHlwZSB7RE9NUGFyc2VyfSAqLyAodHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgRE9NUGFyc2VyKCkgOiBudWxsKVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBlbWl0Q3VzdG9tRXZlbnQgPSAoZWwsIG5hbWUsIG9wdHMpID0+IGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIG9wdHMpKVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmd8Ym9vbGVhbj4+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgc2V0QXR0cmlidXRlcyA9IChlbCwgYXR0cnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGF0dHJzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgJycpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgc2V0QXR0cmlidXRlc01hcCA9IChlbCwgYXR0cnMpID0+IHtcbiAgYXR0cnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4geyBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkgfSlcbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxOb2RlPnxIVE1MQ29sbGVjdGlvbn0gY2hpbGRyZW5cbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSBjaGlsZHJlbiA9PiB7XG4gIGNvbnN0IGZyYWdtZW50ID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBlbmRDaGlsZChmcmFnbWVudCwgY2hpbGRyZW5baV0pXG4gIH1cbiAgcmV0dXJuIGZyYWdtZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZCA9IChwYXJlbnQsIG5vZGVzKSA9PiB7XG4gIGFwcGVuZENoaWxkKHBhcmVudCwgZnJhZ21lbnQobm9kZXMpKVxuICByZXR1cm4gcGFyZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCByZW1vdmUgPSBlbCA9PiBlbC5yZW1vdmUoKVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBmXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgZikgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmKVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBmXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgZikgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBmKVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtBcnJheTxwYWlyLlBhaXI8c3RyaW5nLEV2ZW50TGlzdGVuZXI+Pn0gbGlzdGVuZXJzXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFkZEV2ZW50TGlzdGVuZXJzID0gKG5vZGUsIGxpc3RlbmVycykgPT4ge1xuICBwYWlyLmZvckVhY2gobGlzdGVuZXJzLCAobmFtZSwgZikgPT4gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCBmKSlcbiAgcmV0dXJuIG5vZGVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxFdmVudExpc3RlbmVyPj59IGxpc3RlbmVyc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCByZW1vdmVFdmVudExpc3RlbmVycyA9IChub2RlLCBsaXN0ZW5lcnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGxpc3RlbmVycywgKG5hbWUsIGYpID0+IHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgbmFtZSwgZikpXG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+fHBhaXIuUGFpcjxzdHJpbmcsYm9vbGVhbj4+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGVsZW1lbnQgPSAobmFtZSwgYXR0cnMgPSBbXSwgY2hpbGRyZW4gPSBbXSkgPT5cbiAgYXBwZW5kKHNldEF0dHJpYnV0ZXMoY3JlYXRlRWxlbWVudChuYW1lKSwgYXR0cnMpLCBjaGlsZHJlbilcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjYW52YXMgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICBjb25zdCBjID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKVxuICBjLmhlaWdodCA9IGhlaWdodFxuICBjLndpZHRoID0gd2lkdGhcbiAgcmV0dXJuIGNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdFxuICogQHJldHVybiB7VGV4dH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB0ZXh0ID0gY3JlYXRlVGV4dE5vZGVcblxuLyoqXG4gKiBAcGFyYW0ge3BhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPn0gcGFpclxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHBhaXJUb1N0eWxlU3RyaW5nID0gcGFpciA9PiBgJHtwYWlyLmxlZnR9OiR7cGFpci5yaWdodH07YFxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+Pn0gcGFpcnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBwYWlyc1RvU3R5bGVTdHJpbmcgPSBwYWlycyA9PiBwYWlycy5tYXAocGFpclRvU3R5bGVTdHJpbmcpLmpvaW4oJycpXG5cbi8qKlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLHN0cmluZz59IG1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBtYXBUb1N0eWxlU3RyaW5nID0gbSA9PiBtYXAubWFwKG0sICh2YWx1ZSwga2V5KSA9PiBgJHtrZXl9OiR7dmFsdWV9O2ApLmpvaW4oJycpXG5cbi8qKlxuICogQHRvZG8gc2hvdWxkIGFsd2F5cyBxdWVyeSBvbiBhIGRvbSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTaGFkb3dSb290fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcXVlcnlTZWxlY3RvciA9IChlbCwgcXVlcnkpID0+IGVsLnF1ZXJ5U2VsZWN0b3IocXVlcnkpXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTaGFkb3dSb290fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtOb2RlTGlzdE9mPEhUTUxFbGVtZW50Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBxdWVyeVNlbGVjdG9yQWxsID0gKGVsLCBxdWVyeSkgPT4gZWwucXVlcnlTZWxlY3RvckFsbChxdWVyeSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRCeUlkID0gaWQgPT4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGRvYy5nZXRFbGVtZW50QnlJZChpZCkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgX3BhcnNlID0gaHRtbCA9PiBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKGA8aHRtbD48Ym9keT4ke2h0bWx9PC9ib2R5PjwvaHRtbD5gLCAndGV4dC9odG1sJykuYm9keVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlRnJhZ21lbnQgPSBodG1sID0+IGZyYWdtZW50KC8qKiBAdHlwZSB7YW55fSAqLyAoX3BhcnNlKGh0bWwpLmNoaWxkTm9kZXMpKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBwYXJzZUVsZW1lbnQgPSBodG1sID0+IC8qKiBAdHlwZSBIVE1MRWxlbWVudCAqLyAoX3BhcnNlKGh0bWwpLmZpcnN0RWxlbWVudENoaWxkKVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9sZEVsXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IG5ld0VsXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcmVwbGFjZVdpdGggPSAob2xkRWwsIG5ld0VsKSA9PiBvbGRFbC5yZXBsYWNlV2l0aChuZXdFbClcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge05vZGV8bnVsbH0gcmVmXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpbnNlcnRCZWZvcmUgPSAocGFyZW50LCBlbCwgcmVmKSA9PiBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCByZWYpXG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnRcbiAqIEBwYXJhbSB7Tm9kZX0gY2hpbGRcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgYXBwZW5kQ2hpbGQgPSAocGFyZW50LCBjaGlsZCkgPT4gcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXG5leHBvcnQgY29uc3QgRUxFTUVOVF9OT0RFID0gZG9jLkVMRU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IFRFWFRfTk9ERSA9IGRvYy5URVhUX05PREVcbmV4cG9ydCBjb25zdCBDREFUQV9TRUNUSU9OX05PREUgPSBkb2MuQ0RBVEFfU0VDVElPTl9OT0RFXG5leHBvcnQgY29uc3QgQ09NTUVOVF9OT0RFID0gZG9jLkNPTU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX05PREUgPSBkb2MuRE9DVU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX1RZUEVfTk9ERSA9IGRvYy5ET0NVTUVOVF9UWVBFX05PREVcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gZG9jLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrTm9kZVR5cGUgPSAobm9kZSwgdHlwZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gdHlwZVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjaGlsZFxuICovXG5leHBvcnQgY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGxldCBwID0gY2hpbGQucGFyZW50Tm9kZVxuICB3aGlsZSAocCAmJiBwICE9PSBwYXJlbnQpIHtcbiAgICBwID0gcC5wYXJlbnROb2RlXG4gIH1cbiAgcmV0dXJuIHAgPT09IHBhcmVudFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/dom.js\n')},"../CoCreate-crdt/node_modules/lib0/encoding.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Encoder": () => (/* binding */ Encoder),\n/* harmony export */   "createEncoder": () => (/* binding */ createEncoder),\n/* harmony export */   "length": () => (/* binding */ length),\n/* harmony export */   "toUint8Array": () => (/* binding */ toUint8Array),\n/* harmony export */   "write": () => (/* binding */ write),\n/* harmony export */   "set": () => (/* binding */ set),\n/* harmony export */   "writeUint8": () => (/* binding */ writeUint8),\n/* harmony export */   "setUint8": () => (/* binding */ setUint8),\n/* harmony export */   "writeUint16": () => (/* binding */ writeUint16),\n/* harmony export */   "setUint16": () => (/* binding */ setUint16),\n/* harmony export */   "writeUint32": () => (/* binding */ writeUint32),\n/* harmony export */   "writeUint32BigEndian": () => (/* binding */ writeUint32BigEndian),\n/* harmony export */   "setUint32": () => (/* binding */ setUint32),\n/* harmony export */   "writeVarUint": () => (/* binding */ writeVarUint),\n/* harmony export */   "writeVarInt": () => (/* binding */ writeVarInt),\n/* harmony export */   "writeVarString": () => (/* binding */ writeVarString),\n/* harmony export */   "writeBinaryEncoder": () => (/* binding */ writeBinaryEncoder),\n/* harmony export */   "writeUint8Array": () => (/* binding */ writeUint8Array),\n/* harmony export */   "writeVarUint8Array": () => (/* binding */ writeVarUint8Array),\n/* harmony export */   "writeOnDataView": () => (/* binding */ writeOnDataView),\n/* harmony export */   "writeFloat32": () => (/* binding */ writeFloat32),\n/* harmony export */   "writeFloat64": () => (/* binding */ writeFloat64),\n/* harmony export */   "writeBigInt64": () => (/* binding */ writeBigInt64),\n/* harmony export */   "writeBigUint64": () => (/* binding */ writeBigUint64),\n/* harmony export */   "writeAny": () => (/* binding */ writeAny),\n/* harmony export */   "RleEncoder": () => (/* binding */ RleEncoder),\n/* harmony export */   "IntDiffEncoder": () => (/* binding */ IntDiffEncoder),\n/* harmony export */   "RleIntDiffEncoder": () => (/* binding */ RleIntDiffEncoder),\n/* harmony export */   "UintOptRleEncoder": () => (/* binding */ UintOptRleEncoder),\n/* harmony export */   "IncUintOptRleEncoder": () => (/* binding */ IncUintOptRleEncoder),\n/* harmony export */   "IntDiffOptRleEncoder": () => (/* binding */ IntDiffOptRleEncoder),\n/* harmony export */   "StringEncoder": () => (/* binding */ StringEncoder)\n/* harmony export */ });\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "../CoCreate-crdt/node_modules/lib0/buffer.js");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "../CoCreate-crdt/node_modules/lib0/math.js");\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./number.js */ "../CoCreate-crdt/node_modules/lib0/number.js");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binary.js */ "../CoCreate-crdt/node_modules/lib0/binary.js");\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang\'s binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, \'Hello world!\')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => \'Hello world!\'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n\n\n\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder()\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nconst set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint16 = (encoder, num) => {\n  write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  write(encoder, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) {\n    write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num >>>= 7\n  }\n  write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don\'t use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarInt = (encoder, num) => {\n  const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_1__.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (isNegative ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT7 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 & num))\n  num >>>= 6\n  // We don\'t need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num >>>= 7\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst writeVarString = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nconst writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = _math_js__WEBPACK_IMPORTED_MODULE_1__.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nconst writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can\'t be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nconst writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case \'string\':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case \'number\':\n      if (_number_js__WEBPACK_IMPORTED_MODULE_3__.isInteger(data) && data <= _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case \'bigint\':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case \'object\':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case \'boolean\':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nclass RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nclass IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nclass RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nclass UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nclass IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nclass IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nclass StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = \'\'\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = \'\'\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = \'\'\n    writeVarString(encoder, this.sarr.join(\'\'))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZW5jb2RpbmcuanM/NTc3NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0o7QUFDSTtBQUNBOztBQUVyQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFdBQVc7QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBMEM7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQTBDO0FBQ2hFLGtDQUFrQyx5Q0FBUTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZW5jb2RpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZW5jb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2VuY29kaW5nXSB3aXRoIFtsaWIwL2RlY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gbmV3IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IG5ldyBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZW5jb2RpbmdcbiAqL1xuXG5pbXBvcnQgKiBhcyBidWZmZXIgZnJvbSAnLi9idWZmZXIuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIG51bWJlciBmcm9tICcuL251bWJlci5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcblxuLyoqXG4gKiBBIEJpbmFyeUVuY29kZXIgaGFuZGxlcyB0aGUgZW5jb2RpbmcgdG8gYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5jcG9zID0gMFxuICAgIHRoaXMuY2J1ZiA9IG5ldyBVaW50OEFycmF5KDEwMClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VWludDhBcnJheT59XG4gICAgICovXG4gICAgdGhpcy5idWZzID0gW11cbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7RW5jb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVuY29kZXIgPSAoKSA9PiBuZXcgRW5jb2RlcigpXG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBlbmNvZGVkIGRhdGEuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGxlbmd0aCA9IGVuY29kZXIgPT4ge1xuICBsZXQgbGVuID0gZW5jb2Rlci5jcG9zXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGVuICs9IGVuY29kZXIuYnVmc1tpXS5sZW5ndGhcbiAgfVxuICByZXR1cm4gbGVuXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRvIFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IFRoZSBjcmVhdGVkIEFycmF5QnVmZmVyLlxuICovXG5leHBvcnQgY29uc3QgdG9VaW50OEFycmF5ID0gZW5jb2RlciA9PiB7XG4gIGNvbnN0IHVpbnQ4YXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKGVuY29kZXIpKVxuICBsZXQgY3VyUG9zID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGQgPSBlbmNvZGVyLmJ1ZnNbaV1cbiAgICB1aW50OGFyci5zZXQoZCwgY3VyUG9zKVxuICAgIGN1clBvcyArPSBkLmxlbmd0aFxuICB9XG4gIHVpbnQ4YXJyLnNldChidWZmZXIuY3JlYXRlVWludDhBcnJheVZpZXdGcm9tQXJyYXlCdWZmZXIoZW5jb2Rlci5jYnVmLmJ1ZmZlciwgMCwgZW5jb2Rlci5jcG9zKSwgY3VyUG9zKVxuICByZXR1cm4gdWludDhhcnJcbn1cblxuLyoqXG4gKiBWZXJpZnkgdGhhdCBpdCBpcyBwb3NzaWJsZSB0byB3cml0ZSBgbGVuYCBieXRlcyB3dGlob3V0IGNoZWNraW5nLiBJZlxuICogbmVjZXNzYXJ5LCBhIG5ldyBCdWZmZXIgd2l0aCB0aGUgcmVxdWlyZWQgbGVuZ3RoIGlzIGF0dGFjaGVkLlxuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICovXG5jb25zdCB2ZXJpZnlMZW4gPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgaWYgKGJ1ZmZlckxlbiAtIGVuY29kZXIuY3BvcyA8IGxlbikge1xuICAgIGVuY29kZXIuYnVmcy5wdXNoKGJ1ZmZlci5jcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlcihlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpKVxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1hdGgubWF4KGJ1ZmZlckxlbiwgbGVuKSAqIDIpXG4gICAgZW5jb2Rlci5jcG9zID0gMFxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGJ5dGUgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGUgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgaWYgKGVuY29kZXIuY3BvcyA9PT0gYnVmZmVyTGVuKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKVxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbiAqIDIpXG4gICAgZW5jb2Rlci5jcG9zID0gMFxuICB9XG4gIGVuY29kZXIuY2J1ZltlbmNvZGVyLmNwb3MrK10gPSBudW1cbn1cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhdCBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICogUG9zaXRpb24gbXVzdCBhbHJlYWR5IGJlIHdyaXR0ZW4gKGkuZS4gZW5jb2Rlci5sZW5ndGggPiBwb3MpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgUG9zaXRpb24gdG8gd2hpY2ggdG8gd3JpdGUgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBVbnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gKi9cbmV4cG9ydCBjb25zdCBzZXQgPSAoZW5jb2RlciwgcG9zLCBudW0pID0+IHtcbiAgbGV0IGJ1ZmZlciA9IG51bGxcbiAgLy8gaXRlcmF0ZSBhbGwgYnVmZmVycyBhbmQgYWRqdXN0IHBvc2l0aW9uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aCAmJiBidWZmZXIgPT09IG51bGw7IGkrKykge1xuICAgIGNvbnN0IGIgPSBlbmNvZGVyLmJ1ZnNbaV1cbiAgICBpZiAocG9zIDwgYi5sZW5ndGgpIHtcbiAgICAgIGJ1ZmZlciA9IGIgLy8gZm91bmQgYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyAtPSBiLmxlbmd0aFxuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyID09PSBudWxsKSB7XG4gICAgLy8gdXNlIGN1cnJlbnQgYnVmZmVyXG4gICAgYnVmZmVyID0gZW5jb2Rlci5jYnVmXG4gIH1cbiAgYnVmZmVyW3Bvc10gPSBudW1cbn1cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50OCA9IHdyaXRlXG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgYXMgYW4gdW5zaWduZWQgSW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgc2V0VWludDggPSBzZXRcblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDE2ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICB3cml0ZShlbmNvZGVyLCBudW0gJiBiaW5hcnkuQklUUzgpXG4gIHdyaXRlKGVuY29kZXIsIChudW0gPj4+IDgpICYgYmluYXJ5LkJJVFM4KVxufVxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgc2V0VWludDE2ID0gKGVuY29kZXIsIHBvcywgbnVtKSA9PiB7XG4gIHNldChlbmNvZGVyLCBwb3MsIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgc2V0KGVuY29kZXIsIHBvcyArIDEsIChudW0gPj4+IDgpICYgYmluYXJ5LkJJVFM4KVxufVxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQzMiA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB3cml0ZShlbmNvZGVyLCBudW0gJiBiaW5hcnkuQklUUzgpXG4gICAgbnVtID4+Pj0gOFxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnIGVuZGlhbiBvcmRlci5cbiAqIChtb3N0IHNpZ25pZmljYW50IGJ5dGUgZmlyc3QpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQzMkJpZ0VuZGlhbiA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgKG51bSA+Pj4gKDggKiBpKSkgJiBiaW5hcnkuQklUUzgpXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgc2V0VWludDMyID0gKGVuY29kZXIsIHBvcywgbnVtKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2V0KGVuY29kZXIsIHBvcyArIGksIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgICBudW0gPj4+PSA4XG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEVuY29kZXMgaW50ZWdlcnMgaW4gdGhlIHJhbmdlIGZyb20gWzAsIDQyOTQ5NjcyOTVdIC8gWzAsIDB4ZmZmZmZmZmZdLiAobWF4IDMyIGJpdCB1bnNpZ25lZCBpbnRlZ2VyKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJVaW50ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICB3aGlsZSAobnVtID4gYmluYXJ5LkJJVFM3KSB7XG4gICAgd3JpdGUoZW5jb2RlciwgYmluYXJ5LkJJVDggfCAoYmluYXJ5LkJJVFM3ICYgbnVtKSlcbiAgICBudW0gPj4+PSA3XG4gIH1cbiAgd3JpdGUoZW5jb2RlciwgYmluYXJ5LkJJVFM3ICYgbnVtKVxufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIGludGVnZXIuXG4gKlxuICogRW5jb2RlcyBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgZnJvbSBbLTIxNDc0ODM2NDgsIC0yMTQ3NDgzNjQ3XS5cbiAqXG4gKiBXZSBkb24ndCB1c2UgemlnLXphZyBlbmNvZGluZyBiZWNhdXNlIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3B0aW9uIG9wZW5cbiAqIHRvIHVzZSB0aGUgc2FtZSBmdW5jdGlvbiBmb3IgQmlnSW50IGFuZCA1M2JpdCBpbnRlZ2VycyAoZG91YmxlcykuXG4gKlxuICogV2UgdXNlIHRoZSA3dGggYml0IGluc3RlYWQgZm9yIHNpZ25hbGluZyB0aGF0IHRoaXMgaXMgYSBuZWdhdGl2ZSBudW1iZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVZhckludCA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgaXNOZWdhdGl2ZSA9IG1hdGguaXNOZWdhdGl2ZVplcm8obnVtKVxuICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgIG51bSA9IC1udW1cbiAgfVxuICAvLyAgICAgICAgICAgICB8LSB3aGV0aGVyIHRvIGNvbnRpbnVlIHJlYWRpbmcgICAgICAgICB8LSB3aGV0aGVyIGlzIG5lZ2F0aXZlICAgICB8LSBudW1iZXJcbiAgd3JpdGUoZW5jb2RlciwgKG51bSA+IGJpbmFyeS5CSVRTNiA/IGJpbmFyeS5CSVQ4IDogMCkgfCAoaXNOZWdhdGl2ZSA/IGJpbmFyeS5CSVQ3IDogMCkgfCAoYmluYXJ5LkJJVFM2ICYgbnVtKSlcbiAgbnVtID4+Pj0gNlxuICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBjYXNlIG9mIG51bSA9PT0gMCBzbyB3ZSBjYW4gdXNlIGEgZGlmZmVyZW50XG4gIC8vIHBhdHRlcm4gaGVyZSB0aGFuIGFib3ZlLlxuICB3aGlsZSAobnVtID4gMCkge1xuICAgIHdyaXRlKGVuY29kZXIsIChudW0gPiBiaW5hcnkuQklUUzcgPyBiaW5hcnkuQklUOCA6IDApIHwgKGJpbmFyeS5CSVRTNyAmIG51bSkpXG4gICAgbnVtID4+Pj0gN1xuICB9XG59XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJTdHJpbmcgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSlcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGhcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSkpXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSB0aGUgY29udGVudCBvZiBhbm90aGVyIEVuY29kZXIuXG4gKlxuICogQFRPRE86IGNhbiBiZSBpbXByb3ZlZCFcbiAqICAgICAgICAtIE5vdGU6IFNob3VsZCBjb25zaWRlciB0aGF0IHdoZW4gYXBwZW5kaW5nIGEgbG90IG9mIHNtYWxsIEVuY29kZXJzLCB3ZSBzaG91bGQgcmF0aGVyIGNsb25lIHRoYW4gcmVmZXJlbmNpbmcgdGhlIG9sZCBzdHJ1Y3R1cmUuXG4gKiAgICAgICAgICAgICAgICBFbmNvZGVycyBzdGFydCB3aXRoIGEgcmF0aGVyIGJpZyBpbml0aWFsIGJ1ZmZlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciBUaGUgZW5VaW50OEFyclxuICogQHBhcmFtIHtFbmNvZGVyfSBhcHBlbmQgVGhlIEJpbmFyeUVuY29kZXIgdG8gYmUgd3JpdHRlbi5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlQmluYXJ5RW5jb2RlciA9IChlbmNvZGVyLCBhcHBlbmQpID0+IHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB0b1VpbnQ4QXJyYXkoYXBwZW5kKSlcblxuLyoqXG4gKiBBcHBlbmQgZml4ZWQtbGVuZ3RoIFVpbnQ4QXJyYXkgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aFxuICBjb25zdCBjcG9zID0gZW5jb2Rlci5jcG9zXG4gIGNvbnN0IGxlZnRDb3B5TGVuID0gbWF0aC5taW4oYnVmZmVyTGVuIC0gY3BvcywgdWludDhBcnJheS5sZW5ndGgpXG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW5cbiAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KDAsIGxlZnRDb3B5TGVuKSwgY3BvcylcbiAgZW5jb2Rlci5jcG9zICs9IGxlZnRDb3B5TGVuXG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgLy8gU3RpbGwgc29tZXRoaW5nIHRvIHdyaXRlLCB3cml0ZSByaWdodCBoYWxmLi5cbiAgICAvLyBBcHBlbmQgbmV3IGJ1ZmZlclxuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1ZilcbiAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgc2l6ZSBvZiByZW1haW5pbmcgYnVmZmVyXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF0aC5tYXgoYnVmZmVyTGVuICogMiwgcmlnaHRDb3B5TGVuKSlcbiAgICAvLyBjb3B5IGFycmF5XG4gICAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KGxlZnRDb3B5TGVuKSlcbiAgICBlbmNvZGVyLmNwb3MgPSByaWdodENvcHlMZW5cbiAgfVxufVxuXG4vKipcbiAqIEFwcGVuZCBhbiBVaW50OEFycmF5IHRvIEVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aClcbiAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHVpbnQ4QXJyYXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIERhdGFWaWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzLiBVc2UgaXQgdG8gd3JpdGUgZGF0YSBhZnRlclxuICogY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiAvLyB3cml0ZSBmbG9hdDMyIHVzaW5nIERhdGFWaWV3XG4gKiBjb25zdCBkdiA9IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA0KVxuICogZHYuc2V0RmxvYXQzMigwLCAxLjEpXG4gKiAvLyByZWFkIGZsb2F0MzIgdXNpbmcgRGF0YVZpZXdcbiAqIGNvbnN0IGR2ID0gcmVhZEZyb21EYXRhVmlldyhlbmNvZGVyLCA0KVxuICogZHYuZ2V0RmxvYXQzMigwKSAvLyA9PiAxLjEwMDAwMDAyMzg0MTg1OCAobGVhdmluZyBpdCB0byB0aGUgcmVhZGVyIHRvIGZpbmQgb3V0IHdoeSB0aGlzIGlzIHRoZSBjb3JyZWN0IHJlc3VsdClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHJldHVybiB7RGF0YVZpZXd9XG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZU9uRGF0YVZpZXcgPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIHZlcmlmeUxlbihlbmNvZGVyLCBsZW4pXG4gIGNvbnN0IGR2aWV3ID0gbmV3IERhdGFWaWV3KGVuY29kZXIuY2J1Zi5idWZmZXIsIGVuY29kZXIuY3BvcywgbGVuKVxuICBlbmNvZGVyLmNwb3MgKz0gbGVuXG4gIHJldHVybiBkdmlld1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVGbG9hdDMyID0gKGVuY29kZXIsIG51bSkgPT4gd3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDQpLnNldEZsb2F0MzIoMCwgbnVtKVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVGbG9hdDY0ID0gKGVuY29kZXIsIG51bSkgPT4gd3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpLnNldEZsb2F0NjQoMCwgbnVtKVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtiaWdpbnR9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVCaWdJbnQ2NCA9IChlbmNvZGVyLCBudW0pID0+IC8qKiBAdHlwZSB7YW55fSAqLyAod3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpKS5zZXRCaWdJbnQ2NCgwLCBudW0pXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge2JpZ2ludH0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUJpZ1VpbnQ2NCA9IChlbmNvZGVyLCBudW0pID0+IC8qKiBAdHlwZSB7YW55fSAqLyAod3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpKS5zZXRCaWdVaW50NjQoMCwgbnVtKVxuXG5jb25zdCBmbG9hdFRlc3RCZWQgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDQpKVxuLyoqXG4gKiBDaGVjayBpZiBhIG51bWJlciBjYW4gYmUgZW5jb2RlZCBhcyBhIDMyIGJpdCBmbG9hdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc0Zsb2F0MzIgPSBudW0gPT4ge1xuICBmbG9hdFRlc3RCZWQuc2V0RmxvYXQzMigwLCBudW0pXG4gIHJldHVybiBmbG9hdFRlc3RCZWQuZ2V0RmxvYXQzMigwKSA9PT0gbnVtXG59XG5cbi8qKlxuICogRW5jb2RlIGRhdGEgd2l0aCBlZmZpY2llbnQgYmluYXJ5IGZvcm1hdC5cbiAqXG4gKiBEaWZmZXJlbmNlcyB0byBKU09OOlxuICog4oCiIFRyYW5zZm9ybXMgZGF0YSB0byBhIGJpbmFyeSBmb3JtYXQgKG5vdCB0byBhIHN0cmluZylcbiAqIOKAoiBFbmNvZGVzIHVuZGVmaW5lZCwgTmFOLCBhbmQgQXJyYXlCdWZmZXIgKHRoZXNlIGNhbid0IGJlIHJlcHJlc2VudGVkIGluIEpTT04pXG4gKiDigKIgTnVtYmVycyBhcmUgZWZmaWNpZW50bHkgZW5jb2RlZCBlaXRoZXIgYXMgYSB2YXJpYWJsZSBsZW5ndGggaW50ZWdlciwgYXMgYVxuICogICAzMiBiaXQgZmxvYXQsIGFzIGEgNjQgYml0IGZsb2F0LCBvciBhcyBhIDY0IGJpdCBiaWdpbnQuXG4gKlxuICogRW5jb2RpbmcgdGFibGU6XG4gKlxuICogfCBEYXRhIFR5cGUgICAgICAgICAgIHwgUHJlZml4ICAgfCBFbmNvZGluZyBNZXRob2QgICAgfCBDb21tZW50IHxcbiAqIHwgLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLSB8XG4gKiB8IHVuZGVmaW5lZCAgICAgICAgICAgfCAxMjcgICAgICB8ICAgICAgICAgICAgICAgICAgICB8IEZ1bmN0aW9ucywgc3ltYm9sLCBhbmQgZXZlcnl0aGluZyB0aGF0IGNhbm5vdCBiZSBpZGVudGlmaWVkIGlzIGVuY29kZWQgYXMgdW5kZWZpbmVkIHxcbiAqIHwgbnVsbCAgICAgICAgICAgICAgICB8IDEyNiAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgfFxuICogfCBpbnRlZ2VyICAgICAgICAgICAgIHwgMTI1ICAgICAgfCB3cml0ZVZhckludCAgICAgICAgfCBPbmx5IGVuY29kZXMgMzIgYml0IHNpZ25lZCBpbnRlZ2VycyB8XG4gKiB8IGZsb2F0MzIgICAgICAgICAgICAgfCAxMjQgICAgICB8IHdyaXRlRmxvYXQzMiAgICAgICB8IHxcbiAqIHwgZmxvYXQ2NCAgICAgICAgICAgICB8IDEyMyAgICAgIHwgd3JpdGVGbG9hdDY0ICAgICAgIHwgfFxuICogfCBiaWdpbnQgICAgICAgICAgICAgIHwgMTIyICAgICAgfCB3cml0ZUJpZ0ludDY0ICAgICAgfCB8XG4gKiB8IGJvb2xlYW4gKGZhbHNlKSAgICAgfCAxMjEgICAgICB8ICAgICAgICAgICAgICAgICAgICB8IFRydWUgYW5kIGZhbHNlIGFyZSBkaWZmZXJlbnQgZGF0YSB0eXBlcyBzbyB3ZSBzYXZlIHRoZSBmb2xsb3dpbmcgYnl0ZSB8XG4gKiB8IGJvb2xlYW4gKHRydWUpICAgICAgfCAxMjAgICAgICB8ICAgICAgICAgICAgICAgICAgICB8IC0gMGIwMTExMTAwMCBzbyB0aGUgbGFzdCBiaXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRydWUgb3IgZmFsc2UgfFxuICogfCBzdHJpbmcgICAgICAgICAgICAgIHwgMTE5ICAgICAgfCB3cml0ZVZhclN0cmluZyAgICAgfCB8XG4gKiB8IG9iamVjdDxzdHJpbmcsYW55PiAgfCAxMTggICAgICB8IGN1c3RvbSAgICAgICAgICAgICB8IFdyaXRlcyB7bGVuZ3RofSB0aGVuIHtsZW5ndGh9IGtleS12YWx1ZSBwYWlycyB8XG4gKiB8IGFycmF5PGFueT4gICAgICAgICAgfCAxMTcgICAgICB8IGN1c3RvbSAgICAgICAgICAgICB8IFdyaXRlcyB7bGVuZ3RofSB0aGVuIHtsZW5ndGh9IGpzb24gdmFsdWVzIHxcbiAqIHwgVWludDhBcnJheSAgICAgICAgICB8IDExNiAgICAgIHwgd3JpdGVWYXJVaW50OEFycmF5IHwgV2UgdXNlIFVpbnQ4QXJyYXkgZm9yIGFueSBraW5kIG9mIGJpbmFyeSBkYXRhIHxcbiAqXG4gKiBSZWFzb25zIGZvciB0aGUgZGVjcmVhc2luZyBwcmVmaXg6XG4gKiBXZSBuZWVkIHRoZSBmaXJzdCBiaXQgZm9yIGV4dGVuZGFiaWxpdHkgKGxhdGVyIHdlIG1heSB3YW50IHRvIGVuY29kZSB0aGVcbiAqIHByZWZpeCB3aXRoIHdyaXRlVmFyVWludCkuIFRoZSByZW1haW5pbmcgNyBiaXRzIGFyZSBkaXZpZGVkIGFzIGZvbGxvd3M6XG4gKiBbMC0zMF0gICB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXRhIHJhbmdlIGlzIHVzZWQgZm9yIGN1c3RvbSBwdXJwb3Nlc1xuICogICAgICAgICAgKGRlZmluZWQgYnkgdGhlIGZ1bmN0aW9uIHRoYXQgdXNlcyB0aGlzIGxpYnJhcnkpXG4gKiBbMzEtMTI3XSB0aGUgZW5kIG9mIHRoZSBkYXRhIHJhbmdlIGlzIHVzZWQgZm9yIGRhdGEgZW5jb2RpbmcgYnlcbiAqICAgICAgICAgIGxpYjAvZW5jb2RpbmcuanNcbiAqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7dW5kZWZpbmVkfG51bGx8bnVtYmVyfGJpZ2ludHxib29sZWFufHN0cmluZ3xPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxVaW50OEFycmF5fSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUFueSA9IChlbmNvZGVyLCBkYXRhKSA9PiB7XG4gIHN3aXRjaCAodHlwZW9mIGRhdGEpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gVFlQRSAxMTk6IFNUUklOR1xuICAgICAgd3JpdGUoZW5jb2RlciwgMTE5KVxuICAgICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXIuaXNJbnRlZ2VyKGRhdGEpICYmIGRhdGEgPD0gYmluYXJ5LkJJVFMzMSkge1xuICAgICAgICAvLyBUWVBFIDEyNTogSU5URUdFUlxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjUpXG4gICAgICAgIHdyaXRlVmFySW50KGVuY29kZXIsIGRhdGEpXG4gICAgICB9IGVsc2UgaWYgKGlzRmxvYXQzMihkYXRhKSkge1xuICAgICAgICAvLyBUWVBFIDEyNDogRkxPQVQzMlxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjQpXG4gICAgICAgIHdyaXRlRmxvYXQzMihlbmNvZGVyLCBkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVFlQRSAxMjM6IEZMT0FUNjRcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTIzKVxuICAgICAgICB3cml0ZUZsb2F0NjQoZW5jb2RlciwgZGF0YSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIC8vIFRZUEUgMTIyOiBCaWdJbnRcbiAgICAgIHdyaXRlKGVuY29kZXIsIDEyMilcbiAgICAgIHdyaXRlQmlnSW50NjQoZW5jb2RlciwgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRZUEUgMTI2OiBudWxsXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyNilcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIC8vIFRZUEUgMTE3OiBBcnJheVxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMTcpXG4gICAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBkYXRhLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd3JpdGVBbnkoZW5jb2RlciwgZGF0YVtpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAvLyBUWVBFIDExNjogQXJyYXlCdWZmZXJcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE2KVxuICAgICAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRZUEUgMTE4OiBPYmplY3RcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE4KVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGtleXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgd3JpdGVWYXJTdHJpbmcoZW5jb2Rlciwga2V5KVxuICAgICAgICAgIHdyaXRlQW55KGVuY29kZXIsIGRhdGFba2V5XSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIC8vIFRZUEUgMTIwLzEyMTogYm9vbGVhbiAodHJ1ZS9mYWxzZSlcbiAgICAgIHdyaXRlKGVuY29kZXIsIGRhdGEgPyAxMjAgOiAxMjEpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUWVBFIDEyNzogdW5kZWZpbmVkXG4gICAgICB3cml0ZShlbmNvZGVyLCAxMjcpXG4gIH1cbn1cblxuLyoqXG4gKiBOb3cgY29tZSBhIGZldyBzdGF0ZWZ1bCBlbmNvZGVyIHRoYXQgaGF2ZSB0aGVpciBvd24gY2xhc3Nlcy5cbiAqL1xuXG4vKipcbiAqIEJhc2ljIFJ1biBMZW5ndGggRW5jb2RlciAtIGEgYmFzaWMgY29tcHJlc3Npb24gaW1wbGVtZW50YXRpb24uXG4gKlxuICogRW5jb2RlcyBbMSwxLDEsN10gdG8gWzEsMyw3LDFdICgzIHRpbWVzIDEsIDEgdGltZSA3KS4gVGhpcyBlbmNvZGVyIG1pZ2h0IGRvIG1vcmUgaGFybSB0aGFuIGdvb2QgaWYgdGhlcmUgYXJlIGEgbG90IG9mIHZhbHVlcyB0aGF0IGFyZSBub3QgcmVwZWF0ZWQuXG4gKlxuICogSXQgd2FzIG9yaWdpbmFsbHkgdXNlZCBmb3IgaW1hZ2UgY29tcHJlc3Npb24uIENvb2wgLi4gYXJ0aWNsZSBodHRwOi8vY3NicnVjZS5jb20vY2JtL3RyYW5zYWN0b3IvcGRmcy90cmFuc192N19pMDYucGRmXG4gKlxuICogQG5vdGUgVCBtdXN0IG5vdCBiZSBudWxsIVxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVuY29kZXIsIFQpOnZvaWR9IHdyaXRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHdyaXRlcikge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBUaGUgd3JpdGVyXG4gICAgICovXG4gICAgdGhpcy53ID0gd3JpdGVyXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtUfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zID0gbnVsbFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLCB0aGlzLmNvdW50IC0gMSkgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMCwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICAgIH1cbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICAvLyB3cml0ZSBmaXJzdCB2YWx1ZVxuICAgICAgdGhpcy53KHRoaXMsIHYpXG4gICAgICB0aGlzLnMgPSB2XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzaWMgZGlmZiBkZWNvZGVyIHVzaW5nIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBFbmNvZGVzIHRoZSB2YWx1ZXMgWzMsIDExMDAsIDExMDEsIDEwNTAsIDBdIHRvIFszLCAxMDk3LCAxLCAtNTEsIC0xMDUwXSB1c2luZyB3cml0ZVZhckludC5cbiAqL1xuZXhwb3J0IGNsYXNzIEludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIHdyaXRlVmFySW50KHRoaXMsIHYgLSB0aGlzLnMpXG4gICAgdGhpcy5zID0gdlxuICB9XG59XG5cbi8qKlxuICogQSBjb21iaW5hdGlvbiBvZiBJbnREaWZmRW5jb2RlciBhbmQgUmxlRW5jb2Rlci5cbiAqXG4gKiBCYXNpY2FsbHkgZmlyc3Qgd3JpdGVzIHRoZSBJbnREaWZmRW5jb2RlciBhbmQgdGhlbiBjb3VudHMgZHVwbGljYXRlIGRpZmZzIHVzaW5nIFJsZUVuY29kaW5nLlxuICpcbiAqIEVuY29kZXMgdGhlIHZhbHVlcyBbMSwxLDEsMiwzLDQsNSw2XSBhcyBbMSwxLDAsMiwxLDVdIChSTEUoWzEsMCwwLDEsMSwxLDEsMV0pIOKHkiBSbGVJbnREaWZmWzEsMSwwLDIsMSw1XSlcbiAqL1xuZXhwb3J0IGNsYXNzIFJsZUludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMucyA9PT0gdiAmJiB0aGlzLmNvdW50ID4gMCkge1xuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmNvdW50ID4gMCkge1xuICAgICAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAgICAgd3JpdGVWYXJVaW50KHRoaXMsIHRoaXMuY291bnQgLSAxKSAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAwLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgICAgfVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIC8vIHdyaXRlIGZpcnN0IHZhbHVlXG4gICAgICB3cml0ZVZhckludCh0aGlzLCB2IC0gdGhpcy5zKVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludE9wdFJsZUVuY29kZXJ9IGVuY29kZXJcbiAqL1xuY29uc3QgZmx1c2hVaW50T3B0UmxlRW5jb2RlciA9IGVuY29kZXIgPT4ge1xuICBpZiAoZW5jb2Rlci5jb3VudCA+IDApIHtcbiAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAvLyBjYXNlIDE6IGp1c3QgYSBzaW5nbGUgdmFsdWUuIHNldCBzaWduIHRvIHBvc2l0aXZlXG4gICAgLy8gY2FzZSAyOiB3cml0ZSBzZXZlcmFsIHZhbHVlcy4gc2V0IHNpZ24gdG8gbmVnYXRpdmUgdG8gaW5kaWNhdGUgdGhhdCB0aGVyZSBpcyBhIGxlbmd0aCBjb21pbmdcbiAgICB3cml0ZVZhckludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZXIuY291bnQgPT09IDEgPyBlbmNvZGVyLnMgOiAtZW5jb2Rlci5zKVxuICAgIGlmIChlbmNvZGVyLmNvdW50ID4gMSkge1xuICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2Rlci5jb3VudCAtIDIpIC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDEsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogT3B0aW1pemVkIFJsZSBlbmNvZGVyIHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb20gdGhlIG1lbnRpb25lZCBwcm9ibGVtIG9mIHRoZSBiYXNpYyBSbGUgZW5jb2Rlci5cbiAqXG4gKiBJbnRlcm5hbGx5IHVzZXMgVmFySW50IGVuY29kZXIgdG8gd3JpdGUgdW5zaWduZWQgaW50ZWdlcnMuIElmIHRoZSBpbnB1dCBvY2N1cnMgbXVsdGlwbGUgdGltZXMsIHdlIHdyaXRlXG4gKiB3cml0ZSBpdCBhcyBhIG5lZ2F0aXZlIG51bWJlci4gVGhlIFVpbnRPcHRSbGVEZWNvZGVyIHRoZW4gdW5kZXJzdGFuZHMgdGhhdCBpdCBuZWVkcyB0byByZWFkIGEgY291bnQuXG4gKlxuICogRW5jb2RlcyBbMSwyLDMsMywzXSBhcyBbMSwyLC0zLDNdIChvbmNlIDEsIG9uY2UgMiwgdGhyZWUgdGltZXMgMylcbiAqL1xuZXhwb3J0IGNsYXNzIFVpbnRPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaFVpbnRPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogSW5jcmVhc2luZyBVaW50IE9wdGltaXplZCBSTEUgRW5jb2RlclxuICpcbiAqIFRoZSBSTEUgZW5jb2RlciBjb3VudHMgdGhlIG51bWJlciBvZiBzYW1lIG9jY3VyZW5jZXMgb2YgdGhlIHNhbWUgdmFsdWUuXG4gKiBUaGUgSW5jVWludE9wdFJsZSBlbmNvZGVyIGNvdW50cyBpZiB0aGUgdmFsdWUgaW5jcmVhc2VzLlxuICogSS5lLiA3LCA4LCA5LCAxMCB3aWxsIGJlIGVuY29kZWQgYXMgWy03LCA0XS4gMSwgMywgNSB3aWxsIGJlIGVuY29kZWRcbiAqIGFzIFsxLCAzLCA1XS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluY1VpbnRPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgKyB0aGlzLmNvdW50ID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SW50RGlmZk9wdFJsZUVuY29kZXJ9IGVuY29kZXJcbiAqL1xuY29uc3QgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2RlciA9IGVuY29kZXIgPT4ge1xuICBpZiAoZW5jb2Rlci5jb3VudCA+IDApIHtcbiAgICAvLyAgICAgICAgICAzMSBiaXQgbWFraW5nIHVwIHRoZSBkaWZmIHwgd2V0aGVyIHRvIHdyaXRlIHRoZSBjb3VudGVyXG4gICAgY29uc3QgZW5jb2RlZERpZmYgPSBlbmNvZGVyLmRpZmYgPDwgMSB8IChlbmNvZGVyLmNvdW50ID09PSAxID8gMCA6IDEpXG4gICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgLy8gY2FzZSAxOiBqdXN0IGEgc2luZ2xlIHZhbHVlLiBzZXQgZmlyc3QgYml0IHRvIHBvc2l0aXZlXG4gICAgLy8gY2FzZSAyOiB3cml0ZSBzZXZlcmFsIHZhbHVlcy4gc2V0IGZpcnN0IGJpdCB0byBuZWdhdGl2ZSB0byBpbmRpY2F0ZSB0aGF0IHRoZXJlIGlzIGEgbGVuZ3RoIGNvbWluZ1xuICAgIHdyaXRlVmFySW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2RlZERpZmYpXG4gICAgaWYgKGVuY29kZXIuY291bnQgPiAxKSB7XG4gICAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVyLmNvdW50IC0gMikgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMSwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbWJpbmF0aW9uIG9mIHRoZSBJbnREaWZmRW5jb2RlciBhbmQgdGhlIFVpbnRPcHRSbGVFbmNvZGVyLlxuICpcbiAqIFRoZSBjb3VudCBhcHByb2FjaCBpcyBzaW1pbGFyIHRvIHRoZSBVaW50RGlmZk9wdFJsZUVuY29kZXIsIGJ1dCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBuZWdhdGl2ZSBiaXRmbGFnLCBpdCBlbmNvZGVzXG4gKiBpbiB0aGUgTFNCIHdoZXRoZXIgYSBjb3VudCBpcyB0byBiZSByZWFkLiBUaGVyZWZvcmUgdGhpcyBFbmNvZGVyIG9ubHkgc3VwcG9ydHMgMzEgYml0IGludGVnZXJzIVxuICpcbiAqIEVuY29kZXMgWzEsIDIsIDMsIDJdIGFzIFszLCAxLCA2LCAtMV0gKG1vcmUgc3BlY2lmaWNhbGx5IFsoMSA8PCAxKSB8IDEsICgzIDw8IDApIHwgMCwgLTFdKVxuICpcbiAqIEludGVybmFsbHkgdXNlcyB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuIENvbnRyYXJ5IHRvIG5vcm1hbCBVaW50VmFyIGVuY29kaW5nLCB0aGUgZmlyc3QgYnl0ZSBjb250YWluczpcbiAqICogMSBiaXQgdGhhdCBkZW5vdGVzIHdoZXRoZXIgdGhlIG5leHQgdmFsdWUgaXMgYSBjb3VudCAoTFNCKVxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0aGlzIHZhbHVlIGlzIG5lZ2F0aXZlIChNU0IgLSAxKVxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0byBjb250aW51ZSByZWFkaW5nIHRoZSB2YXJpYWJsZSBsZW5ndGggaW50ZWdlciAoTVNCKVxuICpcbiAqIFRoZXJlZm9yZSwgb25seSBmaXZlIGJpdHMgcmVtYWluIHRvIGVuY29kZSBkaWZmIHJhbmdlcy5cbiAqXG4gKiBVc2UgdGhpcyBFbmNvZGVyIG9ubHkgd2hlbiBhcHByb3ByaWF0ZS4gSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBwcm9iYWJseSBhIGJhZCBpZGVhLlxuICovXG5leHBvcnQgY2xhc3MgSW50RGlmZk9wdFJsZUVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IEVuY29kZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gMFxuICAgIHRoaXMuY291bnQgPSAwXG4gICAgdGhpcy5kaWZmID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLmRpZmYgPT09IHYgLSB0aGlzLnMpIHtcbiAgICAgIHRoaXMucyA9IHZcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaEludERpZmZPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgdGhpcy5kaWZmID0gdiAtIHRoaXMuc1xuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogT3B0aW1pemVkIFN0cmluZyBFbmNvZGVyLlxuICpcbiAqIEVuY29kaW5nIG1hbnkgc21hbGwgc3RyaW5ncyBpbiBhIHNpbXBsZSBFbmNvZGVyIGlzIG5vdCB2ZXJ5IGVmZmljaWVudC4gVGhlIGZ1bmN0aW9uIGNhbGwgdG8gZGVjb2RlIGEgc3RyaW5nIHRha2VzIHNvbWUgdGltZSBhbmQgY3JlYXRlcyByZWZlcmVuY2VzIHRoYXQgbXVzdCBiZSBldmVudHVhbGx5IGRlbGV0ZWQuXG4gKiBJbiBwcmFjdGljZSwgd2hlbiBkZWNvZGluZyBzZXZlcmFsIG1pbGxpb24gc21hbGwgc3RyaW5ncywgdGhlIEdDIHdpbGwga2ljayBpbiBtb3JlIGFuZCBtb3JlIG9mdGVuIHRvIGNvbGxlY3Qgb3JwaGFuZWQgc3RyaW5nIG9iamVjdHMgKG9yIG1heWJlIHRoZXJlIGlzIGFub3RoZXIgcmVhc29uPykuXG4gKlxuICogVGhpcyBzdHJpbmcgZW5jb2RlciBzb2x2ZXMgdGhlIGFib3ZlIHByb2JsZW0uIEFsbCBzdHJpbmdzIGFyZSBjb25jYXRlbmF0ZWQgYW5kIHdyaXR0ZW4gYXMgYSBzaW5nbGUgc3RyaW5nIHVzaW5nIGEgc2luZ2xlIGVuY29kaW5nIGNhbGwuXG4gKlxuICogVGhlIGxlbmd0aHMgYXJlIGVuY29kZWQgdXNpbmcgYSBVaW50T3B0UmxlRW5jb2Rlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0VuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5zYXJyID0gW11cbiAgICB0aGlzLnMgPSAnJ1xuICAgIHRoaXMubGVuc0UgPSBuZXcgVWludE9wdFJsZUVuY29kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICovXG4gIHdyaXRlIChzdHJpbmcpIHtcbiAgICB0aGlzLnMgKz0gc3RyaW5nXG4gICAgaWYgKHRoaXMucy5sZW5ndGggPiAxOSkge1xuICAgICAgdGhpcy5zYXJyLnB1c2godGhpcy5zKVxuICAgICAgdGhpcy5zID0gJydcbiAgICB9XG4gICAgdGhpcy5sZW5zRS53cml0ZShzdHJpbmcubGVuZ3RoKVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IEVuY29kZXIoKVxuICAgIHRoaXMuc2Fyci5wdXNoKHRoaXMucylcbiAgICB0aGlzLnMgPSAnJ1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRoaXMuc2Fyci5qb2luKCcnKSlcbiAgICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5sZW5zRS50b1VpbnQ4QXJyYXkoKSlcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KGVuY29kZXIpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/encoding.js\n')},"../CoCreate-crdt/node_modules/lib0/environment.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isNode\": () => (/* binding */ isNode),\n/* harmony export */   \"isBrowser\": () => (/* binding */ isBrowser),\n/* harmony export */   \"isMac\": () => (/* binding */ isMac),\n/* harmony export */   \"hasParam\": () => (/* binding */ hasParam),\n/* harmony export */   \"getParam\": () => (/* binding */ getParam),\n/* harmony export */   \"getVariable\": () => (/* binding */ getVariable),\n/* harmony export */   \"getConf\": () => (/* binding */ getConf),\n/* harmony export */   \"hasConf\": () => (/* binding */ hasConf),\n/* harmony export */   \"production\": () => (/* binding */ production)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"../CoCreate-crdt/node_modules/lib0/map.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ \"../CoCreate-crdt/node_modules/lib0/string.js\");\n/* harmony import */ var _conditions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conditions.js */ \"../CoCreate-crdt/node_modules/lib0/conditions.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage.js */ \"../CoCreate-crdt/node_modules/lib0/storage.js\");\n/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\n\n\n\n\n\n/* istanbul ignore next */\n// @ts-ignore\nconst isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name)\n/* istanbul ignore next */\nconst isBrowser = typeof window !== 'undefined' && !isNode\n/* istanbul ignore next */\nconst isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* istanbul ignore next */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n      const pargs = process.argv\n      let currParamName = null\n      /* istanbul ignore next */\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n    // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n      // eslint-disable-next-line no-undef\n      ;(location.search || '?').slice(1).split('&').forEach(kv => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n          params.set(`-${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n    }\n  }\n  return params\n}\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasParam = name => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* istanbul ignore next */\nconst getParam = (name, defaultVal) => computeParams().get(name) || defaultVal\n// export const getArgs = name => computeParams() && args\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* istanbul ignore next */\nconst getVariable = name => isNode ? _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(process.env[name.toUpperCase()]) : _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(_storage_js__WEBPACK_IMPORTED_MODULE_3__.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\nconst getConf = name => computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasConf = name => hasParam('--' + name) || getVariable(name) !== null\n\n/* istanbul ignore next */\nconst production = hasConf('production')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZW52aXJvbm1lbnQuanM/OTcxMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDTTtBQUNRO0FBQ047O0FBRXZDO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPOztBQUVQO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkNBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSwyQ0FBVTtBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFvQixXQUFXO0FBQ3pELHlCQUF5QixxREFBb0IsV0FBVztBQUN4RDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsZUFBZSwyQ0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTyxxQ0FBcUMsMkRBQTBCLG9DQUFvQywyREFBMEIsQ0FBQywyREFBMEI7O0FBRS9KO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDTyIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9saWIwL2Vudmlyb25tZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJc29tb3JwaGljIG1vZHVsZSB0byB3b3JrIGFjY2VzcyB0aGUgZW52aXJvbm1lbnQgKHF1ZXJ5IHBhcmFtcywgZW52IHZhcmlhYmxlcykuXG4gKlxuICogQG1vZHVsZSBtYXBcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnLi9zdHJpbmcuanMnXG5pbXBvcnQgKiBhcyBjb25kaXRpb25zIGZyb20gJy4vY29uZGl0aW9ucy5qcydcbmltcG9ydCAqIGFzIHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlLmpzJ1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnJlbGVhc2UgJiYgL25vZGV8aW9cXC5qcy8udGVzdChwcm9jZXNzLnJlbGVhc2UubmFtZSlcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTm9kZVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc01hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogZmFsc2VcblxuLyoqXG4gKiBAdHlwZSB7TWFwPHN0cmluZyxzdHJpbmc+fVxuICovXG5sZXQgcGFyYW1zXG5jb25zdCBhcmdzID0gW11cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGNvbXB1dGVQYXJhbXMgPSAoKSA9PiB7XG4gIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgICAgY29uc3QgcGFyZ3MgPSBwcm9jZXNzLmFyZ3ZcbiAgICAgIGxldCBjdXJyUGFyYW1OYW1lID0gbnVsbFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyZyA9IHBhcmdzW2ldXG4gICAgICAgIGlmIChwYXJnWzBdID09PSAnLScpIHtcbiAgICAgICAgICBpZiAoY3VyclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zLnNldChjdXJyUGFyYW1OYW1lLCAnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyclBhcmFtTmFtZSA9IHBhcmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3VyclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zLnNldChjdXJyUGFyYW1OYW1lLCBwYXJnKVxuICAgICAgICAgICAgY3VyclBhcmFtTmFtZSA9IG51bGxcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncy5wdXNoKHBhcmcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VyclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMuc2V0KGN1cnJQYXJhbU5hbWUsICcnKVxuICAgICAgfVxuICAgIC8vIGluIFJlYWN0TmF0aXZlIGZvciBleGFtcGxlIHRoaXMgd291bGQgbm90IGJlIHRydWUgKHVubGVzcyBjb25uZWN0ZWQgdG8gdGhlIFJlbW90ZSBEZWJ1Z2dlcilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICA7KGxvY2F0aW9uLnNlYXJjaCB8fCAnPycpLnNsaWNlKDEpLnNwbGl0KCcmJykuZm9yRWFjaChrdiA9PiB7XG4gICAgICAgIGlmIChrdi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBrdi5zcGxpdCgnPScpXG4gICAgICAgICAgcGFyYW1zLnNldChgLS0ke3N0cmluZy5mcm9tQ2FtZWxDYXNlKGtleSwgJy0nKX1gLCB2YWx1ZSlcbiAgICAgICAgICBwYXJhbXMuc2V0KGAtJHtzdHJpbmcuZnJvbUNhbWVsQ2FzZShrZXksICctJyl9YCwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1zXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaGFzUGFyYW0gPSBuYW1lID0+IGNvbXB1dGVQYXJhbXMoKS5oYXMobmFtZSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRWYWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRQYXJhbSA9IChuYW1lLCBkZWZhdWx0VmFsKSA9PiBjb21wdXRlUGFyYW1zKCkuZ2V0KG5hbWUpIHx8IGRlZmF1bHRWYWxcbi8vIGV4cG9ydCBjb25zdCBnZXRBcmdzID0gbmFtZSA9PiBjb21wdXRlUGFyYW1zKCkgJiYgYXJnc1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRWYXJpYWJsZSA9IG5hbWUgPT4gaXNOb2RlID8gY29uZGl0aW9ucy51bmRlZmluZWRUb051bGwocHJvY2Vzcy5lbnZbbmFtZS50b1VwcGVyQ2FzZSgpXSkgOiBjb25kaXRpb25zLnVuZGVmaW5lZFRvTnVsbChzdG9yYWdlLnZhclN0b3JhZ2UuZ2V0SXRlbShuYW1lKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDb25mID0gbmFtZSA9PiBjb21wdXRlUGFyYW1zKCkuZ2V0KCctLScgKyBuYW1lKSB8fCBnZXRWYXJpYWJsZShuYW1lKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGhhc0NvbmYgPSBuYW1lID0+IGhhc1BhcmFtKCctLScgKyBuYW1lKSB8fCBnZXRWYXJpYWJsZShuYW1lKSAhPT0gbnVsbFxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y3Rpb24gPSBoYXNDb25mKCdwcm9kdWN0aW9uJylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/environment.js\n")},"../CoCreate-crdt/node_modules/lib0/error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "methodUnimplemented": () => (/* binding */ methodUnimplemented),\n/* harmony export */   "unexpectedCase": () => (/* binding */ unexpectedCase)\n/* harmony export */ });\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* istanbul ignore next */\nconst create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst methodUnimplemented = () => {\n  throw create(\'Method unimplemented\')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst unexpectedCase = () => {\n  throw create(\'Unexpected case\')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZXJyb3IuanM/YTY0ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9lcnJvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXJyb3IgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGVycm9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7RXJyb3J9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gcyA9PiBuZXcgRXJyb3IocylcblxuLyoqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqIEByZXR1cm4ge25ldmVyfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IG1ldGhvZFVuaW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gIHRocm93IGNyZWF0ZSgnTWV0aG9kIHVuaW1wbGVtZW50ZWQnKVxufVxuXG4vKipcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogQHJldHVybiB7bmV2ZXJ9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdW5leHBlY3RlZENhc2UgPSAoKSA9PiB7XG4gIHRocm93IGNyZWF0ZSgnVW5leHBlY3RlZCBjYXNlJylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/error.js\n')},"../CoCreate-crdt/node_modules/lib0/eventloop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "enqueue": () => (/* binding */ enqueue),\n/* harmony export */   "timeout": () => (/* binding */ timeout),\n/* harmony export */   "interval": () => (/* binding */ interval),\n/* harmony export */   "Animation": () => (/* binding */ Animation),\n/* harmony export */   "animationFrame": () => (/* binding */ animationFrame),\n/* harmony export */   "idleCallback": () => (/* binding */ idleCallback),\n/* harmony export */   "createDebouncer": () => (/* binding */ createDebouncer)\n/* harmony export */ });\n/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\n/**\n * Utility module to work with EcmaScript\'s event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = []\n\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n}\n\n/**\n * @param {function():void} f\n */\nconst enqueue = f => {\n  queue.push(f)\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0)\n  }\n}\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor (timeoutId) {\n    this._ = timeoutId\n  }\n\n  destroy () {\n    clearFunction(this._)\n  }\n}\n\nconst Timeout = createTimeoutClass(clearTimeout)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout))\n\nconst Interval = createTimeoutClass(clearInterval)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst interval = (timeout, callback) => new Interval(setInterval(callback, timeout))\n\n/* istanbul ignore next */\nconst Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== \'undefined\' && cancelAnimationFrame(arg))\n\n/* istanbul ignore next */\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\nconst animationFrame = cb => typeof requestAnimationFrame === \'undefined\' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb))\n\n/* istanbul ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== \'undefined\' && cancelIdleCallback(arg))\n\n/* istanbul ignore next */\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n// @ts-ignore\nconst idleCallback = cb => typeof requestIdleCallback !== \'undefined\' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb)\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @return {function(function():void):void}\n */\nconst createDebouncer = timeout => {\n  let timer = -1\n  return f => {\n    clearTimeout(timer)\n    if (f) {\n      timer = /** @type {any} */ (setTimeout(f, timeout))\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZXZlbnRsb29wLmpzP2VjZmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNPOztBQUVQOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZXZlbnRsb29wLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHJlcXVlc3RJZGxlQ2FsbGJhY2ssIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsSWRsZUNhbGxiYWNrLCBjYW5jZWxBbmltYXRpb25GcmFtZSAqL1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBFY21hU2NyaXB0J3MgZXZlbnQgbG9vcC5cbiAqXG4gKiBAbW9kdWxlIGV2ZW50bG9vcFxuICovXG5cbi8qKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn1cbiAqL1xubGV0IHF1ZXVlID0gW11cblxuY29uc3QgX3J1blF1ZXVlID0gKCkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKVxuICB9XG4gIHF1ZXVlID0gW11cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gZlxuICovXG5leHBvcnQgY29uc3QgZW5xdWV1ZSA9IGYgPT4ge1xuICBxdWV1ZS5wdXNoKGYpXG4gIGlmIChxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICBzZXRUaW1lb3V0KF9ydW5RdWV1ZSwgMClcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbWVvdXRPYmplY3RcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFRpbWVvdXRPYmplY3QuZGVzdHJveVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOnZvaWR9IGNsZWFyRnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlVGltZW91dENsYXNzID0gY2xlYXJGdW5jdGlvbiA9PiBjbGFzcyBUVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dElkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGltZW91dElkKSB7XG4gICAgdGhpcy5fID0gdGltZW91dElkXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBjbGVhckZ1bmN0aW9uKHRoaXMuXylcbiAgfVxufVxuXG5jb25zdCBUaW1lb3V0ID0gY3JlYXRlVGltZW91dENsYXNzKGNsZWFyVGltZW91dClcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCB0aW1lb3V0ID0gKHRpbWVvdXQsIGNhbGxiYWNrKSA9PiBuZXcgVGltZW91dChzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0KSlcblxuY29uc3QgSW50ZXJ2YWwgPSBjcmVhdGVUaW1lb3V0Q2xhc3MoY2xlYXJJbnRlcnZhbClcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcnZhbCA9ICh0aW1lb3V0LCBjYWxsYmFjaykgPT4gbmV3IEludGVydmFsKHNldEludGVydmFsKGNhbGxiYWNrLCB0aW1lb3V0KSlcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBBbmltYXRpb24gPSBjcmVhdGVUaW1lb3V0Q2xhc3MoYXJnID0+IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICd1bmRlZmluZWQnICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFyZykpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTp2b2lkfSBjYlxuICogQHJldHVybiB7VGltZW91dE9iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbkZyYW1lID0gY2IgPT4gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyB0aW1lb3V0KDAsIGNiKSA6IG5ldyBBbmltYXRpb24ocmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSlcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IElkbGUgPSBjcmVhdGVUaW1lb3V0Q2xhc3MoYXJnID0+IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGNhbmNlbElkbGVDYWxsYmFjayhhcmcpKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBOb3RlOiB0aGlzIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgcHJvYmFibHkgb25seSB1c2VmdWwgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2JcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBpZGxlQ2FsbGJhY2sgPSBjYiA9PiB0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgSWRsZShyZXF1ZXN0SWRsZUNhbGxiYWNrKGNiKSkgOiB0aW1lb3V0KDEwMDAsIGNiKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgb2YgdGhlIGRlYm91bmNlIGFjdGlvblxuICogQHJldHVybiB7ZnVuY3Rpb24oZnVuY3Rpb24oKTp2b2lkKTp2b2lkfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRGVib3VuY2VyID0gdGltZW91dCA9PiB7XG4gIGxldCB0aW1lciA9IC0xXG4gIHJldHVybiBmID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgaWYgKGYpIHtcbiAgICAgIHRpbWVyID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRUaW1lb3V0KGYsIHRpbWVvdXQpKVxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/eventloop.js\n')},"../CoCreate-crdt/node_modules/lib0/function.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "callAll": () => (/* binding */ callAll),\n/* harmony export */   "nop": () => (/* binding */ nop),\n/* harmony export */   "apply": () => (/* binding */ apply),\n/* harmony export */   "id": () => (/* binding */ id),\n/* harmony export */   "equalityStrict": () => (/* binding */ equalityStrict),\n/* harmony export */   "equalityFlat": () => (/* binding */ equalityFlat),\n/* harmony export */   "equalityDeep": () => (/* binding */ equalityDeep)\n/* harmony export */ });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "../CoCreate-crdt/node_modules/lib0/array.js");\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./object.js */ "../CoCreate-crdt/node_modules/lib0/object.js");\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n\n\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nconst callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nconst nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nconst apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nconst id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nconst equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((a instanceof Array && _array_js__WEBPACK_IMPORTED_MODULE_0__.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === \'object\' && _object_js__WEBPACK_IMPORTED_MODULE_1__.equalFlat(a, b))))\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (_object_js__WEBPACK_IMPORTED_MODULE_1__.length(a) !== _object_js__WEBPACK_IMPORTED_MODULE_1__.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!_object_js__WEBPACK_IMPORTED_MODULE_1__.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZnVuY3Rpb24uanM/MWY2ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtQztBQUNFOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFdBQVc7QUFDdEI7QUFDTztBQUNQO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVk7QUFDWjtBQUNPLGdJQUFnSSxnREFBZSxlQUFlLFNBQVMsdUNBQXVDLGlEQUFnQjs7QUFFck87QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLElBQUk7QUFDZixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhDQUFhLFFBQVEsOENBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvZnVuY3Rpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbW1vbiBmdW5jdGlvbnMgYW5kIGZ1bmN0aW9uIGNhbGwgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGZ1bmN0aW9uXG4gKi9cblxuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICcuL29iamVjdC5qcydcblxuLyoqXG4gKiBDYWxscyBhbGwgZnVuY3Rpb25zIGluIGBmc2Agd2l0aCBhcmdzLiBPbmx5IHRocm93cyBhZnRlciBhbGwgZnVuY3Rpb25zIHdlcmUgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24+fSBmc1xuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxsQWxsID0gKGZzLCBhcmdzLCBpID0gMCkgPT4ge1xuICB0cnkge1xuICAgIGZvciAoOyBpIDwgZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZzW2ldKC4uLmFyZ3MpXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpIDwgZnMubGVuZ3RoKSB7XG4gICAgICBjYWxsQWxsKGZzLCBhcmdzLCBpICsgMSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5vcCA9ICgpID0+IHt9XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpUfSBmXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3QgYXBwbHkgPSBmID0+IGYoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKlxuICogQHBhcmFtIHtBfSBhXG4gKiBAcmV0dXJuIHtBfVxuICovXG5leHBvcnQgY29uc3QgaWQgPSBhID0+IGFcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7VH0gYVxuICogQHBhcmFtIHtUfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlTdHJpY3QgPSAoYSwgYikgPT4gYSA9PT0gYlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxvYmplY3R9IGFcbiAqIEBwYXJhbSB7QXJyYXk8VD58b2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlGbGF0ID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKGEgIT0gbnVsbCAmJiBiICE9IG51bGwgJiYgYS5jb25zdHJ1Y3RvciA9PT0gYi5jb25zdHJ1Y3RvciAmJiAoKGEgaW5zdGFuY2VvZiBBcnJheSAmJiBhcnJheS5lcXVhbEZsYXQoYSwgLyoqIEB0eXBlIHtBcnJheTxUPn0gKi8gKGIpKSkgfHwgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBvYmplY3QuZXF1YWxGbGF0KGEsIGIpKSkpXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlEZWVwID0gKGEsIGIpID0+IHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gZXF1YWxpdHlTdHJpY3QoYSwgYilcbiAgfVxuICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBzd2l0Y2ggKGEuY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIEFycmF5QnVmZmVyOlxuICAgICAgYSA9IG5ldyBVaW50OEFycmF5KGEpXG4gICAgICBiID0gbmV3IFVpbnQ4QXJyYXkoYilcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICBjYXNlIFVpbnQ4QXJyYXk6IHtcbiAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIFNldDoge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhKSB7XG4gICAgICAgIGlmICghYi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgTWFwOiB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhLmtleXMoKSkge1xuICAgICAgICBpZiAoIWIuaGFzKGtleSkgfHwgIWVxdWFsaXR5RGVlcChhLmdldChrZXkpLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIE9iamVjdDpcbiAgICAgIGlmIChvYmplY3QubGVuZ3RoKGEpICE9PSBvYmplY3QubGVuZ3RoKGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoIW9iamVjdC5oYXNQcm9wZXJ0eShhLCBrZXkpIHx8ICFlcXVhbGl0eURlZXAoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBBcnJheTpcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFlcXVhbGl0eURlZXAoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/function.js\n')},"../CoCreate-crdt/node_modules/lib0/indexeddb.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rtop": () => (/* binding */ rtop),\n/* harmony export */   "openDB": () => (/* binding */ openDB),\n/* harmony export */   "deleteDB": () => (/* binding */ deleteDB),\n/* harmony export */   "createStores": () => (/* binding */ createStores),\n/* harmony export */   "transact": () => (/* binding */ transact),\n/* harmony export */   "count": () => (/* binding */ count),\n/* harmony export */   "get": () => (/* binding */ get),\n/* harmony export */   "del": () => (/* binding */ del),\n/* harmony export */   "put": () => (/* binding */ put),\n/* harmony export */   "add": () => (/* binding */ add),\n/* harmony export */   "addAutoKey": () => (/* binding */ addAutoKey),\n/* harmony export */   "getAll": () => (/* binding */ getAll),\n/* harmony export */   "getAllKeys": () => (/* binding */ getAllKeys),\n/* harmony export */   "queryFirst": () => (/* binding */ queryFirst),\n/* harmony export */   "getLastKey": () => (/* binding */ getLastKey),\n/* harmony export */   "getFirstKey": () => (/* binding */ getFirstKey),\n/* harmony export */   "getAllKeysValues": () => (/* binding */ getAllKeysValues),\n/* harmony export */   "iterate": () => (/* binding */ iterate),\n/* harmony export */   "iterateKeys": () => (/* binding */ iterateKeys),\n/* harmony export */   "getStore": () => (/* binding */ getStore),\n/* harmony export */   "createIDBKeyRangeBound": () => (/* binding */ createIDBKeyRangeBound),\n/* harmony export */   "createIDBKeyRangeUpperBound": () => (/* binding */ createIDBKeyRangeUpperBound),\n/* harmony export */   "createIDBKeyRangeLowerBound": () => (/* binding */ createIDBKeyRangeLowerBound)\n/* harmony export */ });\n/* harmony import */ var _promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./promise.js */ "../CoCreate-crdt/node_modules/lib0/promise.js");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error.js */ "../CoCreate-crdt/node_modules/lib0/error.js");\n/* eslint-env browser */\n\n/**\n * Helpers to work with IndexedDB.\n *\n * @module idb\n */\n\n\n\n\n/**\n * IDB Request to Promise transformer\n *\n * @param {IDBRequest} request\n * @return {Promise<any>}\n */\n/* istanbul ignore next */\nconst rtop = request => _promise_js__WEBPACK_IMPORTED_MODULE_0__.create((resolve, reject) => {\n  /* istanbul ignore next */\n  // @ts-ignore\n  request.onerror = event => reject(new Error(event.target.error))\n  /* istanbul ignore next */\n  // @ts-ignore\n  request.onblocked = () => location.reload()\n  // @ts-ignore\n  request.onsuccess = event => resolve(event.target.result)\n})\n\n/**\n * @param {string} name\n * @param {function(IDBDatabase):any} initDB Called when the database is first created\n * @return {Promise<IDBDatabase>}\n */\n/* istanbul ignore next */\nconst openDB = (name, initDB) => _promise_js__WEBPACK_IMPORTED_MODULE_0__.create((resolve, reject) => {\n  const request = indexedDB.open(name)\n  /**\n   * @param {any} event\n   */\n  request.onupgradeneeded = event => initDB(event.target.result)\n  /* istanbul ignore next */\n  /**\n   * @param {any} event\n   */\n  request.onerror = event => reject(_error_js__WEBPACK_IMPORTED_MODULE_1__.create(event.target.error))\n  /* istanbul ignore next */\n  request.onblocked = () => location.reload()\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    /**\n     * @type {IDBDatabase}\n     */\n    const db = event.target.result\n    /* istanbul ignore next */\n    db.onversionchange = () => { db.close() }\n    /* istanbul ignore if */\n    if (typeof addEventListener !== \'undefined\') {\n      addEventListener(\'unload\', () => db.close())\n    }\n    resolve(db)\n  }\n})\n\n/**\n * @param {string} name\n */\n/* istanbul ignore next */\nconst deleteDB = name => rtop(indexedDB.deleteDatabase(name))\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<Array<string>|Array<string|IDBObjectStoreParameters|undefined>>} definitions\n */\n/* istanbul ignore next */\nconst createStores = (db, definitions) => definitions.forEach(d =>\n  // @ts-ignore\n  db.createObjectStore.apply(db, d)\n)\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<string>} stores\n * @param {"readwrite"|"readonly"} [access]\n * @return {Array<IDBObjectStore>}\n */\nconst transact = (db, stores, access = \'readwrite\') => {\n  const transaction = db.transaction(stores, access)\n  return stores.map(store => getStore(transaction, store))\n}\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<number>}\n */\n/* istanbul ignore next */\nconst count = (store, range) =>\n  rtop(store.count(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | Array<any> } key\n * @return {Promise<String | number | ArrayBuffer | Date | Array<any>>}\n */\n/* istanbul ignore next */\nconst get = (store, key) =>\n  rtop(store.get(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | IDBKeyRange | Array<any> } key\n */\n/* istanbul ignore next */\nconst del = (store, key) =>\n  rtop(store.delete(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean} item\n * @param {String | number | ArrayBuffer | Date | Array<any>} [key]\n */\n/* istanbul ignore next */\nconst put = (store, item, key) =>\n  rtop(store.put(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean}  item\n * @param {String | number | ArrayBuffer | Date | Array<any>}  key\n * @return {Promise<any>}\n */\n/* istanbul ignore next */\nconst add = (store, item, key) =>\n  rtop(store.add(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date}  item\n * @return {Promise<number>} Returns the generated key\n */\n/* istanbul ignore next */\nconst addAutoKey = (store, item) =>\n  rtop(store.add(item))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n/* istanbul ignore next */\nconst getAll = (store, range) =>\n  rtop(store.getAll(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n/* istanbul ignore next */\nconst getAllKeys = (store, range) =>\n  rtop(store.getAllKeys(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} query\n * @param {\'next\'|\'prev\'|\'nextunique\'|\'prevunique\'} direction\n * @return {Promise<any>}\n */\nconst queryFirst = (store, query, direction) => {\n  /**\n   * @type {any}\n   */\n  let first = null\n  return iterateKeys(store, query, key => {\n    first = key\n    return false\n  }, direction).then(() => first)\n}\n\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\nconst getLastKey = store => queryFirst(store, null, \'prev\')\n\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\nconst getFirstKey = store => queryFirst(store, null, \'prev\')\n\n/**\n * @typedef KeyValuePair\n * @type {Object}\n * @property {any} k key\n * @property {any} v Value\n */\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<KeyValuePair>>}\n */\n/* istanbul ignore next */\nconst getAllKeysValues = (store, range) =>\n  // @ts-ignore\n  _promise_js__WEBPACK_IMPORTED_MODULE_0__.all([getAllKeys(store, range), getAll(store, range)]).then(([ks, vs]) => ks.map((k, i) => ({ k, v: vs[i] })))\n\n/**\n * @param {any} request\n * @param {function(IDBCursorWithValue):void|boolean} f\n * @return {Promise<void>}\n */\n/* istanbul ignore next */\nconst iterateOnRequest = (request, f) => _promise_js__WEBPACK_IMPORTED_MODULE_0__.create((resolve, reject) => {\n  /* istanbul ignore next */\n  request.onerror = reject\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    const cursor = event.target.result\n    if (cursor === null || f(cursor) === false) {\n      return resolve()\n    }\n    cursor.continue()\n  }\n})\n\n/**\n * Iterate on keys and values\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any,any):void|boolean} f Callback that receives (value, key)\n * @param {\'next\'|\'prev\'|\'nextunique\'|\'prevunique\'} direction\n */\n/* istanbul ignore next */\nconst iterate = (store, keyrange, f, direction = \'next\') =>\n  iterateOnRequest(store.openCursor(keyrange, direction), cursor => f(cursor.value, cursor.key))\n\n/**\n * Iterate on the keys (no values)\n *\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any):void|boolean} f callback that receives the key\n * @param {\'next\'|\'prev\'|\'nextunique\'|\'prevunique\'} direction\n */\n/* istanbul ignore next */\nconst iterateKeys = (store, keyrange, f, direction = \'next\') =>\n  iterateOnRequest(store.openKeyCursor(keyrange, direction), cursor => f(cursor.key))\n\n/**\n * Open store from transaction\n * @param {IDBTransaction} t\n * @param {String} store\n * @returns {IDBObjectStore}\n */\n/* istanbul ignore next */\nconst getStore = (t, store) => t.objectStore(store)\n\n/**\n * @param {any} lower\n * @param {any} upper\n * @param {boolean} lowerOpen\n * @param {boolean} upperOpen\n */\n/* istanbul ignore next */\nconst createIDBKeyRangeBound = (lower, upper, lowerOpen, upperOpen) => IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\n\n/**\n * @param {any} upper\n * @param {boolean} upperOpen\n */\n/* istanbul ignore next */\nconst createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen)\n\n/**\n * @param {any} lower\n * @param {boolean} lowerOpen\n */\n/* istanbul ignore next */\nconst createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvaW5kZXhlZGRiLmpzPzMyNzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ0o7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNPLHdCQUF3QiwrQ0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLDBCQUEwQjtBQUNyQyxZQUFZO0FBQ1o7QUFDQTtBQUNPLGlDQUFpQywrQ0FBYztBQUN0RDtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0Esb0NBQW9DLDZDQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsc0VBQXNFO0FBQ2pGO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLGNBQWM7QUFDekIsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxZQUFZO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLG1EQUFtRDtBQUM5RCxZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpRUFBaUU7QUFDNUU7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVywrQ0FBK0M7QUFDMUQsV0FBVyxrREFBa0Q7QUFDN0Q7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVywrQ0FBK0M7QUFDMUQsV0FBVyxrREFBa0Q7QUFDN0QsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcscUNBQXFDO0FBQ2hELFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxZQUFZO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLHdDQUF3QztBQUNuRCxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFVBQVU7QUFDVixjQUFjLElBQUk7QUFDbEIsY0FBYyxJQUFJO0FBQ2xCOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7QUFDQSxFQUFFLDRDQUFXLHlGQUF5RixjQUFjOztBQUVwSDtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsMENBQTBDO0FBQ3JELFlBQVk7QUFDWjtBQUNBO0FBQ0EseUNBQXlDLCtDQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsd0NBQXdDO0FBQ25EO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLHdDQUF3QztBQUNuRDtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxJQUFJO0FBQ2YsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDTyIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9saWIwL2luZGV4ZWRkYi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIEhlbHBlcnMgdG8gd29yayB3aXRoIEluZGV4ZWREQi5cbiAqXG4gKiBAbW9kdWxlIGlkYlxuICovXG5cbmltcG9ydCAqIGFzIHByb21pc2UgZnJvbSAnLi9wcm9taXNlLmpzJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnLi9lcnJvci5qcydcblxuLyoqXG4gKiBJREIgUmVxdWVzdCB0byBQcm9taXNlIHRyYW5zZm9ybWVyXG4gKlxuICogQHBhcmFtIHtJREJSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcnRvcCA9IHJlcXVlc3QgPT4gcHJvbWlzZS5jcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAvLyBAdHMtaWdub3JlXG4gIHJlcXVlc3Qub25lcnJvciA9IGV2ZW50ID0+IHJlamVjdChuZXcgRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKSlcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICByZXF1ZXN0Lm9uYmxvY2tlZCA9ICgpID0+IGxvY2F0aW9uLnJlbG9hZCgpXG4gIC8vIEB0cy1pZ25vcmVcbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBldmVudCA9PiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKElEQkRhdGFiYXNlKTphbnl9IGluaXREQiBDYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgaXMgZmlyc3QgY3JlYXRlZFxuICogQHJldHVybiB7UHJvbWlzZTxJREJEYXRhYmFzZT59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgb3BlbkRCID0gKG5hbWUsIGluaXREQikgPT4gcHJvbWlzZS5jcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4obmFtZSlcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBldmVudFxuICAgKi9cbiAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBldmVudCA9PiBpbml0REIoZXZlbnQudGFyZ2V0LnJlc3VsdClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBldmVudFxuICAgKi9cbiAgcmVxdWVzdC5vbmVycm9yID0gZXZlbnQgPT4gcmVqZWN0KGVycm9yLmNyZWF0ZShldmVudC50YXJnZXQuZXJyb3IpKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXF1ZXN0Lm9uYmxvY2tlZCA9ICgpID0+IGxvY2F0aW9uLnJlbG9hZCgpXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZXZlbnRcbiAgICovXG4gIHJlcXVlc3Qub25zdWNjZXNzID0gZXZlbnQgPT4ge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJREJEYXRhYmFzZX1cbiAgICAgKi9cbiAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGRiLm9udmVyc2lvbmNoYW5nZSA9ICgpID0+IHsgZGIuY2xvc2UoKSB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgKCkgPT4gZGIuY2xvc2UoKSlcbiAgICB9XG4gICAgcmVzb2x2ZShkYilcbiAgfVxufSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZURCID0gbmFtZSA9PiBydG9wKGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQkRhdGFiYXNlfSBkYlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxzdHJpbmc+fEFycmF5PHN0cmluZ3xJREJPYmplY3RTdG9yZVBhcmFtZXRlcnN8dW5kZWZpbmVkPj59IGRlZmluaXRpb25zXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlU3RvcmVzID0gKGRiLCBkZWZpbml0aW9ucykgPT4gZGVmaW5pdGlvbnMuZm9yRWFjaChkID0+XG4gIC8vIEB0cy1pZ25vcmVcbiAgZGIuY3JlYXRlT2JqZWN0U3RvcmUuYXBwbHkoZGIsIGQpXG4pXG5cbi8qKlxuICogQHBhcmFtIHtJREJEYXRhYmFzZX0gZGJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc3RvcmVzXG4gKiBAcGFyYW0ge1wicmVhZHdyaXRlXCJ8XCJyZWFkb25seVwifSBbYWNjZXNzXVxuICogQHJldHVybiB7QXJyYXk8SURCT2JqZWN0U3RvcmU+fVxuICovXG5leHBvcnQgY29uc3QgdHJhbnNhY3QgPSAoZGIsIHN0b3JlcywgYWNjZXNzID0gJ3JlYWR3cml0ZScpID0+IHtcbiAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihzdG9yZXMsIGFjY2VzcylcbiAgcmV0dXJuIHN0b3Jlcy5tYXAoc3RvcmUgPT4gZ2V0U3RvcmUodHJhbnNhY3Rpb24sIHN0b3JlKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNvdW50ID0gKHN0b3JlLCByYW5nZSkgPT5cbiAgcnRvcChzdG9yZS5jb3VudChyYW5nZSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgQXJyYXk8YW55PiB9IGtleVxuICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBBcnJheTxhbnk+Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXQgPSAoc3RvcmUsIGtleSkgPT5cbiAgcnRvcChzdG9yZS5nZXQoa2V5KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBJREJLZXlSYW5nZSB8IEFycmF5PGFueT4gfSBrZXlcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBkZWwgPSAoc3RvcmUsIGtleSkgPT5cbiAgcnRvcChzdG9yZS5kZWxldGUoa2V5KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBib29sZWFufSBpdGVtXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IEFycmF5PGFueT59IFtrZXldXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcHV0ID0gKHN0b3JlLCBpdGVtLCBrZXkpID0+XG4gIHJ0b3Aoc3RvcmUucHV0KGl0ZW0sIGtleSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgYm9vbGVhbn0gIGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgQXJyYXk8YW55Pn0gIGtleVxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IChzdG9yZSwgaXRlbSwga2V5KSA9PlxuICBydG9wKHN0b3JlLmFkZChpdGVtLCBrZXkpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0gIGl0ZW1cbiAqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn0gUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGtleVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFkZEF1dG9LZXkgPSAoc3RvcmUsIGl0ZW0pID0+XG4gIHJ0b3Aoc3RvcmUuYWRkKGl0ZW0pKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfSBbcmFuZ2VdXG4gKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PGFueT4+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGdldEFsbCA9IChzdG9yZSwgcmFuZ2UpID0+XG4gIHJ0b3Aoc3RvcmUuZ2V0QWxsKHJhbmdlKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxhbnk+Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRBbGxLZXlzID0gKHN0b3JlLCByYW5nZSkgPT5cbiAgcnRvcChzdG9yZS5nZXRBbGxLZXlzKHJhbmdlKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZXxudWxsfSBxdWVyeVxuICogQHBhcmFtIHsnbmV4dCd8J3ByZXYnfCduZXh0dW5pcXVlJ3wncHJldnVuaXF1ZSd9IGRpcmVjdGlvblxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG5leHBvcnQgY29uc3QgcXVlcnlGaXJzdCA9IChzdG9yZSwgcXVlcnksIGRpcmVjdGlvbikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIGxldCBmaXJzdCA9IG51bGxcbiAgcmV0dXJuIGl0ZXJhdGVLZXlzKHN0b3JlLCBxdWVyeSwga2V5ID0+IHtcbiAgICBmaXJzdCA9IGtleVxuICAgIHJldHVybiBmYWxzZVxuICB9LCBkaXJlY3Rpb24pLnRoZW4oKCkgPT4gZmlyc3QpXG59XG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldExhc3RLZXkgPSBzdG9yZSA9PiBxdWVyeUZpcnN0KHN0b3JlLCBudWxsLCAncHJldicpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZpcnN0S2V5ID0gc3RvcmUgPT4gcXVlcnlGaXJzdChzdG9yZSwgbnVsbCwgJ3ByZXYnKVxuXG4vKipcbiAqIEB0eXBlZGVmIEtleVZhbHVlUGFpclxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7YW55fSBrIGtleVxuICogQHByb3BlcnR5IHthbnl9IHYgVmFsdWVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfSBbcmFuZ2VdXG4gKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PEtleVZhbHVlUGFpcj4+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGdldEFsbEtleXNWYWx1ZXMgPSAoc3RvcmUsIHJhbmdlKSA9PlxuICAvLyBAdHMtaWdub3JlXG4gIHByb21pc2UuYWxsKFtnZXRBbGxLZXlzKHN0b3JlLCByYW5nZSksIGdldEFsbChzdG9yZSwgcmFuZ2UpXSkudGhlbigoW2tzLCB2c10pID0+IGtzLm1hcCgoaywgaSkgPT4gKHsgaywgdjogdnNbaV0gfSkpKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKElEQkN1cnNvcldpdGhWYWx1ZSk6dm9pZHxib29sZWFufSBmXG4gKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgaXRlcmF0ZU9uUmVxdWVzdCA9IChyZXF1ZXN0LCBmKSA9PiBwcm9taXNlLmNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdFxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGV2ZW50XG4gICAqL1xuICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgaWYgKGN1cnNvciA9PT0gbnVsbCB8fCBmKGN1cnNvcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpXG4gICAgfVxuICAgIGN1cnNvci5jb250aW51ZSgpXG4gIH1cbn0pXG5cbi8qKlxuICogSXRlcmF0ZSBvbiBrZXlzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfG51bGx9IGtleXJhbmdlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxhbnkpOnZvaWR8Ym9vbGVhbn0gZiBDYWxsYmFjayB0aGF0IHJlY2VpdmVzICh2YWx1ZSwga2V5KVxuICogQHBhcmFtIHsnbmV4dCd8J3ByZXYnfCduZXh0dW5pcXVlJ3wncHJldnVuaXF1ZSd9IGRpcmVjdGlvblxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGUgPSAoc3RvcmUsIGtleXJhbmdlLCBmLCBkaXJlY3Rpb24gPSAnbmV4dCcpID0+XG4gIGl0ZXJhdGVPblJlcXVlc3Qoc3RvcmUub3BlbkN1cnNvcihrZXlyYW5nZSwgZGlyZWN0aW9uKSwgY3Vyc29yID0+IGYoY3Vyc29yLnZhbHVlLCBjdXJzb3Iua2V5KSlcblxuLyoqXG4gKiBJdGVyYXRlIG9uIHRoZSBrZXlzIChubyB2YWx1ZXMpXG4gKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V8bnVsbH0ga2V5cmFuZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTp2b2lkfGJvb2xlYW59IGYgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUga2V5XG4gKiBAcGFyYW0geyduZXh0J3wncHJldid8J25leHR1bmlxdWUnfCdwcmV2dW5pcXVlJ30gZGlyZWN0aW9uXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXRlcmF0ZUtleXMgPSAoc3RvcmUsIGtleXJhbmdlLCBmLCBkaXJlY3Rpb24gPSAnbmV4dCcpID0+XG4gIGl0ZXJhdGVPblJlcXVlc3Qoc3RvcmUub3BlbktleUN1cnNvcihrZXlyYW5nZSwgZGlyZWN0aW9uKSwgY3Vyc29yID0+IGYoY3Vyc29yLmtleSkpXG5cbi8qKlxuICogT3BlbiBzdG9yZSBmcm9tIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0lEQlRyYW5zYWN0aW9ufSB0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RvcmVcbiAqIEByZXR1cm5zIHtJREJPYmplY3RTdG9yZX1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRTdG9yZSA9ICh0LCBzdG9yZSkgPT4gdC5vYmplY3RTdG9yZShzdG9yZSlcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbG93ZXJcbiAqIEBwYXJhbSB7YW55fSB1cHBlclxuICogQHBhcmFtIHtib29sZWFufSBsb3dlck9wZW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBwZXJPcGVuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlSURCS2V5UmFuZ2VCb3VuZCA9IChsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKSA9PiBJREJLZXlSYW5nZS5ib3VuZChsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB1cHBlclxuICogQHBhcmFtIHtib29sZWFufSB1cHBlck9wZW5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJREJLZXlSYW5nZVVwcGVyQm91bmQgPSAodXBwZXIsIHVwcGVyT3BlbikgPT4gSURCS2V5UmFuZ2UudXBwZXJCb3VuZCh1cHBlciwgdXBwZXJPcGVuKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBsb3dlclxuICogQHBhcmFtIHtib29sZWFufSBsb3dlck9wZW5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJREJLZXlSYW5nZUxvd2VyQm91bmQgPSAobG93ZXIsIGxvd2VyT3BlbikgPT4gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgbG93ZXJPcGVuKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/indexeddb.js\n')},"../CoCreate-crdt/node_modules/lib0/isomorphic.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "performance": () => (/* binding */ performance),\n/* harmony export */   "cryptoRandomBuffer": () => (/* binding */ cryptoRandomBuffer)\n/* harmony export */ });\n/* harmony import */ var isomorphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! isomorphic.js */ "../CoCreate-crdt/node_modules/isomorphic.js/iso-browser.js");\n/**\n * Isomorphic library exports from isomorphic.js.\n *\n * @module isomorphic\n */\n\n// @ts-ignore\n\n\nconst performance = /** @type {any} */ (isomorphic_js__WEBPACK_IMPORTED_MODULE_0__.performance)\nconst cryptoRandomBuffer = /** @type {any} */ (isomorphic_js__WEBPACK_IMPORTED_MODULE_0__.cryptoRandomBuffer)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvaXNvbW9ycGhpYy5qcz9hOWM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0I7O0FBRXhCLCtCQUErQixJQUFJLEtBQUssc0RBQWU7QUFDdkQsc0NBQXNDLElBQUksS0FBSyw2REFBc0IiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9pc29tb3JwaGljLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJc29tb3JwaGljIGxpYnJhcnkgZXhwb3J0cyBmcm9tIGlzb21vcnBoaWMuanMuXG4gKlxuICogQG1vZHVsZSBpc29tb3JwaGljXG4gKi9cblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IGlzbyBmcm9tICdpc29tb3JwaGljLmpzJ1xuXG5leHBvcnQgY29uc3QgcGVyZm9ybWFuY2UgPSAvKiogQHR5cGUge2FueX0gKi8gKGlzby5wZXJmb3JtYW5jZSlcbmV4cG9ydCBjb25zdCBjcnlwdG9SYW5kb21CdWZmZXIgPSAvKiogQHR5cGUge2FueX0gKi8gKGlzby5jcnlwdG9SYW5kb21CdWZmZXIpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/isomorphic.js\n')},"../CoCreate-crdt/node_modules/lib0/iterator.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "mapIterator": () => (/* binding */ mapIterator),\n/* harmony export */   "createIterator": () => (/* binding */ createIterator),\n/* harmony export */   "iteratorFilter": () => (/* binding */ iteratorFilter),\n/* harmony export */   "iteratorMap": () => (/* binding */ iteratorMap)\n/* harmony export */ });\n/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nconst mapIterator = (iterator, f) => ({\n  /**\n   * @param {function(T):R} f\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next()\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n})\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nconst createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n})\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nconst iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res\n  do {\n    res = iterator.next()\n  } while (!res.done && !filter(res.value))\n  return res\n})\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nconst iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next()\n  return { done, value: done ? undefined : fmap(value) }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvaXRlcmF0b3IuanM/OTczNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QyxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxjQUFjO0FBQ3pCO0FBQ087QUFDUCxTQUFTLGNBQWM7QUFDdkIsVUFBVTtBQUNWLENBQUMiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9pdGVyYXRvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gY3JlYXRlIGFuZCBtYW5pcHVsYXRlIEl0ZXJhdG9ycy5cbiAqXG4gKiBAbW9kdWxlIGl0ZXJhdG9yXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCxSXG4gKiBAcGFyYW0ge0l0ZXJhdG9yPFQ+fSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbihUKTpSfSBmXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFI+fVxuICovXG5leHBvcnQgY29uc3QgbWFwSXRlcmF0b3IgPSAoaXRlcmF0b3IsIGYpID0+ICh7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOlJ9IGZcbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICAvLyBAdHMtaWdub3JlXG4gIG5leHQgKCkge1xuICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KClcbiAgICByZXR1cm4geyB2YWx1ZTogci5kb25lID8gdW5kZWZpbmVkIDogZihyLnZhbHVlKSwgZG9uZTogci5kb25lIH1cbiAgfVxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbigpOkl0ZXJhdG9yUmVzdWx0PFQ+fSBuZXh0XG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlSXRlcmF0b3IgPSBuZXh0ID0+ICh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8vIEB0cy1pZ25vcmVcbiAgbmV4dFxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtJdGVyYXRvcjxUPn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Ym9vbGVhbn0gZmlsdGVyXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRvckZpbHRlciA9IChpdGVyYXRvciwgZmlsdGVyKSA9PiBjcmVhdGVJdGVyYXRvcigoKSA9PiB7XG4gIGxldCByZXNcbiAgZG8ge1xuICAgIHJlcyA9IGl0ZXJhdG9yLm5leHQoKVxuICB9IHdoaWxlICghcmVzLmRvbmUgJiYgIWZpbHRlcihyZXMudmFsdWUpKVxuICByZXR1cm4gcmVzXG59KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULE1cbiAqIEBwYXJhbSB7SXRlcmF0b3I8VD59IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOk19IGZtYXBcbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yTWFwID0gKGl0ZXJhdG9yLCBmbWFwKSA9PiBjcmVhdGVJdGVyYXRvcigoKSA9PiB7XG4gIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGl0ZXJhdG9yLm5leHQoKVxuICByZXR1cm4geyBkb25lLCB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IGZtYXAodmFsdWUpIH1cbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/iterator.js\n')},"../CoCreate-crdt/node_modules/lib0/json.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "stringify": () => (/* binding */ stringify),\n/* harmony export */   "parse": () => (/* binding */ parse)\n/* harmony export */ });\n/**\n * JSON utility functions.\n *\n * @module json\n */\n\n/**\n * Transform JavaScript object to JSON.\n *\n * @param {any} object\n * @return {string}\n */\nconst stringify = JSON.stringify\n\n/**\n * Parse JSON object.\n *\n * @param {string} json\n * @return {any}\n */\nconst parse = JSON.parse\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvanNvbi5qcz8zNzJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ08iLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9qc29uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKU09OIHV0aWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBtb2R1bGUganNvblxuICovXG5cbi8qKlxuICogVHJhbnNmb3JtIEphdmFTY3JpcHQgb2JqZWN0IHRvIEpTT04uXG4gKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3Qgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnlcblxuLyoqXG4gKiBQYXJzZSBKU09OIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ganNvblxuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgcGFyc2UgPSBKU09OLnBhcnNlXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/json.js\n')},"../CoCreate-crdt/node_modules/lib0/logging.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BOLD\": () => (/* binding */ BOLD),\n/* harmony export */   \"UNBOLD\": () => (/* binding */ UNBOLD),\n/* harmony export */   \"BLUE\": () => (/* binding */ BLUE),\n/* harmony export */   \"GREY\": () => (/* binding */ GREY),\n/* harmony export */   \"GREEN\": () => (/* binding */ GREEN),\n/* harmony export */   \"RED\": () => (/* binding */ RED),\n/* harmony export */   \"PURPLE\": () => (/* binding */ PURPLE),\n/* harmony export */   \"ORANGE\": () => (/* binding */ ORANGE),\n/* harmony export */   \"UNCOLOR\": () => (/* binding */ UNCOLOR),\n/* harmony export */   \"print\": () => (/* binding */ print),\n/* harmony export */   \"warn\": () => (/* binding */ warn),\n/* harmony export */   \"printError\": () => (/* binding */ printError),\n/* harmony export */   \"printImg\": () => (/* binding */ printImg),\n/* harmony export */   \"printImgBase64\": () => (/* binding */ printImgBase64),\n/* harmony export */   \"group\": () => (/* binding */ group),\n/* harmony export */   \"groupCollapsed\": () => (/* binding */ groupCollapsed),\n/* harmony export */   \"groupEnd\": () => (/* binding */ groupEnd),\n/* harmony export */   \"printDom\": () => (/* binding */ printDom),\n/* harmony export */   \"printCanvas\": () => (/* binding */ printCanvas),\n/* harmony export */   \"vconsoles\": () => (/* binding */ vconsoles),\n/* harmony export */   \"VConsole\": () => (/* binding */ VConsole),\n/* harmony export */   \"createVConsole\": () => (/* binding */ createVConsole),\n/* harmony export */   \"createModuleLogger\": () => (/* binding */ createModuleLogger)\n/* harmony export */ });\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./environment.js */ \"../CoCreate-crdt/node_modules/lib0/environment.js\");\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol.js */ \"../CoCreate-crdt/node_modules/lib0/symbol.js\");\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pair.js */ \"../CoCreate-crdt/node_modules/lib0/pair.js\");\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ \"../CoCreate-crdt/node_modules/lib0/dom.js\");\n/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./json.js */ \"../CoCreate-crdt/node_modules/lib0/json.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ \"../CoCreate-crdt/node_modules/lib0/map.js\");\n/* harmony import */ var _eventloop_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./eventloop.js */ \"../CoCreate-crdt/node_modules/lib0/eventloop.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./math.js */ \"../CoCreate-crdt/node_modules/lib0/math.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./time.js */ \"../CoCreate-crdt/node_modules/lib0/time.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./function.js */ \"../CoCreate-crdt/node_modules/lib0/function.js\");\n/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst BOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNBOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst BLUE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREY = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREEN = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst RED = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst PURPLE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst ORANGE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNCOLOR = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [BOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'bold'),\n  [UNBOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'normal'),\n  [BLUE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'blue'),\n  [GREEN]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'green'),\n  [GREY]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'grey'),\n  [RED]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'red'),\n  [PURPLE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'purple'),\n  [ORANGE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [UNCOLOR]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'black')\n}\n\nconst _nodeStyleMap = {\n  [BOLD]: '\\u001b[1m',\n  [UNBOLD]: '\\u001b[2m',\n  [BLUE]: '\\x1b[34m',\n  [GREEN]: '\\x1b[32m',\n  [GREY]: '\\u001b[37m',\n  [RED]: '\\x1b[31m',\n  [PURPLE]: '\\x1b[35m',\n  [ORANGE]: '\\x1b[38;5;208m',\n  [UNCOLOR]: '\\x1b[0m'\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeBrowserLoggingArgs = args => {\n  const strBuilder = []\n  const styles = []\n  const currentStyle = _map_js__WEBPACK_IMPORTED_MODULE_2__.create()\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle)\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg)\n          styles.push(style)\n        } else {\n          strBuilder.push(arg)\n        }\n      } else {\n        break\n      }\n    }\n  }\n\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles\n    logArgs.unshift(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeNodeLoggingArgs = args => {\n  const strBuilder = []\n  const logArgs = []\n\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _nodeStyleMap[arg]\n    if (style !== undefined) {\n      strBuilder.push(style)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        strBuilder.push(arg)\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    strBuilder.push('\\x1b[0m')\n    logArgs.push(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    /* istanbul ignore else */\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/* istanbul ignore next */\nconst computeLoggingArgs = _environment_js__WEBPACK_IMPORTED_MODULE_4__.isNode ? computeNodeLoggingArgs : computeBrowserLoggingArgs\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst print = (...args) => {\n  console.log(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst warn = (...args) => {\n  console.warn(...computeLoggingArgs(args))\n  args.unshift(ORANGE)\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Error} err\n */\nconst printError = err => {\n  console.error(err)\n  vconsoles.forEach(vc => vc.printError(err))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\nconst printImg = (url, height) => {\n  if (_environment_js__WEBPACK_IMPORTED_MODULE_4__.isBrowser) {\n    console.log('%c                      ', `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`)\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach(vc => vc.printImg(url, height))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} base64\n * @param {number} height\n */\nconst printImgBase64 = (base64, height) => printImg(`data:image/gif;base64,${base64}`, height)\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst group = (...args) => {\n  console.group(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.group(args))\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupCollapsed(args))\n}\n\nconst groupEnd = () => {\n  console.groupEnd()\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupEnd())\n}\n\n/* istanbul ignore next */\n/**\n * @param {function():Node} createNode\n */\nconst printDom = createNode =>\n  vconsoles.forEach(vc => vc.printDom(createNode()))\n\n/* istanbul ignore next */\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\nconst printCanvas = (canvas, height) => printImg(canvas.toDataURL(), height)\n\nconst vconsoles = new Set()\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\nconst _computeLineSpans = args => {\n  const spans = []\n  const currentStyle = new Map()\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle))], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(arg)])\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;'\n        }\n        spans.push(span)\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i]\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + _json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(content) + ' '\n      }\n      spans.push(_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(/** @type {string} */ (content))]))\n    }\n  }\n  return spans\n}\n\nconst lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;'\n\n/* istanbul ignore next */\nclass VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom\n    this.depth = 0\n    vconsoles.add(this)\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      const triangleDown = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:120%;')], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('▼')])\n      const triangleRight = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', !collapsed), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:125%;')], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('▶')])\n      const content = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], [triangleDown, triangleRight, _dom_js__WEBPACK_IMPORTED_MODULE_3__.text(' ')].concat(_computeLineSpans(args)))\n      const nextContainer = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed)])\n      const nextLine = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [], [content, nextContainer])\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [nextLine])\n      this.ccontainer = nextContainer\n      this.depth++\n      // when header is clicked, collapse/uncollapse container\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.addEventListener(content, 'click', event => {\n        nextContainer.toggleAttribute('hidden')\n        triangleDown.toggleAttribute('hidden')\n        triangleRight.toggleAttribute('hidden')\n      })\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true)\n  }\n\n  groupEnd () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement\n      }\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], _computeLineSpans(args))])\n    })\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([RED, BOLD, err.toString()])\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('img', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('src', url), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('height', `${_math_js__WEBPACK_IMPORTED_MODULE_7__.round(height * 1.5)}px`)])])\n    })\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [node])\n    })\n  }\n\n  destroy () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      vconsoles.delete(this)\n    })\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @param {Element} dom\n */\nconst createVConsole = dom => new VConsole(dom)\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE]\nlet nextColor = 0\nlet lastLoggingTime = _time_js__WEBPACK_IMPORTED_MODULE_8__.getUnixTime()\n\n/**\n * @param {string} moduleName\n * @return {function(...any)}\n */\nconst createModuleLogger = moduleName => {\n  const color = loggingColors[nextColor]\n  const debugRegexVar = _environment_js__WEBPACK_IMPORTED_MODULE_4__.getVariable('log')\n  const doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName))\n  nextColor = (nextColor + 1) % loggingColors.length\n  moduleName += ': '\n\n  return !doLogging ? _function_js__WEBPACK_IMPORTED_MODULE_9__.nop : (...args) => {\n    const timeNow = _time_js__WEBPACK_IMPORTED_MODULE_8__.getUnixTime()\n    const timeDiff = timeNow - lastLoggingTime\n    lastLoggingTime = timeNow\n    print(color, moduleName, UNCOLOR, ...args.map(arg => (typeof arg === 'string' || typeof arg === 'symbol') ? arg : JSON.stringify(arg)), color, ' +' + timeDiff + 'ms')\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvbG9nZ2luZy5qcz81NjUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ0Y7QUFDSjtBQUNGO0FBQ0U7QUFDRjtBQUNZO0FBQ1Y7QUFDQTtBQUNJOztBQUU5QixhQUFhLDhDQUFhO0FBQzFCLGVBQWUsOENBQWE7QUFDNUIsYUFBYSw4Q0FBYTtBQUMxQixhQUFhLDhDQUFhO0FBQzFCLGNBQWMsOENBQWE7QUFDM0IsWUFBWSw4Q0FBYTtBQUN6QixlQUFlLDhDQUFhO0FBQzVCLGVBQWUsOENBQWE7QUFDNUIsZ0JBQWdCLDhDQUFhOztBQUVwQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSw0Q0FBVztBQUNyQixZQUFZLDRDQUFXO0FBQ3ZCLFVBQVUsNENBQVc7QUFDckIsV0FBVyw0Q0FBVztBQUN0QixVQUFVLDRDQUFXO0FBQ3JCLFNBQVMsNENBQVc7QUFDcEIsWUFBWSw0Q0FBVztBQUN2QixZQUFZLDRDQUFXO0FBQ3ZCLGFBQWEsNENBQVc7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQ0FBVTtBQUNqQztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLHFEQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtB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ZHQvbm9kZV9tb2R1bGVzL2xpYjAvbG9nZ2luZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSXNvbW9ycGhpYyBsb2dnaW5nIG1vZHVsZSB3aXRoIHN1cHBvcnQgZm9yIGNvbG9ycyFcbiAqXG4gKiBAbW9kdWxlIGxvZ2dpbmdcbiAqL1xuXG5pbXBvcnQgKiBhcyBlbnYgZnJvbSAnLi9lbnZpcm9ubWVudC5qcydcbmltcG9ydCAqIGFzIHN5bWJvbCBmcm9tICcuL3N5bWJvbC5qcydcbmltcG9ydCAqIGFzIHBhaXIgZnJvbSAnLi9wYWlyLmpzJ1xuaW1wb3J0ICogYXMgZG9tIGZyb20gJy4vZG9tLmpzJ1xuaW1wb3J0ICogYXMganNvbiBmcm9tICcuL2pzb24uanMnXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5pbXBvcnQgKiBhcyBldmVudGxvb3AgZnJvbSAnLi9ldmVudGxvb3AuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnLi90aW1lLmpzJ1xuaW1wb3J0ICogYXMgZnVuYyBmcm9tICcuL2Z1bmN0aW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IFVOQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IEJMVUUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBHUkVZID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgR1JFRU4gPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBSRUQgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBQVVJQTEUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBPUkFOR0UgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBVTkNPTE9SID0gc3ltYm9sLmNyZWF0ZSgpXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxTeW1ib2wscGFpci5QYWlyPHN0cmluZyxzdHJpbmc+Pn1cbiAqL1xuY29uc3QgX2Jyb3dzZXJTdHlsZU1hcCA9IHtcbiAgW0JPTERdOiBwYWlyLmNyZWF0ZSgnZm9udC13ZWlnaHQnLCAnYm9sZCcpLFxuICBbVU5CT0xEXTogcGFpci5jcmVhdGUoJ2ZvbnQtd2VpZ2h0JywgJ25vcm1hbCcpLFxuICBbQkxVRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibHVlJyksXG4gIFtHUkVFTl06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdncmVlbicpLFxuICBbR1JFWV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdncmV5JyksXG4gIFtSRURdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAncmVkJyksXG4gIFtQVVJQTEVdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAncHVycGxlJyksXG4gIFtPUkFOR0VdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnb3JhbmdlJyksIC8vIG5vdCB3ZWxsIHN1cHBvcnRlZCBpbiBjaHJvbWUgd2hlbiBkZWJ1Z2dpbmcgbm9kZSB3aXRoIGluc3BlY3RvciAtIFRPRE86IGRlcHJlY2F0ZVxuICBbVU5DT0xPUl06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibGFjaycpXG59XG5cbmNvbnN0IF9ub2RlU3R5bGVNYXAgPSB7XG4gIFtCT0xEXTogJ1xcdTAwMWJbMW0nLFxuICBbVU5CT0xEXTogJ1xcdTAwMWJbMm0nLFxuICBbQkxVRV06ICdcXHgxYlszNG0nLFxuICBbR1JFRU5dOiAnXFx4MWJbMzJtJyxcbiAgW0dSRVldOiAnXFx1MDAxYlszN20nLFxuICBbUkVEXTogJ1xceDFiWzMxbScsXG4gIFtQVVJQTEVdOiAnXFx4MWJbMzVtJyxcbiAgW09SQU5HRV06ICdcXHgxYlszODs1OzIwOG0nLFxuICBbVU5DT0xPUl06ICdcXHgxYlswbSdcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8b2JqZWN0fG51bWJlcj59XG4gKi9cbmNvbnN0IGNvbXB1dGVCcm93c2VyTG9nZ2luZ0FyZ3MgPSBhcmdzID0+IHtcbiAgY29uc3Qgc3RyQnVpbGRlciA9IFtdXG4gIGNvbnN0IHN0eWxlcyA9IFtdXG4gIGNvbnN0IGN1cnJlbnRTdHlsZSA9IG1hcC5jcmVhdGUoKVxuICAvKipcbiAgICogQHR5cGUge0FycmF5PHN0cmluZ3xPYmplY3R8bnVtYmVyPn1cbiAgICovXG4gIGxldCBsb2dBcmdzID0gW11cbiAgLy8gdHJ5IHdpdGggZm9ybWF0dGluZyB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB1bnN1cHBvcnRlZFxuICBsZXQgaSA9IDBcblxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHN0eWxlID0gX2Jyb3dzZXJTdHlsZU1hcFthcmddXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1cnJlbnRTdHlsZS5zZXQoc3R5bGUubGVmdCwgc3R5bGUucmlnaHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvbS5tYXBUb1N0eWxlU3RyaW5nKGN1cnJlbnRTdHlsZSlcbiAgICAgICAgaWYgKGkgPiAwIHx8IHN0eWxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdHJCdWlsZGVyLnB1c2goJyVjJyArIGFyZylcbiAgICAgICAgICBzdHlsZXMucHVzaChzdHlsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpID4gMCkge1xuICAgIC8vIGNyZWF0ZSBsb2dBcmdzIHdpdGggd2hhdCB3ZSBoYXZlIHNvIGZhclxuICAgIGxvZ0FyZ3MgPSBzdHlsZXNcbiAgICBsb2dBcmdzLnVuc2hpZnQoc3RyQnVpbGRlci5qb2luKCcnKSlcbiAgfVxuICAvLyBhcHBlbmQgdGhlIHJlc3RcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChhcmcpXG4gICAgfVxuICB9XG4gIHJldHVybiBsb2dBcmdzXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8b2JqZWN0fG51bWJlcj59XG4gKi9cbmNvbnN0IGNvbXB1dGVOb2RlTG9nZ2luZ0FyZ3MgPSBhcmdzID0+IHtcbiAgY29uc3Qgc3RyQnVpbGRlciA9IFtdXG4gIGNvbnN0IGxvZ0FyZ3MgPSBbXVxuXG4gIC8vIHRyeSB3aXRoIGZvcm1hdHRpbmcgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdW5zdXBwb3J0ZWRcbiAgbGV0IGkgPSAwXG5cbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdHlsZSA9IF9ub2RlU3R5bGVNYXBbYXJnXVxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHJCdWlsZGVyLnB1c2goc3R5bGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGkgPiAwKSB7XG4gICAgLy8gY3JlYXRlIGxvZ0FyZ3Mgd2l0aCB3aGF0IHdlIGhhdmUgc28gZmFyXG4gICAgc3RyQnVpbGRlci5wdXNoKCdcXHgxYlswbScpXG4gICAgbG9nQXJncy5wdXNoKHN0ckJ1aWxkZXIuam9pbignJykpXG4gIH1cbiAgLy8gYXBwZW5kIHRoZSByZXN0XG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChhcmcpXG4gICAgfVxuICB9XG4gIHJldHVybiBsb2dBcmdzXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBjb21wdXRlTG9nZ2luZ0FyZ3MgPSBlbnYuaXNOb2RlID8gY29tcHV0ZU5vZGVMb2dnaW5nQXJncyA6IGNvbXB1dGVCcm93c2VyTG9nZ2luZ0FyZ3NcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW50ID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5sb2coLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5wcmludChhcmdzKSlcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCB3YXJuID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS53YXJuKC4uLmNvbXB1dGVMb2dnaW5nQXJncyhhcmdzKSlcbiAgYXJncy51bnNoaWZ0KE9SQU5HRSlcbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMucHJpbnQoYXJncykpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICovXG5leHBvcnQgY29uc3QgcHJpbnRFcnJvciA9IGVyciA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyKVxuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5wcmludEVycm9yKGVycikpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgaW1hZ2UgbG9jYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0IG9mIHRoZSBpbWFnZSBpbiBwaXhlbFxuICovXG5leHBvcnQgY29uc3QgcHJpbnRJbWcgPSAodXJsLCBoZWlnaHQpID0+IHtcbiAgaWYgKGVudi5pc0Jyb3dzZXIpIHtcbiAgICBjb25zb2xlLmxvZygnJWMgICAgICAgICAgICAgICAgICAgICAgJywgYGZvbnQtc2l6ZTogJHtoZWlnaHR9cHg7IGJhY2tncm91bmQtc2l6ZTogY29udGFpbjsgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7dXJsfSlgKVxuICAgIC8vIGNvbnNvbGUubG9nKCclYyAgICAgICAgICAgICAgICAnLCBgZm9udC1zaXplOiAke2hlaWdodH14OyBiYWNrZ3JvdW5kOiB1cmwoJHt1cmx9KSBuby1yZXBlYXQ7YClcbiAgfVxuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5wcmludEltZyh1cmwsIGhlaWdodCkpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW50SW1nQmFzZTY0ID0gKGJhc2U2NCwgaGVpZ2h0KSA9PiBwcmludEltZyhgZGF0YTppbWFnZS9naWY7YmFzZTY0LCR7YmFzZTY0fWAsIGhlaWdodClcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5ncm91cCguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLmdyb3VwKGFyZ3MpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICovXG5leHBvcnQgY29uc3QgZ3JvdXBDb2xsYXBzZWQgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKC4uLmNvbXB1dGVMb2dnaW5nQXJncyhhcmdzKSlcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMuZ3JvdXBDb2xsYXBzZWQoYXJncykpXG59XG5cbmV4cG9ydCBjb25zdCBncm91cEVuZCA9ICgpID0+IHtcbiAgY29uc29sZS5ncm91cEVuZCgpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLmdyb3VwRW5kKCkpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpOb2RlfSBjcmVhdGVOb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBwcmludERvbSA9IGNyZWF0ZU5vZGUgPT5cbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMucHJpbnREb20oY3JlYXRlTm9kZSgpKSlcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCBwcmludENhbnZhcyA9IChjYW52YXMsIGhlaWdodCkgPT4gcHJpbnRJbWcoY2FudmFzLnRvRGF0YVVSTCgpLCBoZWlnaHQpXG5cbmV4cG9ydCBjb25zdCB2Y29uc29sZXMgPSBuZXcgU2V0KClcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxFbGVtZW50Pn1cbiAqL1xuY29uc3QgX2NvbXB1dGVMaW5lU3BhbnMgPSBhcmdzID0+IHtcbiAgY29uc3Qgc3BhbnMgPSBbXVxuICBjb25zdCBjdXJyZW50U3R5bGUgPSBuZXcgTWFwKClcbiAgLy8gdHJ5IHdpdGggZm9ybWF0dGluZyB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB1bnN1cHBvcnRlZFxuICBsZXQgaSA9IDBcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdHlsZSA9IF9icm93c2VyU3R5bGVNYXBbYXJnXVxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdXJyZW50U3R5bGUuc2V0KHN0eWxlLmxlZnQsIHN0eWxlLnJpZ2h0KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgfHwgYXJnLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBzcGFuID0gZG9tLmVsZW1lbnQoJ3NwYW4nLCBbcGFpci5jcmVhdGUoJ3N0eWxlJywgZG9tLm1hcFRvU3R5bGVTdHJpbmcoY3VycmVudFN0eWxlKSldLCBbZG9tLnRleHQoYXJnKV0pXG4gICAgICAgIGlmIChzcGFuLmlubmVySFRNTCA9PT0gJycpIHtcbiAgICAgICAgICBzcGFuLmlubmVySFRNTCA9ICcmbmJzcDsnXG4gICAgICAgIH1cbiAgICAgICAgc3BhbnMucHVzaChzcGFuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gYXBwZW5kIHRoZSByZXN0XG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjb250ZW50ID0gYXJnc1tpXVxuICAgIGlmICghKGNvbnRlbnQgaW5zdGFuY2VvZiBTeW1ib2wpKSB7XG4gICAgICBpZiAoY29udGVudC5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nICYmIGNvbnRlbnQuY29uc3RydWN0b3IgIT09IE51bWJlcikge1xuICAgICAgICBjb250ZW50ID0gJyAnICsganNvbi5zdHJpbmdpZnkoY29udGVudCkgKyAnICdcbiAgICAgIH1cbiAgICAgIHNwYW5zLnB1c2goZG9tLmVsZW1lbnQoJ3NwYW4nLCBbXSwgW2RvbS50ZXh0KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoY29udGVudCkpXSkpXG4gICAgfVxuICB9XG4gIHJldHVybiBzcGFuc1xufVxuXG5jb25zdCBsaW5lU3R5bGUgPSAnZm9udC1mYW1pbHk6bW9ub3NwYWNlO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlMmUyZTI7cGFkZGluZzoycHg7J1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNsYXNzIFZDb25zb2xlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9tKSB7XG4gICAgdGhpcy5kb20gPSBkb21cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNjb250YWluZXIgPSB0aGlzLmRvbVxuICAgIHRoaXMuZGVwdGggPSAwXG4gICAgdmNvbnNvbGVzLmFkZCh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbGxhcHNlZFxuICAgKi9cbiAgZ3JvdXAgKGFyZ3MsIGNvbGxhcHNlZCA9IGZhbHNlKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgY29uc3QgdHJpYW5nbGVEb3duID0gZG9tLmVsZW1lbnQoJ3NwYW4nLCBbcGFpci5jcmVhdGUoJ2hpZGRlbicsIGNvbGxhcHNlZCksIHBhaXIuY3JlYXRlKCdzdHlsZScsICdjb2xvcjpncmV5O2ZvbnQtc2l6ZToxMjAlOycpXSwgW2RvbS50ZXh0KCfilrwnKV0pXG4gICAgICBjb25zdCB0cmlhbmdsZVJpZ2h0ID0gZG9tLmVsZW1lbnQoJ3NwYW4nLCBbcGFpci5jcmVhdGUoJ2hpZGRlbicsICFjb2xsYXBzZWQpLCBwYWlyLmNyZWF0ZSgnc3R5bGUnLCAnY29sb3I6Z3JleTtmb250LXNpemU6MTI1JTsnKV0sIFtkb20udGV4dCgn4pa2JyldKVxuICAgICAgY29uc3QgY29udGVudCA9IGRvbS5lbGVtZW50KCdkaXYnLCBbcGFpci5jcmVhdGUoJ3N0eWxlJywgYCR7bGluZVN0eWxlfTtwYWRkaW5nLWxlZnQ6JHt0aGlzLmRlcHRoICogMTB9cHhgKV0sIFt0cmlhbmdsZURvd24sIHRyaWFuZ2xlUmlnaHQsIGRvbS50ZXh0KCcgJyldLmNvbmNhdChfY29tcHV0ZUxpbmVTcGFucyhhcmdzKSkpXG4gICAgICBjb25zdCBuZXh0Q29udGFpbmVyID0gZG9tLmVsZW1lbnQoJ2RpdicsIFtwYWlyLmNyZWF0ZSgnaGlkZGVuJywgY29sbGFwc2VkKV0pXG4gICAgICBjb25zdCBuZXh0TGluZSA9IGRvbS5lbGVtZW50KCdkaXYnLCBbXSwgW2NvbnRlbnQsIG5leHRDb250YWluZXJdKVxuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtuZXh0TGluZV0pXG4gICAgICB0aGlzLmNjb250YWluZXIgPSBuZXh0Q29udGFpbmVyXG4gICAgICB0aGlzLmRlcHRoKytcbiAgICAgIC8vIHdoZW4gaGVhZGVyIGlzIGNsaWNrZWQsIGNvbGxhcHNlL3VuY29sbGFwc2UgY29udGFpbmVyXG4gICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihjb250ZW50LCAnY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIG5leHRDb250YWluZXIudG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKVxuICAgICAgICB0cmlhbmdsZURvd24udG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKVxuICAgICAgICB0cmlhbmdsZVJpZ2h0LnRvZ2dsZUF0dHJpYnV0ZSgnaGlkZGVuJylcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICovXG4gIGdyb3VwQ29sbGFwc2VkIChhcmdzKSB7XG4gICAgdGhpcy5ncm91cChhcmdzLCB0cnVlKVxuICB9XG5cbiAgZ3JvdXBFbmQgKCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlcHRoID4gMCkge1xuICAgICAgICB0aGlzLmRlcHRoLS1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmNjb250YWluZXIgPSB0aGlzLmNjb250YWluZXIucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICovXG4gIHByaW50IChhcmdzKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtkb20uZWxlbWVudCgnZGl2JywgW3BhaXIuY3JlYXRlKCdzdHlsZScsIGAke2xpbmVTdHlsZX07cGFkZGluZy1sZWZ0OiR7dGhpcy5kZXB0aCAqIDEwfXB4YCldLCBfY29tcHV0ZUxpbmVTcGFucyhhcmdzKSldKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gICAqL1xuICBwcmludEVycm9yIChlcnIpIHtcbiAgICB0aGlzLnByaW50KFtSRUQsIEJPTEQsIGVyci50b1N0cmluZygpXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHByaW50SW1nICh1cmwsIGhlaWdodCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbZG9tLmVsZW1lbnQoJ2ltZycsIFtwYWlyLmNyZWF0ZSgnc3JjJywgdXJsKSwgcGFpci5jcmVhdGUoJ2hlaWdodCcsIGAke21hdGgucm91bmQoaGVpZ2h0ICogMS41KX1weGApXSldKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBwcmludERvbSAobm9kZSkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbbm9kZV0pXG4gICAgfSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIHZjb25zb2xlcy5kZWxldGUodGhpcylcbiAgICB9KVxuICB9XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVWQ29uc29sZSA9IGRvbSA9PiBuZXcgVkNvbnNvbGUoZG9tKVxuXG5jb25zdCBsb2dnaW5nQ29sb3JzID0gW0dSRUVOLCBQVVJQTEUsIE9SQU5HRSwgQkxVRV1cbmxldCBuZXh0Q29sb3IgPSAwXG5sZXQgbGFzdExvZ2dpbmdUaW1lID0gdGltZS5nZXRVbml4VGltZSgpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLmFueSl9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNb2R1bGVMb2dnZXIgPSBtb2R1bGVOYW1lID0+IHtcbiAgY29uc3QgY29sb3IgPSBsb2dnaW5nQ29sb3JzW25leHRDb2xvcl1cbiAgY29uc3QgZGVidWdSZWdleFZhciA9IGVudi5nZXRWYXJpYWJsZSgnbG9nJylcbiAgY29uc3QgZG9Mb2dnaW5nID0gZGVidWdSZWdleFZhciAhPT0gbnVsbCAmJiAoZGVidWdSZWdleFZhciA9PT0gJyonIHx8IGRlYnVnUmVnZXhWYXIgPT09ICd0cnVlJyB8fCBuZXcgUmVnRXhwKGRlYnVnUmVnZXhWYXIsICdnaScpLnRlc3QobW9kdWxlTmFtZSkpXG4gIG5leHRDb2xvciA9IChuZXh0Q29sb3IgKyAxKSAlIGxvZ2dpbmdDb2xvcnMubGVuZ3RoXG4gIG1vZHVsZU5hbWUgKz0gJzogJ1xuXG4gIHJldHVybiAhZG9Mb2dnaW5nID8gZnVuYy5ub3AgOiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHRpbWVOb3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICBjb25zdCB0aW1lRGlmZiA9IHRpbWVOb3cgLSBsYXN0TG9nZ2luZ1RpbWVcbiAgICBsYXN0TG9nZ2luZ1RpbWUgPSB0aW1lTm93XG4gICAgcHJpbnQoY29sb3IsIG1vZHVsZU5hbWUsIFVOQ09MT1IsIC4uLmFyZ3MubWFwKGFyZyA9PiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcpID8gYXJnIDogSlNPTi5zdHJpbmdpZnkoYXJnKSksIGNvbG9yLCAnICsnICsgdGltZURpZmYgKyAnbXMnKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/logging.js\n")},"../CoCreate-crdt/node_modules/lib0/map.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "copy": () => (/* binding */ copy),\n/* harmony export */   "setIfUndefined": () => (/* binding */ setIfUndefined),\n/* harmony export */   "map": () => (/* binding */ map),\n/* harmony export */   "any": () => (/* binding */ any),\n/* harmony export */   "all": () => (/* binding */ all)\n/* harmony export */ });\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nconst copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, \'eventName\', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template T,K\n * @param {Map<K, T>} map\n * @param {K} key\n * @param {function():T} createT\n * @return {T}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nconst map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvbWFwLmpzP2ZmNDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGdCQUFnQjtBQUMzQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsc0JBQXNCO0FBQ2pDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsc0JBQXNCO0FBQ2pDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9tYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBrZXktdmFsdWUgc3RvcmVzLlxuICpcbiAqIEBtb2R1bGUgbWFwXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1hcCBpbnN0YW5jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge01hcDxhbnksIGFueT59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBuZXcgTWFwKClcblxuLyoqXG4gKiBDb3B5IGEgTWFwIG9iamVjdCBpbnRvIGEgZnJlc2ggTWFwIG9iamVjdC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBYLFlcbiAqIEBwYXJhbSB7TWFwPFgsWT59IG1cbiAqIEByZXR1cm4ge01hcDxYLFk+fVxuICovXG5leHBvcnQgY29uc3QgY29weSA9IG0gPT4ge1xuICBjb25zdCByID0gY3JlYXRlKClcbiAgbS5mb3JFYWNoKCh2LCBrKSA9PiB7IHIuc2V0KGssIHYpIH0pXG4gIHJldHVybiByXG59XG5cbi8qKlxuICogR2V0IG1hcCBwcm9wZXJ0eS4gQ3JlYXRlIFQgaWYgcHJvcGVydHkgaXMgdW5kZWZpbmVkIGFuZCBzZXQgVCBvbiBtYXAuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxpc3RlbmVycyA9IG1hcC5zZXRJZlVuZGVmaW5lZChldmVudHMsICdldmVudE5hbWUnLCBzZXQuY3JlYXRlKVxuICogbGlzdGVuZXJzLmFkZChsaXN0ZW5lcilcbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQsS1xuICogQHBhcmFtIHtNYXA8SywgVD59IG1hcFxuICogQHBhcmFtIHtLfSBrZXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpUfSBjcmVhdGVUXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3Qgc2V0SWZVbmRlZmluZWQgPSAobWFwLCBrZXksIGNyZWF0ZVQpID0+IHtcbiAgbGV0IHNldCA9IG1hcC5nZXQoa2V5KVxuICBpZiAoc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXAuc2V0KGtleSwgc2V0ID0gY3JlYXRlVCgpKVxuICB9XG4gIHJldHVybiBzZXRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEFycmF5IGFuZCBwb3B1bGF0ZXMgaXQgd2l0aCB0aGUgY29udGVudCBvZiBhbGwga2V5LXZhbHVlIHBhaXJzIHVzaW5nIHRoZSBgZih2YWx1ZSwga2V5KWAgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEB0ZW1wbGF0ZSBSXG4gKiBAcGFyYW0ge01hcDxLLFY+fSBtXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFYsSyk6Un0gZlxuICogQHJldHVybiB7QXJyYXk8Uj59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAobSwgZikgPT4ge1xuICBjb25zdCByZXMgPSBbXVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgcmVzLnB1c2goZih2YWx1ZSwga2V5KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBhbnkga2V5LXZhbHVlIHBhaXJzIHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgYGYodmFsdWUsIGtleSlgLlxuICpcbiAqIEB0b2RvIHNob3VsZCByZW5hbWUgdG8gc29tZSAtIHNpbWlsYXJseSB0byBBcnJheS5zb21lXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgYW55ID0gKG0sIGYpID0+IHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbSkge1xuICAgIGlmIChmKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGFsbCBrZXktdmFsdWUgcGFpcnMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSBgZih2YWx1ZSwga2V5KWAuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgYWxsID0gKG0sIGYpID0+IHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbSkge1xuICAgIGlmICghZih2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/map.js\n')},"../CoCreate-crdt/node_modules/lib0/math.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "floor": () => (/* binding */ floor),\n/* harmony export */   "ceil": () => (/* binding */ ceil),\n/* harmony export */   "abs": () => (/* binding */ abs),\n/* harmony export */   "imul": () => (/* binding */ imul),\n/* harmony export */   "round": () => (/* binding */ round),\n/* harmony export */   "log10": () => (/* binding */ log10),\n/* harmony export */   "log2": () => (/* binding */ log2),\n/* harmony export */   "log": () => (/* binding */ log),\n/* harmony export */   "sqrt": () => (/* binding */ sqrt),\n/* harmony export */   "add": () => (/* binding */ add),\n/* harmony export */   "min": () => (/* binding */ min),\n/* harmony export */   "max": () => (/* binding */ max),\n/* harmony export */   "isNaN": () => (/* binding */ isNaN),\n/* harmony export */   "pow": () => (/* binding */ pow),\n/* harmony export */   "exp10": () => (/* binding */ exp10),\n/* harmony export */   "sign": () => (/* binding */ sign),\n/* harmony export */   "isNegativeZero": () => (/* binding */ isNegativeZero)\n/* harmony export */ });\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor\nconst ceil = Math.ceil\nconst abs = Math.abs\nconst imul = Math.imul\nconst round = Math.round\nconst log10 = Math.log10\nconst log2 = Math.log2\nconst log = Math.log\nconst sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nconst add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b\n\nconst isNaN = Number.isNaN\n\nconst pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nconst exp10 = exp => Math.pow(10, exp)\n\nconst sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nconst isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvbWF0aC5qcz8yMzZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ087O0FBRUE7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRUE7O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ08iLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9tYXRoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21tb24gTWF0aCBleHByZXNzaW9ucy5cbiAqXG4gKiBAbW9kdWxlIG1hdGhcbiAqL1xuXG5leHBvcnQgY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yXG5leHBvcnQgY29uc3QgY2VpbCA9IE1hdGguY2VpbFxuZXhwb3J0IGNvbnN0IGFicyA9IE1hdGguYWJzXG5leHBvcnQgY29uc3QgaW11bCA9IE1hdGguaW11bFxuZXhwb3J0IGNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZFxuZXhwb3J0IGNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMFxuZXhwb3J0IGNvbnN0IGxvZzIgPSBNYXRoLmxvZzJcbmV4cG9ydCBjb25zdCBsb2cgPSBNYXRoLmxvZ1xuZXhwb3J0IGNvbnN0IHNxcnQgPSBNYXRoLnNxcnRcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3VtIG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IChhLCBiKSA9PiBhICsgYlxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzbWFsbGVyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgY29uc3QgbWluID0gKGEsIGIpID0+IGEgPCBiID8gYSA6IGJcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmlnZ2VyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgY29uc3QgbWF4ID0gKGEsIGIpID0+IGEgPiBiID8gYSA6IGJcblxuZXhwb3J0IGNvbnN0IGlzTmFOID0gTnVtYmVyLmlzTmFOXG5cbmV4cG9ydCBjb25zdCBwb3cgPSBNYXRoLnBvd1xuLyoqXG4gKiBCYXNlIDEwIGV4cG9uZW50aWFsIGZ1bmN0aW9uLiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mIHBvdy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBleHAxMCA9IGV4cCA9PiBNYXRoLnBvdygxMCwgZXhwKVxuXG5leHBvcnQgY29uc3Qgc2lnbiA9IE1hdGguc2lnblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXZXRoZXIgbiBpcyBuZWdhdGl2ZS4gVGhpcyBmdW5jdGlvbiBhbHNvIGRpZmZlcmVudGlhdGVzIGJldHdlZW4gLTAgYW5kICswXG4gKi9cbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlWmVybyA9IG4gPT4gbiAhPT0gMCA/IG4gPCAwIDogMSAvIG4gPCAwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/math.js\n')},"../CoCreate-crdt/node_modules/lib0/metric.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "yotta": () => (/* binding */ yotta),\n/* harmony export */   "zetta": () => (/* binding */ zetta),\n/* harmony export */   "exa": () => (/* binding */ exa),\n/* harmony export */   "peta": () => (/* binding */ peta),\n/* harmony export */   "tera": () => (/* binding */ tera),\n/* harmony export */   "giga": () => (/* binding */ giga),\n/* harmony export */   "mega": () => (/* binding */ mega),\n/* harmony export */   "kilo": () => (/* binding */ kilo),\n/* harmony export */   "hecto": () => (/* binding */ hecto),\n/* harmony export */   "deca": () => (/* binding */ deca),\n/* harmony export */   "deci": () => (/* binding */ deci),\n/* harmony export */   "centi": () => (/* binding */ centi),\n/* harmony export */   "milli": () => (/* binding */ milli),\n/* harmony export */   "micro": () => (/* binding */ micro),\n/* harmony export */   "nano": () => (/* binding */ nano),\n/* harmony export */   "pico": () => (/* binding */ pico),\n/* harmony export */   "femto": () => (/* binding */ femto),\n/* harmony export */   "atto": () => (/* binding */ atto),\n/* harmony export */   "zepto": () => (/* binding */ zepto),\n/* harmony export */   "yocto": () => (/* binding */ yocto),\n/* harmony export */   "prefix": () => (/* binding */ prefix)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../CoCreate-crdt/node_modules/lib0/math.js");\n/**\n * Utility module to convert metric values.\n *\n * @module metric\n */\n\n\n\nconst yotta = 1e24\nconst zetta = 1e21\nconst exa = 1e18\nconst peta = 1e15\nconst tera = 1e12\nconst giga = 1e9\nconst mega = 1e6\nconst kilo = 1e3\nconst hecto = 1e2\nconst deca = 10\nconst deci = 0.1\nconst centi = 0.01\nconst milli = 1e-3\nconst micro = 1e-6\nconst nano = 1e-9\nconst pico = 1e-12\nconst femto = 1e-15\nconst atto = 1e-18\nconst zepto = 1e-21\nconst yocto = 1e-24\n\nconst prefixUp = [\'\', \'k\', \'M\', \'G\', \'T\', \'P\', \'E\', \'Z\', \'Y\']\nconst prefixDown = [\'\', \'m\', \'μ\', \'n\', \'p\', \'f\', \'a\', \'z\', \'y\']\n\n/**\n * Calculate the metric prefix for a number. Assumes E.g. `prefix(1000) = { n: 1, prefix: \'k\' }`\n *\n * @param {number} n\n * @param {number} [baseMultiplier] Multiplier of the base (10^(3*baseMultiplier)). E.g. `convert(time, -3)` if time is already in milli seconds\n * @return {{n:number,prefix:string}}\n */\nconst prefix = (n, baseMultiplier = 0) => {\n  const nPow = n === 0 ? 0 : _math_js__WEBPACK_IMPORTED_MODULE_0__.log10(n)\n  let mult = 0\n  while (nPow < mult * 3 && baseMultiplier > -8) {\n    baseMultiplier--\n    mult--\n  }\n  while (nPow >= 3 + mult * 3 && baseMultiplier < 8) {\n    baseMultiplier++\n    mult++\n  }\n  const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier]\n  return {\n    n: _math_js__WEBPACK_IMPORTED_MODULE_0__.round((mult > 0 ? n / _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * 3) : n * _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * -3)) * 1e12) / 1e12,\n    prefix\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvbWV0cmljLmpzP2Y3NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsb0JBQW9CO0FBQy9GO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QiwyQ0FBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywyQ0FBVSxpQkFBaUIsMkNBQVUsaUJBQWlCLDJDQUFVO0FBQ3ZFO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9saWIwL21ldHJpYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gY29udmVydCBtZXRyaWMgdmFsdWVzLlxuICpcbiAqIEBtb2R1bGUgbWV0cmljXG4gKi9cblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5cbmV4cG9ydCBjb25zdCB5b3R0YSA9IDFlMjRcbmV4cG9ydCBjb25zdCB6ZXR0YSA9IDFlMjFcbmV4cG9ydCBjb25zdCBleGEgPSAxZTE4XG5leHBvcnQgY29uc3QgcGV0YSA9IDFlMTVcbmV4cG9ydCBjb25zdCB0ZXJhID0gMWUxMlxuZXhwb3J0IGNvbnN0IGdpZ2EgPSAxZTlcbmV4cG9ydCBjb25zdCBtZWdhID0gMWU2XG5leHBvcnQgY29uc3Qga2lsbyA9IDFlM1xuZXhwb3J0IGNvbnN0IGhlY3RvID0gMWUyXG5leHBvcnQgY29uc3QgZGVjYSA9IDEwXG5leHBvcnQgY29uc3QgZGVjaSA9IDAuMVxuZXhwb3J0IGNvbnN0IGNlbnRpID0gMC4wMVxuZXhwb3J0IGNvbnN0IG1pbGxpID0gMWUtM1xuZXhwb3J0IGNvbnN0IG1pY3JvID0gMWUtNlxuZXhwb3J0IGNvbnN0IG5hbm8gPSAxZS05XG5leHBvcnQgY29uc3QgcGljbyA9IDFlLTEyXG5leHBvcnQgY29uc3QgZmVtdG8gPSAxZS0xNVxuZXhwb3J0IGNvbnN0IGF0dG8gPSAxZS0xOFxuZXhwb3J0IGNvbnN0IHplcHRvID0gMWUtMjFcbmV4cG9ydCBjb25zdCB5b2N0byA9IDFlLTI0XG5cbmNvbnN0IHByZWZpeFVwID0gWycnLCAnaycsICdNJywgJ0cnLCAnVCcsICdQJywgJ0UnLCAnWicsICdZJ11cbmNvbnN0IHByZWZpeERvd24gPSBbJycsICdtJywgJ868JywgJ24nLCAncCcsICdmJywgJ2EnLCAneicsICd5J11cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1ldHJpYyBwcmVmaXggZm9yIGEgbnVtYmVyLiBBc3N1bWVzIEUuZy4gYHByZWZpeCgxMDAwKSA9IHsgbjogMSwgcHJlZml4OiAnaycgfWBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHBhcmFtIHtudW1iZXJ9IFtiYXNlTXVsdGlwbGllcl0gTXVsdGlwbGllciBvZiB0aGUgYmFzZSAoMTBeKDMqYmFzZU11bHRpcGxpZXIpKS4gRS5nLiBgY29udmVydCh0aW1lLCAtMylgIGlmIHRpbWUgaXMgYWxyZWFkeSBpbiBtaWxsaSBzZWNvbmRzXG4gKiBAcmV0dXJuIHt7bjpudW1iZXIscHJlZml4OnN0cmluZ319XG4gKi9cbmV4cG9ydCBjb25zdCBwcmVmaXggPSAobiwgYmFzZU11bHRpcGxpZXIgPSAwKSA9PiB7XG4gIGNvbnN0IG5Qb3cgPSBuID09PSAwID8gMCA6IG1hdGgubG9nMTAobilcbiAgbGV0IG11bHQgPSAwXG4gIHdoaWxlIChuUG93IDwgbXVsdCAqIDMgJiYgYmFzZU11bHRpcGxpZXIgPiAtOCkge1xuICAgIGJhc2VNdWx0aXBsaWVyLS1cbiAgICBtdWx0LS1cbiAgfVxuICB3aGlsZSAoblBvdyA+PSAzICsgbXVsdCAqIDMgJiYgYmFzZU11bHRpcGxpZXIgPCA4KSB7XG4gICAgYmFzZU11bHRpcGxpZXIrK1xuICAgIG11bHQrK1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGJhc2VNdWx0aXBsaWVyIDwgMCA/IHByZWZpeERvd25bLWJhc2VNdWx0aXBsaWVyXSA6IHByZWZpeFVwW2Jhc2VNdWx0aXBsaWVyXVxuICByZXR1cm4ge1xuICAgIG46IG1hdGgucm91bmQoKG11bHQgPiAwID8gbiAvIG1hdGguZXhwMTAobXVsdCAqIDMpIDogbiAqIG1hdGguZXhwMTAobXVsdCAqIC0zKSkgKiAxZTEyKSAvIDFlMTIsXG4gICAgcHJlZml4XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/metric.js\n')},"../CoCreate-crdt/node_modules/lib0/mutex.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createMutex": () => (/* binding */ createMutex)\n/* harmony export */ });\n/**\n * Mutual exclude for JavaScript.\n *\n * @module mutex\n */\n\n/**\n * @callback mutex\n * @param {function():void} cb Only executed when this mutex is not in the current stack\n * @param {function():void} [elseCb] Executed when this mutex is in the current stack\n */\n\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n *\n * @return {mutex} A mutual exclude function\n * @public\n */\nconst createMutex = () => {\n  let token = true\n  return (f, g) => {\n    if (token) {\n      token = false\n      try {\n        f()\n      } finally {\n        token = true\n      }\n    } else if (g !== undefined) {\n      g()\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvbXV0ZXguanM/NDRiOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxnQkFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvbXV0ZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE11dHVhbCBleGNsdWRlIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEBtb2R1bGUgbXV0ZXhcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBtdXRleFxuICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGNiIE9ubHkgZXhlY3V0ZWQgd2hlbiB0aGlzIG11dGV4IGlzIG5vdCBpbiB0aGUgY3VycmVudCBzdGFja1xuICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IFtlbHNlQ2JdIEV4ZWN1dGVkIHdoZW4gdGhpcyBtdXRleCBpcyBpbiB0aGUgY3VycmVudCBzdGFja1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbXV0ZXggPSBjcmVhdGVNdXRleCgpXG4gKiBtdXRleCgoKSA9PiB7XG4gKiAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgaW1tZWRpYXRlbHkgZXhlY3V0ZWRcbiAqICAgbXV0ZXgoKCkgPT4ge1xuICogICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhcyB0aGUgbXV0ZXggaXMgYWxyZWFkeSBhY3RpdmUuXG4gKiAgIH0pXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHJldHVybiB7bXV0ZXh9IEEgbXV0dWFsIGV4Y2x1ZGUgZnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU11dGV4ID0gKCkgPT4ge1xuICBsZXQgdG9rZW4gPSB0cnVlXG4gIHJldHVybiAoZiwgZykgPT4ge1xuICAgIGlmICh0b2tlbikge1xuICAgICAgdG9rZW4gPSBmYWxzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZigpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0b2tlbiA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZygpXG4gICAgfVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/mutex.js\n')},"../CoCreate-crdt/node_modules/lib0/number.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "MAX_SAFE_INTEGER": () => (/* binding */ MAX_SAFE_INTEGER),\n/* harmony export */   "MIN_SAFE_INTEGER": () => (/* binding */ MIN_SAFE_INTEGER),\n/* harmony export */   "LOWEST_INT32": () => (/* binding */ LOWEST_INT32),\n/* harmony export */   "HIGHEST_INT32": () => (/* binding */ HIGHEST_INT32),\n/* harmony export */   "isInteger": () => (/* binding */ isInteger),\n/* harmony export */   "isNaN": () => (/* binding */ isNaN)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "../CoCreate-crdt/node_modules/lib0/math.js");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary.js */ "../CoCreate-crdt/node_modules/lib0/binary.js");\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nconst MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nconst LOWEST_INT32 = 1 << 31\n/**\n * @type {number}\n */\nconst HIGHEST_INT32 = _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS31\n\n/**\n * @module number\n */\n\n/* istanbul ignore next */\nconst isInteger = Number.isInteger || (num => typeof num === \'number\' && isFinite(num) && _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num) === num)\nconst isNaN = Number.isNaN\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvbnVtYmVyLmpzP2RiMzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNJOztBQUU5QjtBQUNBOztBQUVBO0FBQ1A7QUFDQSxVQUFVO0FBQ1Y7QUFDTyxzQkFBc0IsOENBQWE7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLDBGQUEwRiwyQ0FBVTtBQUNwRyIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9saWIwL251bWJlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBoZWxwZXJzIGZvciB3b3JraW5nIHdpdGggbnVtYmVycy5cbiAqXG4gKiBAbW9kdWxlIG51bWJlclxuICovXG5cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJy4vYmluYXJ5LmpzJ1xuXG5leHBvcnQgY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG5leHBvcnQgY29uc3QgTUlOX1NBRkVfSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG5cbmV4cG9ydCBjb25zdCBMT1dFU1RfSU5UMzIgPSAxIDw8IDMxXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBISUdIRVNUX0lOVDMyID0gYmluYXJ5LkJJVFMzMVxuXG4vKipcbiAqIEBtb2R1bGUgbnVtYmVyXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IChudW0gPT4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUobnVtKSAmJiBtYXRoLmZsb29yKG51bSkgPT09IG51bSlcbmV4cG9ydCBjb25zdCBpc05hTiA9IE51bWJlci5pc05hTlxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/number.js\n')},"../CoCreate-crdt/node_modules/lib0/object.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "assign": () => (/* binding */ assign),\n/* harmony export */   "keys": () => (/* binding */ keys),\n/* harmony export */   "forEach": () => (/* binding */ forEach),\n/* harmony export */   "map": () => (/* binding */ map),\n/* harmony export */   "length": () => (/* binding */ length),\n/* harmony export */   "some": () => (/* binding */ some),\n/* harmony export */   "every": () => (/* binding */ every),\n/* harmony export */   "hasProperty": () => (/* binding */ hasProperty),\n/* harmony export */   "equalFlat": () => (/* binding */ equalFlat)\n/* harmony export */ });\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nconst create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nconst assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):any} f\n */\nconst forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nconst map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvb2JqZWN0LmpzP2FhZWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDTzs7QUFFUDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsNkJBQTZCO0FBQ3hDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLDZCQUE2QjtBQUN4QyxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVk7QUFDWjtBQUNPIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvb2JqZWN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIEVjbWFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAbW9kdWxlIG9iamVjdFxuICovXG5cbi8qKlxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IE9iamVjdC5jcmVhdGUobnVsbClcblxuLyoqXG4gKiBPYmplY3QuYXNzaWduXG4gKi9cbmV4cG9ydCBjb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICovXG5leHBvcnQgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGYob2JqW2tleV0sIGtleSlcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBSXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOlJ9IGZcbiAqIEByZXR1cm4ge0FycmF5PFI+fVxuICovXG5leHBvcnQgY29uc3QgbWFwID0gKG9iaiwgZikgPT4ge1xuICBjb25zdCByZXN1bHRzID0gW11cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmVzdWx0cy5wdXNoKGYob2JqW2tleV0sIGtleSkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdHNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBsZW5ndGggPSBvYmogPT4ga2V5cyhvYmopLmxlbmd0aFxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LHN0cmluZyk6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IHNvbWUgPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChmKG9ialtrZXldLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBldmVyeSA9IChvYmosIGYpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFmKG9ialtrZXldLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBDYWxscyBgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHthbnl9IG9ialxuICogQHBhcmFtIHtzdHJpbmd8c3ltYm9sfSBrZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNQcm9wZXJ0eSA9IChvYmosIGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsRmxhdCA9IChhLCBiKSA9PiBhID09PSBiIHx8IChsZW5ndGgoYSkgPT09IGxlbmd0aChiKSAmJiBldmVyeShhLCAodmFsLCBrZXkpID0+ICh2YWwgIT09IHVuZGVmaW5lZCB8fCBoYXNQcm9wZXJ0eShiLCBrZXkpKSAmJiBiW2tleV0gPT09IHZhbCkpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/object.js\n')},"../CoCreate-crdt/node_modules/lib0/observable.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Observable": () => (/* binding */ Observable)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ "../CoCreate-crdt/node_modules/lib0/map.js");\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set.js */ "../CoCreate-crdt/node_modules/lib0/set.js");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "../CoCreate-crdt/node_modules/lib0/array.js");\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n\n\n\n\n/**\n * Handles named events.\n *\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    _map_js__WEBPACK_IMPORTED_MODULE_0__.setIfUndefined(this._observers, name, _set_js__WEBPACK_IMPORTED_MODULE_1__.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return _array_js__WEBPACK_IMPORTED_MODULE_2__.from((this._observers.get(name) || _map_js__WEBPACK_IMPORTED_MODULE_0__.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvb2JzZXJ2YWJsZS5qcz8wZDkyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQjtBQUNBO0FBQ0k7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHNCQUFzQiwyQ0FBVTtBQUNoQzs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsSUFBSSxtREFBa0Isd0JBQXdCLDJDQUFVO0FBQ3hEOztBQUVBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJDQUFVLCtCQUErQiwyQ0FBVTtBQUM5RDs7QUFFQTtBQUNBLHNCQUFzQiwyQ0FBVTtBQUNoQztBQUNBIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvb2JzZXJ2YWJsZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT2JzZXJ2YWJsZSBjbGFzcyBwcm90b3R5cGUuXG4gKlxuICogQG1vZHVsZSBvYnNlcnZhYmxlXG4gKi9cblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcblxuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqXG4gKiBAdGVtcGxhdGUgTlxuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBTb21lIGRlc2MuXG4gICAgICogQHR5cGUge01hcDxOLCBhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbiAobmFtZSwgZikge1xuICAgIG1hcC5zZXRJZlVuZGVmaW5lZCh0aGlzLl9vYnNlcnZlcnMsIG5hbWUsIHNldC5jcmVhdGUpLmFkZChmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbmNlIChuYW1lLCBmKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG4gICAgICovXG4gICAgY29uc3QgX2YgPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5vZmYobmFtZSwgX2YpXG4gICAgICBmKC4uLmFyZ3MpXG4gICAgfVxuICAgIHRoaXMub24obmFtZSwgX2YpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZiAobmFtZSwgZikge1xuICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycy5nZXQobmFtZSlcbiAgICBpZiAob2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ic2VydmVycy5kZWxldGUoZilcbiAgICAgIGlmIChvYnNlcnZlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG5hbWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYSBuYW1lZCBldmVudC4gQWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbGlzdGVuIHRvIHRoZVxuICAgKiBzcGVjaWZpZWQgbmFtZSB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAdG9kbyBUaGlzIHNob3VsZCBjYXRjaCBleGNlcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzIFRoZSBhcmd1bWVudHMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBlbWl0IChuYW1lLCBhcmdzKSB7XG4gICAgLy8gY29weSBhbGwgbGlzdGVuZXJzIHRvIGFuIGFycmF5IGZpcnN0IHRvIG1ha2Ugc3VyZSB0aGF0IG5vIGV2ZW50IGlzIGVtaXR0ZWQgdG8gbGlzdGVuZXJzIHRoYXQgYXJlIHN1YnNjcmliZWQgd2hpbGUgdGhlIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkLlxuICAgIHJldHVybiBhcnJheS5mcm9tKCh0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpIHx8IG1hcC5jcmVhdGUoKSkudmFsdWVzKCkpLmZvckVhY2goZiA9PiBmKC4uLmFyZ3MpKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gbWFwLmNyZWF0ZSgpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/observable.js\n')},"../CoCreate-crdt/node_modules/lib0/pair.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Pair": () => (/* binding */ Pair),\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "createReversed": () => (/* binding */ createReversed),\n/* harmony export */   "forEach": () => (/* binding */ forEach),\n/* harmony export */   "map": () => (/* binding */ map)\n/* harmony export */ });\n/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nclass Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left\n    this.right = right\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nconst create = (left, right) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nconst createReversed = (right, left) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nconst forEach = (arr, f) => arr.forEach(p => f(p.left, p.right))\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nconst map = (arr, f) => arr.map(p => f(p.left, p.right))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvcGFpci5qcz9kMmM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVk7QUFDWjtBQUNPIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvcGFpci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV29ya2luZyB3aXRoIHZhbHVlIHBhaXJzLlxuICpcbiAqIEBtb2R1bGUgcGFpclxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICovXG5leHBvcnQgY2xhc3MgUGFpciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0x9IGxlZnRcbiAgICogQHBhcmFtIHtSfSByaWdodFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxlZnQsIHJpZ2h0KSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdFxuICAgIHRoaXMucmlnaHQgPSByaWdodFxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICogQHBhcmFtIHtMfSBsZWZ0XG4gKiBAcGFyYW0ge1J9IHJpZ2h0XG4gKiBAcmV0dXJuIHtQYWlyPEwsUj59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAobGVmdCwgcmlnaHQpID0+IG5ldyBQYWlyKGxlZnQsIHJpZ2h0KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqIEBwYXJhbSB7Un0gcmlnaHRcbiAqIEBwYXJhbSB7TH0gbGVmdFxuICogQHJldHVybiB7UGFpcjxMLFI+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmV2ZXJzZWQgPSAocmlnaHQsIGxlZnQpID0+IG5ldyBQYWlyKGxlZnQsIHJpZ2h0KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqIEBwYXJhbSB7QXJyYXk8UGFpcjxMLFI+Pn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEwsIFIpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChhcnIsIGYpID0+IGFyci5mb3JFYWNoKHAgPT4gZihwLmxlZnQsIHAucmlnaHQpKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFIsWFxuICogQHBhcmFtIHtBcnJheTxQYWlyPEwsUj4+fSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oTCwgUik6WH0gZlxuICogQHJldHVybiB7QXJyYXk8WD59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAoYXJyLCBmKSA9PiBhcnIubWFwKHAgPT4gZihwLmxlZnQsIHAucmlnaHQpKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/pair.js\n')},"../CoCreate-crdt/node_modules/lib0/promise.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "createEmpty": () => (/* binding */ createEmpty),\n/* harmony export */   "all": () => (/* binding */ all),\n/* harmony export */   "reject": () => (/* binding */ reject),\n/* harmony export */   "resolve": () => (/* binding */ resolve),\n/* harmony export */   "until": () => (/* binding */ until),\n/* harmony export */   "wait": () => (/* binding */ wait),\n/* harmony export */   "isPromise": () => (/* binding */ isPromise)\n/* harmony export */ });\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ "../CoCreate-crdt/node_modules/lib0/time.js");\n/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\n\n\n\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\nconst create = f => new Promise(f)\n\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\nconst createEmpty = f => new Promise(f)\n\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template T\n * @param {Array<Promise<T>>} arrp\n * @return {Promise<Array<T>>}\n */\nconst all = arrp => Promise.all(arrp)\n\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\nconst reject = reason => Promise.reject(reason)\n\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\nconst resolve = res => Promise.resolve(res)\n\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\nconst until = (timeout, check, intervalResolution = 10) => create((resolve, reject) => {\n  const startTime = _time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime()\n  const hasTimeout = timeout > 0\n  const untilInterval = () => {\n    if (check()) {\n      clearInterval(intervalHandle)\n      resolve()\n    } else if (hasTimeout) {\n      /* istanbul ignore else */\n      if (_time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime() - startTime > timeout) {\n        clearInterval(intervalHandle)\n        reject(new Error(\'Timeout\'))\n      }\n    }\n  }\n  const intervalHandle = setInterval(untilInterval, intervalResolution)\n})\n\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\nconst wait = timeout => create((resolve, reject) => setTimeout(resolve, timeout))\n\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\nconst isPromise = p => p instanceof Promise || (p && p.then && p.catch && p.finally)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvcHJvbWlzZS5qcz9hYzNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxREFBcUQ7QUFDaEUsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLG9EQUFvRDtBQUMvRCxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUCxvQkFBb0IsaURBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLGlEQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVk7QUFDWjtBQUNPIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvcHJvbWlzZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBoZWxwZXJzIHRvIHdvcmsgd2l0aCBwcm9taXNlcy5cbiAqXG4gKiBAbW9kdWxlIHByb21pc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJy4vdGltZS5qcydcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQGNhbGxiYWNrIFByb21pc2VSZXNvbHZlXG4gKiBAcGFyYW0ge1R8UHJvbWlzZUxpa2U8VD59IFtyZXN1bHRdXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbihQcm9taXNlUmVzb2x2ZTxUPixmdW5jdGlvbihFcnJvcik6dm9pZCk6YW55fSBmXG4gKiBAcmV0dXJuIHtQcm9taXNlPFQ+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gZiA9PiBuZXcgUHJvbWlzZShmKVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZnVuY3Rpb24oKTp2b2lkLGZ1bmN0aW9uKEVycm9yKTp2b2lkKTp2b2lkfSBmXG4gKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRW1wdHkgPSBmID0+IG5ldyBQcm9taXNlKGYpXG5cbi8qKlxuICogYFByb21pc2UuYWxsYCB3YWl0IGZvciBhbGwgcHJvbWlzZXMgaW4gdGhlIGFycmF5IHRvIHJlc29sdmUgYW5kIHJldHVybiB0aGUgcmVzdWx0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheTxQcm9taXNlPFQ+Pn0gYXJycFxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxUPj59XG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSBhcnJwID0+IFByb21pc2UuYWxsKGFycnApXG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gW3JlYXNvbl1cbiAqIEByZXR1cm4ge1Byb21pc2U8bmV2ZXI+fVxuICovXG5leHBvcnQgY29uc3QgcmVqZWN0ID0gcmVhc29uID0+IFByb21pc2UucmVqZWN0KHJlYXNvbilcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfHZvaWR9IHJlc1xuICogQHJldHVybiB7UHJvbWlzZTxUfHZvaWQ+fVxuICovXG5leHBvcnQgY29uc3QgcmVzb2x2ZSA9IHJlcyA9PiBQcm9taXNlLnJlc29sdmUocmVzKVxuXG4vKipcbiAqIEB0b2RvIE5leHQgdmVyc2lvbiwgcmVvcmRlciBwYXJhbWV0ZXJzOiBjaGVjaywgW3RpbWVvdXQsIFtpbnRlcnZhbFJlc29sdXRpb25dXVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6Ym9vbGVhbn0gY2hlY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZXJ2YWxSZXNvbHV0aW9uXVxuICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHVudGlsID0gKHRpbWVvdXQsIGNoZWNrLCBpbnRlcnZhbFJlc29sdXRpb24gPSAxMCkgPT4gY3JlYXRlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gdGltZS5nZXRVbml4VGltZSgpXG4gIGNvbnN0IGhhc1RpbWVvdXQgPSB0aW1lb3V0ID4gMFxuICBjb25zdCB1bnRpbEludGVydmFsID0gKCkgPT4ge1xuICAgIGlmIChjaGVjaygpKSB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChoYXNUaW1lb3V0KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHRpbWUuZ2V0VW5peFRpbWUoKSAtIHN0YXJ0VGltZSA+IHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSlcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCcpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKHVudGlsSW50ZXJ2YWwsIGludGVydmFsUmVzb2x1dGlvbilcbn0pXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAqIEByZXR1cm4ge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHdhaXQgPSB0aW1lb3V0ID0+IGNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpKVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBvYmplY3QgaXMgYSBwcm9taXNlIHVzaW5nIGR1Y2t0eXBpbmcuXG4gKlxuICogUHJvbWlzZXMgYXJlIG9mdGVuIHBvbHlmaWxsZWQsIHNvIGl0IG1ha2VzIHNlbnNlIHRvIGFkZCBzb21lIGFkZGl0aW9uYWwgZ3VhcmFudGVlcyBpZiB0aGUgdXNlciBvZiB0aGlzXG4gKiBsaWJyYXJ5IGhhcyBzb21lIGluc2FuZSBlbnZpcm9ubWVudCB3aGVyZSBnbG9iYWwgUHJvbWlzZSBvYmplY3RzIGFyZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge2FueX0gcFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzUHJvbWlzZSA9IHAgPT4gcCBpbnN0YW5jZW9mIFByb21pc2UgfHwgKHAgJiYgcC50aGVuICYmIHAuY2F0Y2ggJiYgcC5maW5hbGx5KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/promise.js\n')},"../CoCreate-crdt/node_modules/lib0/random.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rand": () => (/* binding */ rand),\n/* harmony export */   "uint32": () => (/* binding */ uint32),\n/* harmony export */   "oneOf": () => (/* binding */ oneOf),\n/* harmony export */   "uuidv4": () => (/* binding */ uuidv4)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "../CoCreate-crdt/node_modules/lib0/math.js");\n/* harmony import */ var _isomorphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isomorphic.js */ "../CoCreate-crdt/node_modules/lib0/isomorphic.js");\n\n/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\n\n\n\nconst rand = Math.random\n\n/* istanbul ignore next */\nconst uint32 = () => new Uint32Array((0,_isomorphic_js__WEBPACK_IMPORTED_MODULE_0__.cryptoRandomBuffer)(4))[0]\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nconst oneOf = arr => arr[_math_js__WEBPACK_IMPORTED_MODULE_1__.floor(rand() * arr.length)]\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11\nconst uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvcmFuZG9tLmpzP2RmZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNtQjs7QUFFN0M7O0FBRVA7QUFDTyxxQ0FBcUMsa0VBQWtCOztBQUU5RDtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNPLHlCQUF5QiwyQ0FBVTs7QUFFMUM7QUFDQTtBQUNPLGtFQUFrRSxPQUFPO0FBQ2hGO0FBQ0EiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9yYW5kb20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogSXNvbW9ycGhpYyBtb2R1bGUgZm9yIHRydWUgcmFuZG9tIG51bWJlcnMgLyBidWZmZXJzIC8gdXVpZHMuXG4gKlxuICogQXR0ZW50aW9uOiBmYWxscyBiYWNrIHRvIE1hdGgucmFuZG9tIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3J5cHRvLlxuICpcbiAqIEBtb2R1bGUgcmFuZG9tXG4gKi9cblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgeyBjcnlwdG9SYW5kb21CdWZmZXIgfSBmcm9tICcuL2lzb21vcnBoaWMuanMnXG5cbmV4cG9ydCBjb25zdCByYW5kID0gTWF0aC5yYW5kb21cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB1aW50MzIgPSAoKSA9PiBuZXcgVWludDMyQXJyYXkoY3J5cHRvUmFuZG9tQnVmZmVyKDQpKVswXVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnJcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBvbmVPZiA9IGFyciA9PiBhcnJbbWF0aC5mbG9vcihyYW5kKCkgKiBhcnIubGVuZ3RoKV1cblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgdXVpZHY0VGVtcGxhdGUgPSBbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExXG5leHBvcnQgY29uc3QgdXVpZHY0ID0gKCkgPT4gdXVpZHY0VGVtcGxhdGUucmVwbGFjZSgvWzAxOF0vZywgLyoqIEBwYXJhbSB7bnVtYmVyfSBjICovIGMgPT5cbiAgKGMgXiB1aW50MzIoKSAmIDE1ID4+IGMgLyA0KS50b1N0cmluZygxNilcbilcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/random.js\n')},"../CoCreate-crdt/node_modules/lib0/set.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "toArray": () => (/* binding */ toArray)\n/* harmony export */ });\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nconst toArray = set => Array.from(set)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvc2V0LmpzP2YwMWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ08iLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9zZXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzZXRzLlxuICpcbiAqIEBtb2R1bGUgc2V0XG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IG5ldyBTZXQoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1NldDxUPn0gc2V0XG4gKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSBzZXQgPT4gQXJyYXkuZnJvbShzZXQpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/set.js\n')},"../CoCreate-crdt/node_modules/lib0/storage.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"varStorage\": () => (/* binding */ varStorage)\n/* harmony export */ });\n/* global localStorage */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   */\n  setItem (key, value) {\n    this.map.set(key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\n\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage\n  }\n} catch (e) { }\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nconst varStorage = _localStorage\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvc3RvcmFnZS5qcz84ZjM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVk7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDTyIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9saWIwL3N0b3JhZ2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgbG9jYWxTdG9yYWdlICovXG5cbi8qKlxuICogSXNvbW9ycGhpYyB2YXJpYWJsZSBzdG9yYWdlLlxuICpcbiAqIFVzZXMgTG9jYWxTdG9yYWdlIGluIHRoZSBicm93c2VyIGFuZCBmYWxscyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlLlxuICpcbiAqIEBtb2R1bGUgc3RvcmFnZVxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jbGFzcyBWYXJTdG9yYWdlUG9seWZpbGwge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgTWFwKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKi9cbiAgc2V0SXRlbSAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMubWFwLnNldChrZXksIHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIGdldEl0ZW0gKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5nZXQoa2V5KVxuICB9XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEB0eXBlIHthbnl9XG4gKi9cbmxldCBfbG9jYWxTdG9yYWdlID0gbmV3IFZhclN0b3JhZ2VQb2x5ZmlsbCgpXG5cbnRyeSB7XG4gIC8vIGlmIHRoZSBzYW1lLW9yaWdpbiBydWxlIGlzIHZpb2xhdGVkLCBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlIG1pZ2h0IHRocm93biBhbiBlcnJvclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfbG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlXG4gIH1cbn0gY2F0Y2ggKGUpIHsgfVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBsb2NhbFN0b3JhZ2UgaW4gYnJvd3Nlciwgb3IgYSBwb2x5ZmlsbCBpbiBub2RlanNcbiAqL1xuZXhwb3J0IGNvbnN0IHZhclN0b3JhZ2UgPSBfbG9jYWxTdG9yYWdlXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/storage.js\n")},"../CoCreate-crdt/node_modules/lib0/string.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromCharCode": () => (/* binding */ fromCharCode),\n/* harmony export */   "fromCodePoint": () => (/* binding */ fromCodePoint),\n/* harmony export */   "trimLeft": () => (/* binding */ trimLeft),\n/* harmony export */   "fromCamelCase": () => (/* binding */ fromCamelCase),\n/* harmony export */   "utf8ByteLength": () => (/* binding */ utf8ByteLength),\n/* harmony export */   "_encodeUtf8Polyfill": () => (/* binding */ _encodeUtf8Polyfill),\n/* harmony export */   "utf8TextEncoder": () => (/* binding */ utf8TextEncoder),\n/* harmony export */   "_encodeUtf8Native": () => (/* binding */ _encodeUtf8Native),\n/* harmony export */   "encodeUtf8": () => (/* binding */ encodeUtf8),\n/* harmony export */   "_decodeUtf8Polyfill": () => (/* binding */ _decodeUtf8Polyfill),\n/* harmony export */   "utf8TextDecoder": () => (/* binding */ utf8TextDecoder),\n/* harmony export */   "_decodeUtf8Native": () => (/* binding */ _decodeUtf8Native),\n/* harmony export */   "decodeUtf8": () => (/* binding */ decodeUtf8)\n/* harmony export */ });\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nconst fromCharCode = String.fromCharCode\nconst fromCodePoint = String.fromCodePoint\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst trimLeft = s => s.replace(trimLeftRegex, \'\')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nconst fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nconst utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* istanbul ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== \'undefined\' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* istanbul ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = \'\'\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* istanbul ignore next */\nlet utf8TextDecoder = typeof TextDecoder === \'undefined\' ? null : new TextDecoder(\'utf-8\', { fatal: true, ignoreBOM: true })\n\n/* istanbul ignore next */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn\'t handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* istanbul ignore next */\n  utf8TextDecoder = null\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* istanbul ignore next */\nconst decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvc3RyaW5nLmpzP2Q3MDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDQTs7QUFFUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ08sMkZBQTJGLFVBQVUsRUFBRSxtQkFBbUI7O0FBRWpJO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDTyxtQ0FBbUMsWUFBWTs7QUFFdEQ7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsSUFBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLDRGQUE0RiwrQkFBK0I7O0FBRWxJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNPLDRDQUE0QyxZQUFZOztBQUUvRDtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNPIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvc3RyaW5nLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggc3RyaW5ncy5cbiAqXG4gKiBAbW9kdWxlIHN0cmluZ1xuICovXG5cbmV4cG9ydCBjb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG5leHBvcnQgY29uc3QgZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdG9Mb3dlckNhc2UgPSBzID0+IHMudG9Mb3dlckNhc2UoKVxuXG5jb25zdCB0cmltTGVmdFJlZ2V4ID0gL15cXHMqL2dcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgdHJpbUxlZnQgPSBzID0+IHMucmVwbGFjZSh0cmltTGVmdFJlZ2V4LCAnJylcblxuY29uc3QgZnJvbUNhbWVsQ2FzZVJlZ2V4ID0gLyhbQS1aXSkvZ1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VwYXJhdG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tQ2FtZWxDYXNlID0gKHMsIHNlcGFyYXRvcikgPT4gdHJpbUxlZnQocy5yZXBsYWNlKGZyb21DYW1lbENhc2VSZWdleCwgbWF0Y2ggPT4gYCR7c2VwYXJhdG9yfSR7dG9Mb3dlckNhc2UobWF0Y2gpfWApKVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHV0ZjhCeXRlTGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCB1dGY4Qnl0ZUxlbmd0aCA9IHN0ciA9PiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkubGVuZ3RoXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IF9lbmNvZGVVdGY4UG9seWZpbGwgPSBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpXG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSlcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdXRmOFRleHRFbmNvZGVyID0gLyoqIEB0eXBlIHtUZXh0RW5jb2Rlcn0gKi8gKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGwpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IF9lbmNvZGVVdGY4TmF0aXZlID0gc3RyID0+IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGUoc3RyKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZW5jb2RlVXRmOCA9IHV0ZjhUZXh0RW5jb2RlciA/IF9lbmNvZGVVdGY4TmF0aXZlIDogX2VuY29kZVV0ZjhQb2x5ZmlsbFxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBfZGVjb2RlVXRmOFBvbHlmaWxsID0gYnVmID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IGJ1Zi5sZW5ndGhcbiAgbGV0IGVuY29kZWRTdHJpbmcgPSAnJ1xuICBsZXQgYnVmUG9zID0gMFxuICB3aGlsZSAocmVtYWluaW5nTGVuID4gMCkge1xuICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwXG4gICAgY29uc3QgYnl0ZXMgPSBidWYuc3ViYXJyYXkoYnVmUG9zLCBidWZQb3MgKyBuZXh0TGVuKVxuICAgIGJ1ZlBvcyArPSBuZXh0TGVuXG4gICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIC8qKiBAdHlwZSB7YW55fSAqLyAoYnl0ZXMpKVxuICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuXG4gIH1cbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgbGV0IHV0ZjhUZXh0RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUsIGlnbm9yZUJPTTogdHJ1ZSB9KVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKHV0ZjhUZXh0RGVjb2RlciAmJiB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSkge1xuICAvLyBTYWZhcmkgZG9lc24ndCBoYW5kbGUgQk9NIGNvcnJlY3RseS5cbiAgLy8gVGhpcyBmaXhlcyBhIGJ1ZyBpbiBTYWZhcmkgMTMuMC41IHdoZXJlIGl0IHByb2R1Y2VzIGEgQk9NIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZC5cbiAgLy8gdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEgb24gdGhlIGZpcnN0IGNhbGwgYW5kXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBzZWNvbmQgY2FsbFxuICAvLyBBbm90aGVyIGlzc3VlIGlzIHRoYXQgZnJvbSB0aGVuIG9uIG5vIEJPTSBjaGFycyBhcmUgcmVjb2duaXplZCBhbnltb3JlXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHV0ZjhUZXh0RGVjb2RlciA9IG51bGxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgX2RlY29kZVV0ZjhOYXRpdmUgPSBidWYgPT4gLyoqIEB0eXBlIHtUZXh0RGVjb2Rlcn0gKi8gKHV0ZjhUZXh0RGVjb2RlcikuZGVjb2RlKGJ1ZilcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVV0ZjggPSB1dGY4VGV4dERlY29kZXIgPyBfZGVjb2RlVXRmOE5hdGl2ZSA6IF9kZWNvZGVVdGY4UG9seWZpbGxcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/string.js\n')},"../CoCreate-crdt/node_modules/lib0/symbol.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "isSymbol": () => (/* binding */ isSymbol)\n/* harmony export */ });\n/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n *\n * @return {Symbol}\n */\nconst create = Symbol\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nconst isSymbol = s => typeof s === \'symbol\'\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvc3ltYm9sLmpzP2I5ZjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsWUFBWTtBQUNaO0FBQ08iLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC9zeW1ib2wuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBFY21hU2NyaXB0IFN5bWJvbHMuXG4gKlxuICogQG1vZHVsZSBzeW1ib2xcbiAqL1xuXG4vKipcbiAqIFJldHVybiBmcmVzaCBzeW1ib2wuXG4gKlxuICogQHJldHVybiB7U3ltYm9sfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gU3ltYm9sXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1N5bWJvbCA9IHMgPT4gdHlwZW9mIHMgPT09ICdzeW1ib2wnXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/symbol.js\n')},"../CoCreate-crdt/node_modules/lib0/time.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getDate\": () => (/* binding */ getDate),\n/* harmony export */   \"getUnixTime\": () => (/* binding */ getUnixTime),\n/* harmony export */   \"humanizeDuration\": () => (/* binding */ humanizeDuration)\n/* harmony export */ });\n/* harmony import */ var _metric_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metric.js */ \"../CoCreate-crdt/node_modules/lib0/metric.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"../CoCreate-crdt/node_modules/lib0/math.js\");\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n\n\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nconst getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10μs.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nconst humanizeDuration = d => {\n  if (d < 60000) {\n    const p = _metric_js__WEBPACK_IMPORTED_MODULE_0__.prefix(d, -1)\n    return _math_js__WEBPACK_IMPORTED_MODULE_1__.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 60) % 60\n  const hours = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 3600) % 24\n  const days = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* istanbul ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvdGltZS5qcz8zNjcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDSjs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQSxjQUFjLDhDQUFhO0FBQzNCLFdBQVcsMkNBQVU7QUFDckI7QUFDQSxNQUFNLDJDQUFVO0FBQ2hCO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCLGdCQUFnQiwyQ0FBVTtBQUMxQixlQUFlLDJDQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy9saWIwL3RpbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCB0aW1lLlxuICpcbiAqIEBtb2R1bGUgdGltZVxuICovXG5cbmltcG9ydCAqIGFzIG1ldHJpYyBmcm9tICcuL21ldHJpYy5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuXG4vKipcbiAqIFJldHVybiBjdXJyZW50IHRpbWUuXG4gKlxuICogQHJldHVybiB7RGF0ZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldERhdGUgPSAoKSA9PiBuZXcgRGF0ZSgpXG5cbi8qKlxuICogUmV0dXJuIGN1cnJlbnQgdW5peCB0aW1lLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVuaXhUaW1lID0gRGF0ZS5ub3dcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGltZSAoaW4gbXMpIHRvIGEgaHVtYW4gcmVhZGFibGUgZm9ybWF0LiBFLmcuIDExMDAgPT4gMS4xcy4gNjBzID0+IDFtaW4uIC4wMDEgPT4gMTDOvHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGh1bWFuaXplZCBhcHByb3hpbWF0aW9uIG9mIHRpbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGh1bWFuaXplRHVyYXRpb24gPSBkID0+IHtcbiAgaWYgKGQgPCA2MDAwMCkge1xuICAgIGNvbnN0IHAgPSBtZXRyaWMucHJlZml4KGQsIC0xKVxuICAgIHJldHVybiBtYXRoLnJvdW5kKHAubiAqIDEwMCkgLyAxMDAgKyBwLnByZWZpeCArICdzJ1xuICB9XG4gIGQgPSBtYXRoLmZsb29yKGQgLyAxMDAwKVxuICBjb25zdCBzZWNvbmRzID0gZCAlIDYwXG4gIGNvbnN0IG1pbnV0ZXMgPSBtYXRoLmZsb29yKGQgLyA2MCkgJSA2MFxuICBjb25zdCBob3VycyA9IG1hdGguZmxvb3IoZCAvIDM2MDApICUgMjRcbiAgY29uc3QgZGF5cyA9IG1hdGguZmxvb3IoZCAvIDg2NDAwKVxuICBpZiAoZGF5cyA+IDApIHtcbiAgICByZXR1cm4gZGF5cyArICdkJyArICgoaG91cnMgPiAwIHx8IG1pbnV0ZXMgPiAzMCkgPyAnICcgKyAobWludXRlcyA+IDMwID8gaG91cnMgKyAxIDogaG91cnMpICsgJ2gnIDogJycpXG4gIH1cbiAgaWYgKGhvdXJzID4gMCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGhvdXJzICsgJ2gnICsgKChtaW51dGVzID4gMCB8fCBzZWNvbmRzID4gMzApID8gJyAnICsgKHNlY29uZHMgPiAzMCA/IG1pbnV0ZXMgKyAxIDogbWludXRlcykgKyAnbWluJyA6ICcnKVxuICB9XG4gIHJldHVybiBtaW51dGVzICsgJ21pbicgKyAoc2Vjb25kcyA+IDAgPyAnICcgKyBzZWNvbmRzICsgJ3MnIDogJycpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/time.js\n")},"../CoCreate-crdt/node_modules/lib0/url.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decodeQueryParams\": () => (/* binding */ decodeQueryParams),\n/* harmony export */   \"encodeQueryParams\": () => (/* binding */ encodeQueryParams)\n/* harmony export */ });\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object.js */ \"../CoCreate-crdt/node_modules/lib0/object.js\");\n/**\n * Utility module to work with urls.\n *\n * @module url\n */\n\n\n\n/**\n * Parse query parameters from an url.\n *\n * @param {string} url\n * @return {Object<string,string>}\n */\nconst decodeQueryParams = url => {\n  /**\n   * @type {Object<string,string>}\n   */\n  const query = {}\n  const urlQuerySplit = url.split('?')\n  const pairs = urlQuerySplit[urlQuerySplit.length - 1].split('&')\n  for (var i = 0; i < pairs.length; i++) {\n    const item = pairs[i]\n    if (item.length > 0) {\n      const pair = item.split('=')\n      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '')\n    }\n  }\n  return query\n}\n\n/**\n * @param {Object<string,string>} params\n * @return {string}\n */\nconst encodeQueryParams = params =>\n  _object_js__WEBPACK_IMPORTED_MODULE_0__.map(params, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join('&')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL2xpYjAvdXJsLmpzPzQzNzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsWUFBWTtBQUNaO0FBQ087QUFDUCxFQUFFLDJDQUFVLDBCQUEwQix3QkFBd0IsR0FBRyx3QkFBd0IiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMvbGliMC91cmwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCB1cmxzLlxuICpcbiAqIEBtb2R1bGUgdXJsXG4gKi9cblxuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJy4vb2JqZWN0LmpzJ1xuXG4vKipcbiAqIFBhcnNlIHF1ZXJ5IHBhcmFtZXRlcnMgZnJvbSBhbiB1cmwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlUXVlcnlQYXJhbXMgPSB1cmwgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsc3RyaW5nPn1cbiAgICovXG4gIGNvbnN0IHF1ZXJ5ID0ge31cbiAgY29uc3QgdXJsUXVlcnlTcGxpdCA9IHVybC5zcGxpdCgnPycpXG4gIGNvbnN0IHBhaXJzID0gdXJsUXVlcnlTcGxpdFt1cmxRdWVyeVNwbGl0Lmxlbmd0aCAtIDFdLnNwbGl0KCcmJylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGl0ZW0gPSBwYWlyc1tpXVxuICAgIGlmIChpdGVtLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBhaXIgPSBpdGVtLnNwbGl0KCc9JylcbiAgICAgIHF1ZXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSB8fCAnJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLHN0cmluZz59IHBhcmFtc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlUXVlcnlQYXJhbXMgPSBwYXJhbXMgPT5cbiAgb2JqZWN0Lm1hcChwYXJhbXMsICh2YWwsIGtleSkgPT4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbCl9YCkuam9pbignJicpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/lib0/url.js\n")},"../CoCreate-crdt/node_modules/y-indexeddb/src/y-indexeddb.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PREFERRED_TRIM_SIZE\": () => (/* binding */ PREFERRED_TRIM_SIZE),\n/* harmony export */   \"fetchUpdates\": () => (/* binding */ fetchUpdates),\n/* harmony export */   \"storeState\": () => (/* binding */ storeState),\n/* harmony export */   \"clearDocument\": () => (/* binding */ clearDocument),\n/* harmony export */   \"IndexeddbPersistence\": () => (/* binding */ IndexeddbPersistence)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"../CoCreate-crdt/node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/indexeddb.js */ \"../CoCreate-crdt/node_modules/lib0/indexeddb.js\");\n/* harmony import */ var lib0_mutex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/mutex.js */ \"../CoCreate-crdt/node_modules/lib0/mutex.js\");\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/observable.js */ \"../CoCreate-crdt/node_modules/lib0/observable.js\");\n\n\n\n\n\nconst customStoreName = 'custom'\nconst updatesStoreName = 'updates'\n\nconst PREFERRED_TRIM_SIZE = 500\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n */\nconst fetchUpdates = idbPersistence => {\n  const [updatesStore] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(/** @type {IDBDatabase} */ (idbPersistence.db), [updatesStoreName]) // , 'readonly')\n  return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.getAll(updatesStore, lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then(updates =>\n    idbPersistence._mux(() =>\n      idbPersistence.doc.transact(() =>\n        updates.forEach(val => yjs__WEBPACK_IMPORTED_MODULE_1__.applyUpdate(idbPersistence.doc, val))\n      )\n    )\n  )\n    .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.getLastKey(updatesStore).then(lastKey => { idbPersistence._dbref = lastKey + 1 }))\n    .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n    .then(() => updatesStore)\n}\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n * @param {boolean} forceStore\n */\nconst storeState = (idbPersistence, forceStore = true) =>\n  fetchUpdates(idbPersistence)\n    .then(updatesStore => {\n      if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {\n        lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.addAutoKey(updatesStore, yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateAsUpdate(idbPersistence.doc))\n          .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.del(updatesStore, lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.createIDBKeyRangeUpperBound(idbPersistence._dbref, true)))\n          .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n      }\n    })\n\n/**\n * @param {string} name\n */\nconst clearDocument = name => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.deleteDB(name)\n\n/**\n * @extends Observable<string>\n */\nclass IndexeddbPersistence extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable {\n  /**\n   * @param {string} name\n   * @param {Y.Doc} doc\n   */\n  constructor (name, doc) {\n    super()\n    this.doc = doc\n    this.name = name\n    this._mux = lib0_mutex_js__WEBPACK_IMPORTED_MODULE_3__.createMutex()\n    this._dbref = 0\n    this._dbsize = 0\n    /**\n     * @type {IDBDatabase|null}\n     */\n    this.db = null\n    this.synced = false\n    this._db = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.openDB(name, db =>\n      lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.createStores(db, [\n        ['updates', { autoIncrement: true }],\n        ['custom']\n      ])\n    )\n    /**\n     * @type {Promise<IndexeddbPersistence>}\n     */\n    this.whenSynced = this._db.then(db => {\n      this.db = db\n      const currState = yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateAsUpdate(doc)\n      return fetchUpdates(this).then(updatesStore => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.addAutoKey(updatesStore, currState)).then(() => {\n        this.emit('synced', [this])\n        this.synced = true\n        return this\n      })\n    })\n    /**\n     * Timeout in ms untill data is merged and persisted in idb.\n     */\n    this._storeTimeout = 1000\n    /**\n     * @type {any}\n     */\n    this._storeTimeoutId = null\n    /**\n     * @param {Uint8Array} update\n     */\n    this._storeUpdate = update =>\n      this._mux(() => {\n        if (this.db) {\n          const [updatesStore] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(/** @type {IDBDatabase} */ (this.db), [updatesStoreName])\n          lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.addAutoKey(updatesStore, update)\n          if (++this._dbsize >= PREFERRED_TRIM_SIZE) {\n            // debounce store call\n            if (this._storeTimeoutId !== null) {\n              clearTimeout(this._storeTimeoutId)\n            }\n            this._storeTimeoutId = setTimeout(() => {\n              storeState(this, false)\n              this._storeTimeoutId = null\n            }, this._storeTimeout)\n          }\n        }\n      })\n    doc.on('update', this._storeUpdate)\n    this.destroy = this.destroy.bind(this)\n    doc.on('destroy', this.destroy)\n  }\n\n  destroy () {\n    if (this._storeTimeoutId) {\n      clearTimeout(this._storeTimeoutId)\n    }\n    this.doc.off('update', this._storeUpdate)\n    this.doc.off('destroy', this.destroy)\n    return this._db.then(db => {\n      db.close()\n    })\n  }\n\n  /**\n   * Destroys this instance and removes all data from indexeddb.\n   *\n   * @return {Promise<void>}\n   */\n  clearData () {\n    return this.destroy().then(() => {\n      lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.deleteDB(this.name)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<String | number | ArrayBuffer | Date | any>}\n   */\n  get (key) {\n    return this._db.then(db => {\n      const [custom] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(db, [customStoreName], 'readonly')\n      return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.get(custom, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @param {String | number | ArrayBuffer | Date} value\n   * @return {Promise<String | number | ArrayBuffer | Date>}\n   */\n  set (key, value) {\n    return this._db.then(db => {\n      const [custom] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(db, [customStoreName])\n      return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.put(custom, value, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<undefined>}\n   */\n  del (key) {\n    return this._db.then(db => {\n      const [custom] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(db, [customStoreName])\n      return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.del(custom, key)\n    })\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL3ktaW5kZXhlZGRiL3NyYy95LWluZGV4ZWRkYi5qcz8zMDg0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNnQjtBQUNGO0FBQ1M7O0FBRS9DO0FBQ0E7O0FBRU87O0FBRVA7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNPO0FBQ1AseUJBQXlCLHVEQUFZLFlBQVksWUFBWTtBQUM3RCxTQUFTLHFEQUFVLGVBQWUsMEVBQStCO0FBQ2pFO0FBQ0E7QUFDQSwrQkFBK0IsNENBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFjLGdDQUFnQyxzQ0FBc0M7QUFDcEcsZ0JBQWdCLG9EQUFTLDRCQUE0QiwrQkFBK0I7QUFDcEY7QUFDQTs7QUFFQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYyxlQUFlLG9EQUFxQjtBQUMxRCxzQkFBc0Isa0RBQU8sZUFBZSwwRUFBK0I7QUFDM0Usc0JBQXNCLG9EQUFTLDRCQUE0QiwrQkFBK0I7QUFDMUY7QUFDQSxLQUFLOztBQUVMO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ08sOEJBQThCLHVEQUFZOztBQUVqRDtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsMERBQVU7QUFDcEQ7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFVO0FBQ3pCLE1BQU0sMkRBQWdCO0FBQ3RCLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFxQjtBQUM3QyxxREFBcUQseURBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1REFBWSxZQUFZLFlBQVk7QUFDckUsVUFBVSx5REFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBWTtBQUNsQixLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLHFDQUFxQztBQUNsRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFZO0FBQ25DLGFBQWEsa0RBQU87QUFDcEIsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsYUFBYSxxQ0FBcUM7QUFDbEQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBWTtBQUNuQyxhQUFhLGtEQUFPO0FBQ3BCLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVk7QUFDbkMsYUFBYSxrREFBTztBQUNwQixLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L25vZGVfbW9kdWxlcy95LWluZGV4ZWRkYi9zcmMveS1pbmRleGVkZGIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCAqIGFzIGlkYiBmcm9tICdsaWIwL2luZGV4ZWRkYi5qcydcbmltcG9ydCAqIGFzIG11dGV4IGZyb20gJ2xpYjAvbXV0ZXguanMnXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlLmpzJ1xuXG5jb25zdCBjdXN0b21TdG9yZU5hbWUgPSAnY3VzdG9tJ1xuY29uc3QgdXBkYXRlc1N0b3JlTmFtZSA9ICd1cGRhdGVzJ1xuXG5leHBvcnQgY29uc3QgUFJFRkVSUkVEX1RSSU1fU0laRSA9IDUwMFxuXG4vKipcbiAqIEBwYXJhbSB7SW5kZXhlZGRiUGVyc2lzdGVuY2V9IGlkYlBlcnNpc3RlbmNlXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaFVwZGF0ZXMgPSBpZGJQZXJzaXN0ZW5jZSA9PiB7XG4gIGNvbnN0IFt1cGRhdGVzU3RvcmVdID0gaWRiLnRyYW5zYWN0KC8qKiBAdHlwZSB7SURCRGF0YWJhc2V9ICovIChpZGJQZXJzaXN0ZW5jZS5kYiksIFt1cGRhdGVzU3RvcmVOYW1lXSkgLy8gLCAncmVhZG9ubHknKVxuICByZXR1cm4gaWRiLmdldEFsbCh1cGRhdGVzU3RvcmUsIGlkYi5jcmVhdGVJREJLZXlSYW5nZUxvd2VyQm91bmQoaWRiUGVyc2lzdGVuY2UuX2RicmVmLCBmYWxzZSkpLnRoZW4odXBkYXRlcyA9PlxuICAgIGlkYlBlcnNpc3RlbmNlLl9tdXgoKCkgPT5cbiAgICAgIGlkYlBlcnNpc3RlbmNlLmRvYy50cmFuc2FjdCgoKSA9PlxuICAgICAgICB1cGRhdGVzLmZvckVhY2godmFsID0+IFkuYXBwbHlVcGRhdGUoaWRiUGVyc2lzdGVuY2UuZG9jLCB2YWwpKVxuICAgICAgKVxuICAgIClcbiAgKVxuICAgIC50aGVuKCgpID0+IGlkYi5nZXRMYXN0S2V5KHVwZGF0ZXNTdG9yZSkudGhlbihsYXN0S2V5ID0+IHsgaWRiUGVyc2lzdGVuY2UuX2RicmVmID0gbGFzdEtleSArIDEgfSkpXG4gICAgLnRoZW4oKCkgPT4gaWRiLmNvdW50KHVwZGF0ZXNTdG9yZSkudGhlbihjbnQgPT4geyBpZGJQZXJzaXN0ZW5jZS5fZGJzaXplID0gY250IH0pKVxuICAgIC50aGVuKCgpID0+IHVwZGF0ZXNTdG9yZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0luZGV4ZWRkYlBlcnNpc3RlbmNlfSBpZGJQZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZVN0b3JlXG4gKi9cbmV4cG9ydCBjb25zdCBzdG9yZVN0YXRlID0gKGlkYlBlcnNpc3RlbmNlLCBmb3JjZVN0b3JlID0gdHJ1ZSkgPT5cbiAgZmV0Y2hVcGRhdGVzKGlkYlBlcnNpc3RlbmNlKVxuICAgIC50aGVuKHVwZGF0ZXNTdG9yZSA9PiB7XG4gICAgICBpZiAoZm9yY2VTdG9yZSB8fCBpZGJQZXJzaXN0ZW5jZS5fZGJzaXplID49IFBSRUZFUlJFRF9UUklNX1NJWkUpIHtcbiAgICAgICAgaWRiLmFkZEF1dG9LZXkodXBkYXRlc1N0b3JlLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoaWRiUGVyc2lzdGVuY2UuZG9jKSlcbiAgICAgICAgICAudGhlbigoKSA9PiBpZGIuZGVsKHVwZGF0ZXNTdG9yZSwgaWRiLmNyZWF0ZUlEQktleVJhbmdlVXBwZXJCb3VuZChpZGJQZXJzaXN0ZW5jZS5fZGJyZWYsIHRydWUpKSlcbiAgICAgICAgICAudGhlbigoKSA9PiBpZGIuY291bnQodXBkYXRlc1N0b3JlKS50aGVuKGNudCA9PiB7IGlkYlBlcnNpc3RlbmNlLl9kYnNpemUgPSBjbnQgfSkpXG4gICAgICB9XG4gICAgfSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgY29uc3QgY2xlYXJEb2N1bWVudCA9IG5hbWUgPT4gaWRiLmRlbGV0ZURCKG5hbWUpXG5cbi8qKlxuICogQGV4dGVuZHMgT2JzZXJ2YWJsZTxzdHJpbmc+XG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkZGJQZXJzaXN0ZW5jZSBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgZG9jKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuX211eCA9IG11dGV4LmNyZWF0ZU11dGV4KClcbiAgICB0aGlzLl9kYnJlZiA9IDBcbiAgICB0aGlzLl9kYnNpemUgPSAwXG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEQkRhdGFiYXNlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kYiA9IG51bGxcbiAgICB0aGlzLnN5bmNlZCA9IGZhbHNlXG4gICAgdGhpcy5fZGIgPSBpZGIub3BlbkRCKG5hbWUsIGRiID0+XG4gICAgICBpZGIuY3JlYXRlU3RvcmVzKGRiLCBbXG4gICAgICAgIFsndXBkYXRlcycsIHsgYXV0b0luY3JlbWVudDogdHJ1ZSB9XSxcbiAgICAgICAgWydjdXN0b20nXVxuICAgICAgXSlcbiAgICApXG4gICAgLyoqXG4gICAgICogQHR5cGUge1Byb21pc2U8SW5kZXhlZGRiUGVyc2lzdGVuY2U+fVxuICAgICAqL1xuICAgIHRoaXMud2hlblN5bmNlZCA9IHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgdGhpcy5kYiA9IGRiXG4gICAgICBjb25zdCBjdXJyU3RhdGUgPSBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jKVxuICAgICAgcmV0dXJuIGZldGNoVXBkYXRlcyh0aGlzKS50aGVuKHVwZGF0ZXNTdG9yZSA9PiBpZGIuYWRkQXV0b0tleSh1cGRhdGVzU3RvcmUsIGN1cnJTdGF0ZSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoJ3N5bmNlZCcsIFt0aGlzXSlcbiAgICAgICAgdGhpcy5zeW5jZWQgPSB0cnVlXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9KVxuICAgIH0pXG4gICAgLyoqXG4gICAgICogVGltZW91dCBpbiBtcyB1bnRpbGwgZGF0YSBpcyBtZXJnZWQgYW5kIHBlcnNpc3RlZCBpbiBpZGIuXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVUaW1lb3V0ID0gMTAwMFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVUaW1lb3V0SWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZVVwZGF0ZSA9IHVwZGF0ZSA9PlxuICAgICAgdGhpcy5fbXV4KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGIpIHtcbiAgICAgICAgICBjb25zdCBbdXBkYXRlc1N0b3JlXSA9IGlkYi50cmFuc2FjdCgvKiogQHR5cGUge0lEQkRhdGFiYXNlfSAqLyAodGhpcy5kYiksIFt1cGRhdGVzU3RvcmVOYW1lXSlcbiAgICAgICAgICBpZGIuYWRkQXV0b0tleSh1cGRhdGVzU3RvcmUsIHVwZGF0ZSlcbiAgICAgICAgICBpZiAoKyt0aGlzLl9kYnNpemUgPj0gUFJFRkVSUkVEX1RSSU1fU0laRSkge1xuICAgICAgICAgICAgLy8gZGVib3VuY2Ugc3RvcmUgY2FsbFxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3JlVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdG9yZVRpbWVvdXRJZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0b3JlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHN0b3JlU3RhdGUodGhpcywgZmFsc2UpXG4gICAgICAgICAgICAgIHRoaXMuX3N0b3JlVGltZW91dElkID0gbnVsbFxuICAgICAgICAgICAgfSwgdGhpcy5fc3RvcmVUaW1lb3V0KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBkb2Mub24oJ3VwZGF0ZScsIHRoaXMuX3N0b3JlVXBkYXRlKVxuICAgIHRoaXMuZGVzdHJveSA9IHRoaXMuZGVzdHJveS5iaW5kKHRoaXMpXG4gICAgZG9jLm9uKCdkZXN0cm95JywgdGhpcy5kZXN0cm95KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcmVUaW1lb3V0SWQpXG4gICAgfVxuICAgIHRoaXMuZG9jLm9mZigndXBkYXRlJywgdGhpcy5fc3RvcmVVcGRhdGUpXG4gICAgdGhpcy5kb2Mub2ZmKCdkZXN0cm95JywgdGhpcy5kZXN0cm95KVxuICAgIHJldHVybiB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIGRiLmNsb3NlKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgaW5zdGFuY2UgYW5kIHJlbW92ZXMgYWxsIGRhdGEgZnJvbSBpbmRleGVkZGIuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBjbGVhckRhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKS50aGVuKCgpID0+IHtcbiAgICAgIGlkYi5kZWxldGVEQih0aGlzLm5hbWUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0ga2V5XG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgYW55Pn1cbiAgICovXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgY29uc3QgW2N1c3RvbV0gPSBpZGIudHJhbnNhY3QoZGIsIFtjdXN0b21TdG9yZU5hbWVdLCAncmVhZG9ubHknKVxuICAgICAgcmV0dXJuIGlkYi5nZXQoY3VzdG9tLCBrZXkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0ga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFN0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZT59XG4gICAqL1xuICBzZXQgKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZGIudGhlbihkYiA9PiB7XG4gICAgICBjb25zdCBbY3VzdG9tXSA9IGlkYi50cmFuc2FjdChkYiwgW2N1c3RvbVN0b3JlTmFtZV0pXG4gICAgICByZXR1cm4gaWRiLnB1dChjdXN0b20sIHZhbHVlLCBrZXkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0ga2V5XG4gICAqIEByZXR1cm4ge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAgICovXG4gIGRlbCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgY29uc3QgW2N1c3RvbV0gPSBpZGIudHJhbnNhY3QoZGIsIFtjdXN0b21TdG9yZU5hbWVdKVxuICAgICAgcmV0dXJuIGlkYi5kZWwoY3VzdG9tLCBrZXkpXG4gICAgfSlcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/y-indexeddb/src/y-indexeddb.js\n")},"../CoCreate-crdt/node_modules/y-protocols/auth.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "messagePermissionDenied": () => (/* binding */ messagePermissionDenied),\n/* harmony export */   "writePermissionDenied": () => (/* binding */ writePermissionDenied),\n/* harmony export */   "readAuthMessage": () => (/* binding */ readAuthMessage)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/encoding.js */ "../CoCreate-crdt/node_modules/lib0/encoding.js");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/decoding.js */ "../CoCreate-crdt/node_modules/lib0/decoding.js");\n\n // eslint-disable-line\n\n\n\nconst messagePermissionDenied = 0\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {string} reason\n */\nconst writePermissionDenied = (encoder, reason) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messagePermissionDenied)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarString(encoder, reason)\n}\n\n/**\n * @callback PermissionDeniedHandler\n * @param {any} y\n * @param {string} reason\n */\n\n/**\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} y\n * @param {PermissionDeniedHandler} permissionDeniedHandler\n */\nconst readAuthMessage = (decoder, y, permissionDeniedHandler) => {\n  switch (lib0_decoding_js__WEBPACK_IMPORTED_MODULE_1__.readVarUint(decoder)) {\n    case messagePermissionDenied: permissionDeniedHandler(y, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_1__.readVarString(decoder))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F1dGguanM/MjllNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDd0I7QUFDb0I7QUFDQTs7QUFFckM7O0FBRVA7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE9BQU87QUFDbEI7QUFDTztBQUNQLEVBQUUsMERBQXFCO0FBQ3ZCLEVBQUUsNERBQXVCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQixXQUFXLHdCQUF3QjtBQUNuQztBQUNPO0FBQ1AsVUFBVSx5REFBb0I7QUFDOUIsNkRBQTZELDJEQUFzQjtBQUNuRjtBQUNBIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F1dGguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nLmpzJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZy5qcydcblxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VQZXJtaXNzaW9uRGVuaWVkID0gMFxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVQZXJtaXNzaW9uRGVuaWVkID0gKGVuY29kZXIsIHJlYXNvbikgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVBlcm1pc3Npb25EZW5pZWQpXG4gIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHJlYXNvbilcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgUGVybWlzc2lvbkRlbmllZEhhbmRsZXJcbiAqIEBwYXJhbSB7YW55fSB5XG4gKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSB5XG4gKiBAcGFyYW0ge1Blcm1pc3Npb25EZW5pZWRIYW5kbGVyfSBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEF1dGhNZXNzYWdlID0gKGRlY29kZXIsIHksIHBlcm1pc3Npb25EZW5pZWRIYW5kbGVyKSA9PiB7XG4gIHN3aXRjaCAoZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikpIHtcbiAgICBjYXNlIG1lc3NhZ2VQZXJtaXNzaW9uRGVuaWVkOiBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcih5LCBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/y-protocols/auth.js\n')},"../CoCreate-crdt/node_modules/y-protocols/awareness.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "outdatedTimeout": () => (/* binding */ outdatedTimeout),\n/* harmony export */   "Awareness": () => (/* binding */ Awareness),\n/* harmony export */   "removeAwarenessStates": () => (/* binding */ removeAwarenessStates),\n/* harmony export */   "encodeAwarenessUpdate": () => (/* binding */ encodeAwarenessUpdate),\n/* harmony export */   "modifyAwarenessUpdate": () => (/* binding */ modifyAwarenessUpdate),\n/* harmony export */   "applyAwarenessUpdate": () => (/* binding */ applyAwarenessUpdate)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding.js */ "../CoCreate-crdt/node_modules/lib0/encoding.js");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding.js */ "../CoCreate-crdt/node_modules/lib0/decoding.js");\n/* harmony import */ var lib0_time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/time.js */ "../CoCreate-crdt/node_modules/lib0/time.js");\n/* harmony import */ var lib0_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/math.js */ "../CoCreate-crdt/node_modules/lib0/math.js");\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable.js */ "../CoCreate-crdt/node_modules/lib0/observable.js");\n/* harmony import */ var lib0_function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/function.js */ "../CoCreate-crdt/node_modules/lib0/function.js");\n/**\n * @module awareness-protocol\n */\n\n\n\n\n\n\n\n // eslint-disable-line\n\nconst outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nclass Awareness extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = setInterval(() => {\n      const now = lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, \'timeout\')\n      }\n    }, lib0_math_js__WEBPACK_IMPORTED_MODULE_2__.floor(outdatedTimeout / 10))\n    doc.on(\'destroy\', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit(\'destroy\', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!lib0_function_js__WEBPACK_IMPORTED_MODULE_3__.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit(\'change\', [{ added, updated: filteredUpdated, removed }, \'local\'])\n    }\n    this.emit(\'update\', [{ added, updated, removed }, \'local\'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      state[field] = value\n      this.setLocalState(state)\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nconst removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit(\'change\', [{ added: [], updated: [], removed }, origin])\n    awareness.emit(\'update\', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nconst encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clientID)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clock)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, JSON.stringify(state))\n  }\n  return lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nconst modifyAwarenessUpdate = (update, modify) => {\n  const decoder = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)\n  const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n  const len = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const clock = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder))\n    const modifiedState = modify(state)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clientID)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clock)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nconst applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)\n  const timestamp = lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    let clock = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!lib0_function_js__WEBPACK_IMPORTED_MODULE_3__.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit(\'change\', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit(\'update\', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F3YXJlbmVzcy5qcz8wZjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFNEM7QUFDQTtBQUNSO0FBQ0E7QUFDVztBQUNWO0FBQ2I7O0FBRWpCOztBQUVQO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrREFBK0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ08sd0JBQXdCLDBEQUFVO0FBQ3pDO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxREFBZ0I7QUFDbEMscUZBQXFGLG9CQUFvQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLCtDQUFVO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQWdCO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsV0FBVywwREFBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQ0FBMkM7QUFDdkU7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsSUFBSTtBQUNmO0FBQ087QUFDUDtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQSx1QkFBdUIscURBQWdCO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRSwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsMkRBQXNCO0FBQ3hDLEVBQUUsMERBQXFCO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDLElBQUksMERBQXFCO0FBQ3pCLElBQUksMERBQXFCO0FBQ3pCLElBQUksNERBQXVCO0FBQzNCO0FBQ0EsU0FBUywwREFBcUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNPO0FBQ1Asa0JBQWtCLDJEQUFzQjtBQUN4QyxrQkFBa0IsMkRBQXNCO0FBQ3hDLGNBQWMseURBQW9CO0FBQ2xDLEVBQUUsMERBQXFCO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCLHFCQUFxQix5REFBb0I7QUFDekMsa0JBQWtCLHlEQUFvQjtBQUN0Qyw2QkFBNkIsMkRBQXNCO0FBQ25EO0FBQ0EsSUFBSSwwREFBcUI7QUFDekIsSUFBSSwwREFBcUI7QUFDekIsSUFBSSw0REFBdUI7QUFDM0I7QUFDQSxTQUFTLDBEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxJQUFJO0FBQ2Y7QUFDTztBQUNQLGtCQUFrQiwyREFBc0I7QUFDeEMsb0JBQW9CLHFEQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseURBQW9CO0FBQ2xDLGlCQUFpQixTQUFTO0FBQzFCLHFCQUFxQix5REFBb0I7QUFDekMsZ0JBQWdCLHlEQUFvQjtBQUNwQyw2QkFBNkIsMkRBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLGFBQWEsMERBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMveS1wcm90b2NvbHMvYXdhcmVuZXNzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGF3YXJlbmVzcy1wcm90b2NvbFxuICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nLmpzJ1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aC5qcydcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUuanMnXG5pbXBvcnQgKiBhcyBmIGZyb20gJ2xpYjAvZnVuY3Rpb24uanMnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5leHBvcnQgY29uc3Qgb3V0ZGF0ZWRUaW1lb3V0ID0gMzAwMDBcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhQ2xpZW50U3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUuY2xvY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUubGFzdFVwZGF0ZWQgdW5peCB0aW1lc3RhbXBcbiAqL1xuXG4vKipcbiAqIFRoZSBBd2FyZW5lc3MgY2xhc3MgaW1wbGVtZW50cyBhIHNpbXBsZSBzaGFyZWQgc3RhdGUgcHJvdG9jb2wgdGhhdCBjYW4gYmUgdXNlZCBmb3Igbm9uLXBlcnNpc3RlbnQgZGF0YSBsaWtlIGF3YXJlbmVzcyBpbmZvcm1hdGlvblxuICogKGN1cnNvciwgdXNlcm5hbWUsIHN0YXR1cywgLi4pLiBFYWNoIGNsaWVudCBjYW4gdXBkYXRlIGl0cyBvd24gbG9jYWwgc3RhdGUgYW5kIGxpc3RlbiB0byBzdGF0ZSBjaGFuZ2VzIG9mXG4gKiByZW1vdGUgY2xpZW50cy4gRXZlcnkgY2xpZW50IG1heSBzZXQgYSBzdGF0ZSBvZiBhIHJlbW90ZSBwZWVyIHRvIGBudWxsYCB0byBtYXJrIHRoZSBjbGllbnQgYXMgb2ZmbGluZS5cbiAqXG4gKiBFYWNoIGNsaWVudCBpcyBpZGVudGlmaWVkIGJ5IGEgdW5pcXVlIGNsaWVudCBpZCAoc29tZXRoaW5nIHdlIGJvcnJvdyBmcm9tIGBkb2MuY2xpZW50SURgKS4gQSBjbGllbnQgY2FuIG92ZXJyaWRlXG4gKiBpdHMgb3duIHN0YXRlIGJ5IHByb3BhZ2F0aW5nIGEgbWVzc2FnZSB3aXRoIGFuIGluY3JlYXNpbmcgdGltZXN0YW1wIChgY2xvY2tgKS4gSWYgc3VjaCBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGl0IGlzXG4gKiBhcHBsaWVkIGlmIHRoZSBrbm93biBzdGF0ZSBvZiB0aGF0IGNsaWVudCBpcyBvbGRlciB0aGFuIHRoZSBuZXcgc3RhdGUgKGBjbG9jayA8IG5ld0Nsb2NrYCkuIElmIGEgY2xpZW50IHRoaW5rcyB0aGF0XG4gKiBhIHJlbW90ZSBjbGllbnQgaXMgb2ZmbGluZSwgaXQgbWF5IHByb3BhZ2F0ZSBhIG1lc3NhZ2Ugd2l0aFxuICogYHsgY2xvY2s6IGN1cnJlbnRDbGllbnRDbG9jaywgc3RhdGU6IG51bGwsIGNsaWVudDogcmVtb3RlQ2xpZW50IH1gLiBJZiBzdWNoIGFcbiAqIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGFuZCB0aGUga25vd24gY2xvY2sgb2YgdGhhdCBjbGllbnQgZXF1YWxzIHRoZSByZWNlaXZlZCBjbG9jaywgaXQgd2lsbCBvdmVycmlkZSB0aGUgc3RhdGUgd2l0aCBgbnVsbGAuXG4gKlxuICogQmVmb3JlIGEgY2xpZW50IGRpc2Nvbm5lY3RzLCBpdCBzaG91bGQgcHJvcGFnYXRlIGEgYG51bGxgIHN0YXRlIHdpdGggYW4gdXBkYXRlZCBjbG9jay5cbiAqXG4gKiBBd2FyZW5lc3Mgc3RhdGVzIG11c3QgYmUgdXBkYXRlZCBldmVyeSAzMCBzZWNvbmRzLiBPdGhlcndpc2UgdGhlIEF3YXJlbmVzcyBpbnN0YW5jZSB3aWxsIGRlbGV0ZSB0aGUgY2xpZW50IHN0YXRlLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPHN0cmluZz59XG4gKi9cbmV4cG9ydCBjbGFzcyBBd2FyZW5lc3MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRJRCA9IGRvYy5jbGllbnRJRFxuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSBjbGllbnQgaWQgdG8gY2xpZW50IHN0YXRlXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE1ldGFDbGllbnRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fY2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgaWYgKHRoaXMuZ2V0TG9jYWxTdGF0ZSgpICE9PSBudWxsICYmIChvdXRkYXRlZFRpbWVvdXQgLyAyIDw9IG5vdyAtIC8qKiBAdHlwZSB7e2xhc3RVcGRhdGVkOm51bWJlcn19ICovICh0aGlzLm1ldGEuZ2V0KHRoaXMuY2xpZW50SUQpKS5sYXN0VXBkYXRlZCkpIHtcbiAgICAgICAgLy8gcmVuZXcgbG9jYWwgY2xvY2tcbiAgICAgICAgdGhpcy5zZXRMb2NhbFN0YXRlKHRoaXMuZ2V0TG9jYWxTdGF0ZSgpKVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgcmVtb3ZlID0gW11cbiAgICAgIHRoaXMubWV0YS5mb3JFYWNoKChtZXRhLCBjbGllbnRpZCkgPT4ge1xuICAgICAgICBpZiAoY2xpZW50aWQgIT09IHRoaXMuY2xpZW50SUQgJiYgb3V0ZGF0ZWRUaW1lb3V0IDw9IG5vdyAtIG1ldGEubGFzdFVwZGF0ZWQgJiYgdGhpcy5zdGF0ZXMuaGFzKGNsaWVudGlkKSkge1xuICAgICAgICAgIHJlbW92ZS5wdXNoKGNsaWVudGlkKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYgKHJlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLCByZW1vdmUsICd0aW1lb3V0JylcbiAgICAgIH1cbiAgICB9LCBtYXRoLmZsb29yKG91dGRhdGVkVGltZW91dCAvIDEwKSlcbiAgICBkb2Mub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKVxuICAgIH0pXG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKHt9KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKVxuICAgIHRoaXMuc2V0TG9jYWxTdGF0ZShudWxsKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH1cbiAgICovXG4gIGdldExvY2FsU3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlcy5nZXQodGhpcy5jbGllbnRJRCkgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fG51bGx9IHN0YXRlXG4gICAqL1xuICBzZXRMb2NhbFN0YXRlIChzdGF0ZSkge1xuICAgIGNvbnN0IGNsaWVudElEID0gdGhpcy5jbGllbnRJRFxuICAgIGNvbnN0IGN1cnJMb2NhbE1ldGEgPSB0aGlzLm1ldGEuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IGNsb2NrID0gY3VyckxvY2FsTWV0YSA9PT0gdW5kZWZpbmVkID8gMCA6IGN1cnJMb2NhbE1ldGEuY2xvY2sgKyAxXG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5zdGF0ZXMuZ2V0KGNsaWVudElEKVxuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKVxuICAgIH1cbiAgICB0aGlzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICBjbG9jayxcbiAgICAgIGxhc3RVcGRhdGVkOiB0aW1lLmdldFVuaXhUaW1lKClcbiAgICB9KVxuICAgIGNvbnN0IGFkZGVkID0gW11cbiAgICBjb25zdCB1cGRhdGVkID0gW11cbiAgICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXVxuICAgIGNvbnN0IHJlbW92ZWQgPSBbXVxuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgIH0gZWxzZSBpZiAocHJldlN0YXRlID09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIGlmICghZi5lcXVhbGl0eURlZXAocHJldlN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCBbeyBhZGRlZCwgdXBkYXRlZDogZmlsdGVyZWRVcGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKVxuICAgIH1cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIFt7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIHNldExvY2FsU3RhdGVGaWVsZCAoZmllbGQsIHZhbHVlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldExvY2FsU3RhdGUoKVxuICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgc3RhdGVbZmllbGRdID0gdmFsdWVcbiAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZShzdGF0ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TWFwPG51bWJlcixPYmplY3Q8c3RyaW5nLGFueT4+fVxuICAgKi9cbiAgZ2V0U3RhdGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNcbiAgfVxufVxuXG4vKipcbiAqIE1hcmsgKHJlbW90ZSkgY2xpZW50cyBhcyBpbmFjdGl2ZSBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgcGVlcnMuXG4gKiBUaGlzIGNoYW5nZSB3aWxsIGJlIHByb3BhZ2F0ZWQgdG8gcmVtb3RlIGNsaWVudHMuXG4gKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbGllbnRzXG4gKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVBd2FyZW5lc3NTdGF0ZXMgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2xpZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gY2xpZW50c1tpXVxuICAgIGlmIChhd2FyZW5lc3Muc3RhdGVzLmhhcyhjbGllbnRJRCkpIHtcbiAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgICAgaWYgKGNsaWVudElEID09PSBhd2FyZW5lc3MuY2xpZW50SUQpIHtcbiAgICAgICAgY29uc3QgY3VyTWV0YSA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSlcbiAgICAgICAgYXdhcmVuZXNzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICAgICAgY2xvY2s6IGN1ck1ldGEuY2xvY2sgKyAxLFxuICAgICAgICAgIGxhc3RVcGRhdGVkOiB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRClcbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCdjaGFuZ2UnLCBbeyBhZGRlZDogW10sIHVwZGF0ZWQ6IFtdLCByZW1vdmVkIH0sIG9yaWdpbl0pXG4gICAgYXdhcmVuZXNzLmVtaXQoJ3VwZGF0ZScsIFt7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQgfSwgb3JpZ2luXSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZUF3YXJlbmVzc1VwZGF0ZSA9IChhd2FyZW5lc3MsIGNsaWVudHMsIHN0YXRlcyA9IGF3YXJlbmVzcy5zdGF0ZXMpID0+IHtcbiAgY29uc3QgbGVuID0gY2xpZW50cy5sZW5ndGhcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBjbGllbnRzW2ldXG4gICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXMuZ2V0KGNsaWVudElEKSB8fCBudWxsXG4gICAgY29uc3QgY2xvY2sgPSAvKiogQHR5cGUge01ldGFDbGllbnRTdGF0ZX0gKi8gKGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCkpLmNsb2NrXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsaWVudElEKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbG9jaylcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpXG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIE1vZGlmeSB0aGUgY29udGVudCBvZiBhbiBhd2FyZW5lc3MgdXBkYXRlIGJlZm9yZSByZS1lbmNvZGluZyBpdCB0byBhbiBhd2FyZW5lc3MgdXBkYXRlLlxuICpcbiAqIFRoaXMgbWlnaHQgYmUgdXNlZnVsIHdoZW4geW91IGhhdmUgYSBjZW50cmFsIHNlcnZlciB0aGF0IHdhbnRzIHRvIGVuc3VyZSB0aGF0IGNsaWVudHNcbiAqIGNhbnQgaGlqYWNrIHNvbWVib2R5IGVsc2VzIGlkZW50aXR5LlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSk6YW55fSBtb2RpZnlcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBtb2RpZnlBd2FyZW5lc3NVcGRhdGUgPSAodXBkYXRlLCBtb2RpZnkpID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKVxuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3QgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpKVxuICAgIGNvbnN0IG1vZGlmaWVkU3RhdGUgPSBtb2RpZnkoc3RhdGUpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsaWVudElEKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbG9jaylcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBKU09OLnN0cmluZ2lmeShtb2RpZmllZFN0YXRlKSlcbiAgfVxuICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbWl0dGVkIGNoYW5nZSBldmVudFxuICovXG5leHBvcnQgY29uc3QgYXBwbHlBd2FyZW5lc3NVcGRhdGUgPSAoYXdhcmVuZXNzLCB1cGRhdGUsIG9yaWdpbikgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpXG4gIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICBjb25zdCBhZGRlZCA9IFtdXG4gIGNvbnN0IHVwZGF0ZWQgPSBbXVxuICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXVxuICBjb25zdCByZW1vdmVkID0gW11cbiAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBsZXQgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpKVxuICAgIGNvbnN0IGNsaWVudE1ldGEgPSBhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpXG4gICAgY29uc3QgcHJldlN0YXRlID0gYXdhcmVuZXNzLnN0YXRlcy5nZXQoY2xpZW50SUQpXG4gICAgY29uc3QgY3VyckNsb2NrID0gY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkID8gMCA6IGNsaWVudE1ldGEuY2xvY2tcbiAgICBpZiAoY3VyckNsb2NrIDwgY2xvY2sgfHwgKGN1cnJDbG9jayA9PT0gY2xvY2sgJiYgc3RhdGUgPT09IG51bGwgJiYgYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSkge1xuICAgICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIG5ldmVyIGxldCBhIHJlbW90ZSBjbGllbnQgcmVtb3ZlIHRoaXMgbG9jYWwgc3RhdGVcbiAgICAgICAgaWYgKGNsaWVudElEID09PSBhd2FyZW5lc3MuY2xpZW50SUQgJiYgYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gcmVtb3RlIGNsaWVudCByZW1vdmVkIHRoZSBsb2NhbCBzdGF0ZS4gRG8gbm90IHJlbW90ZSBzdGF0ZS4gQnJvYWRjYXN0IGEgbWVzc2FnZSBpbmRpY2F0aW5nXG4gICAgICAgICAgLy8gdGhhdCB0aGlzIGNsaWVudCBzdGlsbCBleGlzdHMgYnkgaW5jcmVhc2luZyB0aGUgY2xvY2tcbiAgICAgICAgICBjbG9jaysrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhcmVuZXNzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuc2V0KGNsaWVudElELCBzdGF0ZSlcbiAgICAgIH1cbiAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICBjbG9jayxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWVzdGFtcFxuICAgICAgfSlcbiAgICAgIGlmIChjbGllbnRNZXRhID09PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWRkZWQucHVzaChjbGllbnRJRClcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50TWV0YSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlID09PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRClcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFmLmVxdWFsaXR5RGVlcChzdGF0ZSwgcHJldlN0YXRlKSkge1xuICAgICAgICAgIGZpbHRlcmVkVXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ2NoYW5nZScsIFt7XG4gICAgICBhZGRlZCwgdXBkYXRlZDogZmlsdGVyZWRVcGRhdGVkLCByZW1vdmVkXG4gICAgfSwgb3JpZ2luXSlcbiAgfVxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCB1cGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ3VwZGF0ZScsIFt7XG4gICAgICBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZFxuICAgIH0sIG9yaWdpbl0pXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/y-protocols/awareness.js\n')},"../CoCreate-crdt/node_modules/y-protocols/sync.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "messageYjsSyncStep1": () => (/* binding */ messageYjsSyncStep1),\n/* harmony export */   "messageYjsSyncStep2": () => (/* binding */ messageYjsSyncStep2),\n/* harmony export */   "messageYjsUpdate": () => (/* binding */ messageYjsUpdate),\n/* harmony export */   "writeSyncStep1": () => (/* binding */ writeSyncStep1),\n/* harmony export */   "writeSyncStep2": () => (/* binding */ writeSyncStep2),\n/* harmony export */   "readSyncStep1": () => (/* binding */ readSyncStep1),\n/* harmony export */   "readSyncStep2": () => (/* binding */ readSyncStep2),\n/* harmony export */   "writeUpdate": () => (/* binding */ writeUpdate),\n/* harmony export */   "readUpdate": () => (/* binding */ readUpdate),\n/* harmony export */   "readSyncMessage": () => (/* binding */ readSyncMessage)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/encoding.js */ "../CoCreate-crdt/node_modules/lib0/encoding.js");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/decoding.js */ "../CoCreate-crdt/node_modules/lib0/decoding.js");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ "../CoCreate-crdt/node_modules/yjs/dist/yjs.mjs");\n/**\n * @module sync-protocol\n */\n\n\n\n\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nconst messageYjsSyncStep1 = 0\nconst messageYjsSyncStep2 = 1\nconst messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nconst writeSyncStep1 = (encoder, doc) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateVector(doc)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nconst writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messageYjsSyncStep2)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint8Array(encoder, yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nconst readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  yjs__WEBPACK_IMPORTED_MODULE_1__.applyUpdate(doc, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder), transactionOrigin)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nconst writeUpdate = (encoder, update) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messageYjsUpdate)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error(\'Unknown message type\')\n  }\n  return messageType\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL3N5bmMuanM/NmVmYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUU0QztBQUNBO0FBQ3BCOztBQUV4QjtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxNQUFNO0FBQ2pCO0FBQ087QUFDUCxFQUFFLDBEQUFxQjtBQUN2QixhQUFhLGtEQUFtQjtBQUNoQyxFQUFFLGdFQUEyQjtBQUM3Qjs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQixXQUFXLFdBQVc7QUFDdEI7QUFDTztBQUNQLEVBQUUsMERBQXFCO0FBQ3ZCLEVBQUUsZ0VBQTJCLFVBQVUsb0RBQXFCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQjtBQUNPO0FBQ1AsK0JBQStCLCtEQUEwQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsSUFBSTtBQUNmO0FBQ087QUFDUCxFQUFFLDRDQUFhLE1BQU0sK0RBQTBCO0FBQy9DOztBQUVBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxXQUFXO0FBQ3RCO0FBQ087QUFDUCxFQUFFLDBEQUFxQjtBQUN2QixFQUFFLGdFQUEyQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE1BQU07QUFDakIsV0FBVyxJQUFJO0FBQ2Y7QUFDTzs7QUFFUDtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQixXQUFXLElBQUk7QUFDZjtBQUNPO0FBQ1Asc0JBQXNCLHlEQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMveS1wcm90b2NvbHMvc3luYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBzeW5jLXByb3RvY29sXG4gKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZy5qcydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7TWFwPG51bWJlciwgbnVtYmVyPn0gU3RhdGVNYXBcbiAqL1xuXG4vKipcbiAqIENvcmUgWWpzIGRlZmluZXMgdHdvIG1lc3NhZ2UgdHlwZXM6XG4gKiDigKIgWWpzU3luY1N0ZXAxOiBJbmNsdWRlcyB0aGUgU3RhdGUgU2V0IG9mIHRoZSBzZW5kaW5nIGNsaWVudC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBzaG91bGQgcmVwbHkgd2l0aCBZanNTeW5jU3RlcDIuXG4gKiDigKIgWWpzU3luY1N0ZXAyOiBJbmNsdWRlcyBhbGwgbWlzc2luZyBzdHJ1Y3RzIGFuZCB0aGUgY29tcGxldGUgZGVsZXRlIHNldC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBpcyBhc3N1cmVkIHRoYXQgaXRcbiAqICAgcmVjZWl2ZWQgYWxsIGluZm9ybWF0aW9uIGZyb20gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBwZWVyLXRvLXBlZXIgbmV0d29yaywgeW91IG1heSB3YW50IHRvIGludHJvZHVjZSBhIFN5bmNEb25lIG1lc3NhZ2UgdHlwZS4gQm90aCBwYXJ0aWVzIHNob3VsZCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvblxuICogd2l0aCBTeW5jU3RlcDEuIFdoZW4gYSBjbGllbnQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jRG9uZS4gV2hlbiB0aGUgbG9jYWwgY2xpZW50IHJlY2VpdmVkIGJvdGhcbiAqIFN5bmNTdGVwMiBhbmQgU3luY0RvbmUsIGl0IGlzIGFzc3VyZWQgdGhhdCBpdCBpcyBzeW5jZWQgdG8gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBjbGllbnQtc2VydmVyIG1vZGVsLCB5b3Ugd2FudCB0byBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseTogVGhlIGNsaWVudCBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb24gd2l0aCBTeW5jU3RlcDEuXG4gKiBXaGVuIHRoZSBzZXJ2ZXIgcmVjZWl2ZXMgU3luY1N0ZXAxLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jU3RlcDIgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgU3luY1N0ZXAxLiBUaGUgY2xpZW50IHJlcGxpZXNcbiAqIHdpdGggU3luY1N0ZXAyIHdoZW4gaXQgcmVjZWl2ZXMgU3luY1N0ZXAxLiBPcHRpb25hbGx5IHRoZSBzZXJ2ZXIgbWF5IHNlbmQgYSBTeW5jRG9uZSBhZnRlciBpdCByZWNlaXZlZCBTeW5jU3RlcDIsIHNvIHRoZVxuICogY2xpZW50IGtub3dzIHRoYXQgdGhlIHN5bmMgaXMgZmluaXNoZWQuICBUaGVyZSBhcmUgdHdvIHJlYXNvbnMgZm9yIHRoaXMgbW9yZSBlbGFib3JhdGVkIHN5bmMgbW9kZWw6IDEuIFRoaXMgcHJvdG9jb2wgY2FuXG4gKiBlYXNpbHkgYmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mIGh0dHAgYW5kIHdlYnNvY2tldHMuIDIuIFRoZSBzZXJ2ZXIgc2hvdWwgb25seSByZXBseSB0byByZXF1ZXN0cywgYW5kIG5vdCBpbml0aWF0ZSB0aGVtLlxuICogVGhlcmVmb3JlIGl0IGlzIG5lY2VzYXJyeSB0aGF0IHRoZSBjbGllbnQgaW5pdGlhdGVzIHRoZSBzeW5jLlxuICpcbiAqIENvbnN0cnVjdGlvbiBvZiBhIG1lc3NhZ2U6XG4gKiBbbWVzc2FnZVR5cGUgOiB2YXJVaW50LCBtZXNzYWdlIGRlZmluaXRpb24uLl1cbiAqXG4gKiBOb3RlOiBBIG1lc3NhZ2UgZG9lcyBub3QgaW5jbHVkZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vbSBuYW1lLiBUaGlzIG11c3QgdG8gYmUgaGFuZGxlZCBieSB0aGUgdXBwZXIgbGF5ZXIgcHJvdG9jb2whXG4gKlxuICogc3RyaW5naWZ5W21lc3NhZ2VUeXBlXSBzdHJpbmdpZmllcyBhIG1lc3NhZ2UgZGVmaW5pdGlvbiAobWVzc2FnZVR5cGUgaXMgYWxyZWFkeSByZWFkIGZyb20gdGhlIGJ1ZmZmZXIpXG4gKi9cblxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDEgPSAwXG5leHBvcnQgY29uc3QgbWVzc2FnZVlqc1N5bmNTdGVwMiA9IDFcbmV4cG9ydCBjb25zdCBtZXNzYWdlWWpzVXBkYXRlID0gMlxuXG4vKipcbiAqIENyZWF0ZSBhIHN5bmMgc3RlcCAxIG1lc3NhZ2UgYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IHNoYXJlZCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICovXG5leHBvcnQgY29uc3Qgd3JpdGVTeW5jU3RlcDEgPSAoZW5jb2RlciwgZG9jKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAxKVxuICBjb25zdCBzdiA9IFkuZW5jb2RlU3RhdGVWZWN0b3IoZG9jKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2Rlciwgc3YpXG59XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRTdGF0ZVZlY3Rvcl1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlU3luY1N0ZXAyID0gKGVuY29kZXIsIGRvYywgZW5jb2RlZFN0YXRlVmVjdG9yKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAyKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYywgZW5jb2RlZFN0YXRlVmVjdG9yKSlcbn1cblxuLyoqXG4gKiBSZWFkIFN5bmNTdGVwMSBtZXNzYWdlIGFuZCByZXBseSB3aXRoIFN5bmNTdGVwMi5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgVGhlIHJlcGx5IHRvIHRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICovXG5leHBvcnQgY29uc3QgcmVhZFN5bmNTdGVwMSA9IChkZWNvZGVyLCBlbmNvZGVyLCBkb2MpID0+XG4gIHdyaXRlU3luY1N0ZXAyKGVuY29kZXIsIGRvYywgZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpXG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVhZFN5bmNTdGVwMiA9IChkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiB7XG4gIFkuYXBwbHlVcGRhdGUoZG9jLCBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgdHJhbnNhY3Rpb25PcmlnaW4pXG59XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVcGRhdGUgPSAoZW5jb2RlciwgdXBkYXRlKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzVXBkYXRlKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdXBkYXRlKVxufVxuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IFN0cnVjdHMgYW5kIHRoZW4gRGVsZXRlU3RvcmUgdG8gYSB5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVcGRhdGUgPSByZWFkU3luY1N0ZXAyXG5cbi8qKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyIEEgbWVzc2FnZSByZWNlaXZlZCBmcm9tIGFub3RoZXIgY2xpZW50XG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlcGx5IG1lc3NhZ2UuIFdpbGwgbm90IGJlIHNlbnQgaWYgZW1wdHkuXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVhZFN5bmNNZXNzYWdlID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBzd2l0Y2ggKG1lc3NhZ2VUeXBlKSB7XG4gICAgY2FzZSBtZXNzYWdlWWpzU3luY1N0ZXAxOlxuICAgICAgcmVhZFN5bmNTdGVwMShkZWNvZGVyLCBlbmNvZGVyLCBkb2MpXG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZVlqc1N5bmNTdGVwMjpcbiAgICAgIHJlYWRTeW5jU3RlcDIoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzVXBkYXRlOlxuICAgICAgcmVhZFVwZGF0ZShkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgdHlwZScpXG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VUeXBlXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/y-protocols/sync.js\n')},"../CoCreate-crdt/node_modules/y-websocket/src/y-websocket.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebsocketProvider\": () => (/* binding */ WebsocketProvider)\n/* harmony export */ });\n/* harmony import */ var lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/broadcastchannel.js */ \"../CoCreate-crdt/node_modules/lib0/broadcastchannel.js\");\n/* harmony import */ var lib0_time_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/time.js */ \"../CoCreate-crdt/node_modules/lib0/time.js\");\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding.js */ \"../CoCreate-crdt/node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/decoding.js */ \"../CoCreate-crdt/node_modules/lib0/decoding.js\");\n/* harmony import */ var y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/sync.js */ \"../CoCreate-crdt/node_modules/y-protocols/sync.js\");\n/* harmony import */ var y_protocols_auth_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-protocols/auth.js */ \"../CoCreate-crdt/node_modules/y-protocols/auth.js\");\n/* harmony import */ var y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/awareness.js */ \"../CoCreate-crdt/node_modules/y-protocols/awareness.js\");\n/* harmony import */ var lib0_mutex_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/mutex.js */ \"../CoCreate-crdt/node_modules/lib0/mutex.js\");\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/observable.js */ \"../CoCreate-crdt/node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/math.js */ \"../CoCreate-crdt/node_modules/lib0/math.js\");\n/* harmony import */ var lib0_url_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/url.js */ \"../CoCreate-crdt/node_modules/lib0/url.js\");\n/*\nUnlike stated in the LICENSE file, it is not necessary to include the copyright notice and permission notice when you copy code from this file.\n*/\n\n/**\n * @module provider/websocket\n */\n\n/* eslint-env browser */\n\n // eslint-disable-line\n\n\n\n\n\n\n\n\n\n\n\n\nconst messageSync = 0\nconst messageQueryAwareness = 3\nconst messageAwareness = 1\nconst messageAuth = 2\n\nconst reconnectTimeoutBase = 1200\nconst maxReconnectTimeout = 2500\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000\n\n/**\n * @param {WebsocketProvider} provider\n * @param {string} reason\n */\nconst permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.\\n${reason}`)\n\n/**\n * @param {WebsocketProvider} provider\n * @param {Uint8Array} buf\n * @param {boolean} emitSynced\n * @return {encoding.Encoder}\n */\nconst readMessage = (provider, buf, emitSynced) => {\n  const decoder = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_3__.createDecoder(buf)\n  const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n  const messageType = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_3__.readVarUint(decoder)\n  switch (messageType) {\n    case messageSync: {\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)\n      const syncMessageType = y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.readSyncMessage(decoder, encoder, provider.doc, provider)\n      if (emitSynced && syncMessageType === y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.messageYjsSyncStep2 && !provider.synced) {\n        provider.synced = true\n      }\n      break\n    }\n    case messageQueryAwareness:\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageAwareness)\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())))\n      break\n    case messageAwareness:\n      y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.applyAwarenessUpdate(provider.awareness, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_3__.readVarUint8Array(decoder), provider)\n      break\n    case messageAuth:\n      y_protocols_auth_js__WEBPACK_IMPORTED_MODULE_1__.readAuthMessage(decoder, provider.doc, permissionDeniedHandler)\n      break\n    default:\n      console.error('Unable to compute message')\n      return encoder\n  }\n  return encoder\n}\n\n/**\n * @param {WebsocketProvider} provider\n */\nconst setupWS = provider => {\n  if (provider.shouldConnect && provider.ws === null) {\n    const websocket = new provider._WS(provider.url)\n    websocket.binaryType = 'arraybuffer'\n    provider.ws = websocket\n    provider.wsconnecting = true\n    provider.wsconnected = false\n    provider.synced = false\n\n    websocket.onmessage = event => {\n      provider.wsLastMessageReceived = lib0_time_js__WEBPACK_IMPORTED_MODULE_5__.getUnixTime()\n      const encoder = readMessage(provider, new Uint8Array(event.data), true)\n      if (lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.length(encoder) > 1) {\n        websocket.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))\n      }\n    }\n    websocket.onclose = () => {\n      provider.ws = null\n      provider.wsconnecting = false\n      if (provider.wsconnected) {\n        provider.wsconnected = false\n        provider.synced = false\n        // update awareness (all users except local left)\n        y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter(client => client !== provider.doc.clientID), provider)\n        provider.emit('status', [{\n          status: 'disconnected'\n        }])\n      } else {\n        provider.wsUnsuccessfulReconnects++\n      }\n      // Start with no reconnect timeout and increase timeout by\n      // log10(wsUnsuccessfulReconnects).\n      // The idea is to increase reconnect timeout slowly and have no reconnect\n      // timeout at the beginning (log(1) = 0)\n      setTimeout(setupWS, lib0_math_js__WEBPACK_IMPORTED_MODULE_6__.min(lib0_math_js__WEBPACK_IMPORTED_MODULE_6__.log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider)\n    }\n    websocket.onopen = () => {\n      provider.wsLastMessageReceived = lib0_time_js__WEBPACK_IMPORTED_MODULE_5__.getUnixTime()\n      provider.wsconnecting = false\n      provider.wsconnected = true\n      provider.wsUnsuccessfulReconnects = 0\n      provider.emit('status', [{\n        status: 'connected'\n      }])\n      // always send sync step 1 when connected\n      const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)\n      y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep1(encoder, provider.doc)\n      websocket.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))\n      // broadcast local awareness state\n      if (provider.awareness.getLocalState() !== null) {\n        const encoderAwarenessState = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n        lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderAwarenessState, messageAwareness)\n        lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID]))\n        websocket.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderAwarenessState))\n      }\n    }\n\n    provider.emit('status', [{\n      status: 'connecting'\n    }])\n  }\n}\n\n/**\n * @param {WebsocketProvider} provider\n * @param {ArrayBuffer} buf\n */\nconst broadcastMessage = (provider, buf) => {\n  if (provider.wsconnected) {\n    // @ts-ignore We know that wsconnected = true\n    provider.ws.send(buf)\n  }\n  if (provider.bcconnected) {\n    provider.mux(() => {\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(provider.bcChannel, buf)\n    })\n  }\n}\n\n/**\n * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.\n * The document name is attached to the provided url. I.e. the following example\n * creates a websocket connection to http://localhost:1234/my-document-name\n *\n * @example\n *   import * as Y from 'yjs'\n *   import { WebsocketProvider } from 'y-websocket'\n *   const doc = new Y.Doc()\n *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)\n *\n * @extends {Observable<string>}\n */\nclass WebsocketProvider extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_8__.Observable {\n  /**\n   * @param {string} serverUrl\n   * @param {string} roomname\n   * @param {Y.Doc} doc\n   * @param {object} [opts]\n   * @param {boolean} [opts.connect]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {Object<string,string>} [opts.params]\n   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill\n   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds\n   */\n  constructor (serverUrl, roomname, doc, { connect = true, awareness = new y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.Awareness(doc), params = {}, WebSocketPolyfill = WebSocket, resyncInterval = -1 } = {}) {\n    super()\n    // ensure that url is always ends with /\n    while (serverUrl[serverUrl.length - 1] === '/') {\n      serverUrl = serverUrl.slice(0, serverUrl.length - 1)\n    }\n    const encodedParams = lib0_url_js__WEBPACK_IMPORTED_MODULE_9__.encodeQueryParams(params)\n    this.bcChannel = serverUrl + '/' + roomname\n    this.url = serverUrl + '/' + roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams)\n    this.roomname = roomname\n    this.doc = doc\n    this._WS = WebSocketPolyfill\n    this.awareness = awareness\n    this.wsconnected = false\n    this.wsconnecting = false\n    this.bcconnected = false\n    this.wsUnsuccessfulReconnects = 0\n    this.mux = lib0_mutex_js__WEBPACK_IMPORTED_MODULE_10__.createMutex()\n    /**\n     * @type {boolean}\n     */\n    this._synced = false\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null\n    this.wsLastMessageReceived = 0\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = connect\n\n    /**\n     * @type {NodeJS.Timeout | number}\n     */\n    this._resyncInterval = 0\n    if (resyncInterval > 0) {\n      this._resyncInterval = setInterval(() => {\n        if (this.ws) {\n          // resend sync step 1\n          const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n          lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)\n          y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep1(encoder, doc)\n          this.ws.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))\n        }\n      }, resyncInterval)\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     */\n    this._bcSubscriber = data => {\n      this.mux(() => {\n        const encoder = readMessage(this, new Uint8Array(data), false)\n        if (lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.length(encoder) > 1) {\n          lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))\n        }\n      })\n    }\n    /**\n     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._updateHandler = (update, origin) => {\n      if (origin !== this || origin === null) {\n        const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n        lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)\n        y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeUpdate(encoder, update)\n        broadcastMessage(this, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))\n      }\n    }\n    this.doc.on('update', this._updateHandler)\n    /**\n     * @param {any} changed\n     * @param {any} origin\n     */\n    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {\n      const changedClients = added.concat(updated).concat(removed)\n      const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageAwareness)\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(awareness, changedClients))\n      broadcastMessage(this, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))\n    }\n    window.addEventListener('beforeunload', () => {\n      y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload')\n    })\n    awareness.on('update', this._awarenessUpdateHandler)\n    this._checkInterval = setInterval(() => {\n      if (this.wsconnected && messageReconnectTimeout < lib0_time_js__WEBPACK_IMPORTED_MODULE_5__.getUnixTime() - this.wsLastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */ (this.ws).close()\n      }\n    }, messageReconnectTimeout / 10)\n    if (connect) {\n      this.connect()\n    }\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get synced () {\n    return this._synced\n  }\n\n  set synced (state) {\n    if (this._synced !== state) {\n      this._synced = state\n      this.emit('synced', [state])\n      this.emit('sync', [state])\n    }\n  }\n\n  destroy () {\n    if (this._resyncInterval !== 0) {\n      clearInterval(/** @type {NodeJS.Timeout} */ (this._resyncInterval))\n    }\n    clearInterval(this._checkInterval)\n    this.disconnect()\n    this.awareness.off('update', this._awarenessUpdateHandler)\n    this.doc.off('update', this._updateHandler)\n    super.destroy()\n  }\n\n  connectBc () {\n    if (!this.bcconnected) {\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.subscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = true\n    }\n    // send sync step1 to bc\n    this.mux(() => {\n      // write sync step 1\n      const encoderSync = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderSync, messageSync)\n      y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep1(encoderSync, this.doc)\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderSync))\n      // broadcast local state\n      const encoderState = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderState, messageSync)\n      y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep2(encoderState, this.doc)\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderState))\n      // write queryAwareness\n      const encoderAwarenessQuery = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderAwarenessQuery))\n      // broadcast local awareness state\n      const encoderAwarenessState = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderAwarenessState, messageAwareness)\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderAwarenessState))\n    })\n  }\n\n  disconnectBc () {\n    // broadcast message with local awareness state set to null (indicating disconnect)\n    const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageAwareness)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map()))\n    broadcastMessage(this, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))\n    if (this.bcconnected) {\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.unsubscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = false\n    }\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    this.disconnectBc()\n    if (this.ws !== null) {\n      this.ws.close()\n    }\n  }\n\n  connect () {\n    this.shouldConnect = true\n    if (!this.wsconnected && this.ws === null) {\n      setupWS(this)\n      this.connectBc()\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL3ktd2Vic29ja2V0L3NyYy95LXdlYnNvY2tldC5qcz80NzA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXdCO0FBQ3NCO0FBQ1Y7QUFDUTtBQUNBO0FBQ087QUFDQTtBQUNVO0FBQ3ZCO0FBQ1M7QUFDWDtBQUNGOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsT0FBTztBQUNsQjtBQUNBLGtHQUFrRyxhQUFhLEtBQUssT0FBTzs7QUFFM0g7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFzQjtBQUN4QyxrQkFBa0IsMkRBQXNCO0FBQ3hDLHNCQUFzQix5REFBb0I7QUFDMUM7QUFDQTtBQUNBLE1BQU0sMERBQXFCO0FBQzNCLDhCQUE4QixnRUFBNEI7QUFDMUQsNENBQTRDLG9FQUFnQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBcUI7QUFDM0IsTUFBTSxnRUFBMkIsVUFBVSwyRUFBdUM7QUFDbEY7QUFDQTtBQUNBLE1BQU0sMEVBQXNDLHFCQUFxQiwrREFBMEI7QUFDM0Y7QUFDQTtBQUNBLE1BQU0sZ0VBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHFEQUFnQjtBQUN2RDtBQUNBLFVBQVUsb0RBQWU7QUFDekIsdUJBQXVCLDBEQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJFQUF1QztBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQVEsQ0FBQywrQ0FBVTtBQUM3QztBQUNBO0FBQ0EsdUNBQXVDLHFEQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0JBQXNCLDJEQUFzQjtBQUM1QyxNQUFNLDBEQUFxQjtBQUMzQixNQUFNLCtEQUEyQjtBQUNqQyxxQkFBcUIsMERBQXFCO0FBQzFDO0FBQ0E7QUFDQSxzQ0FBc0MsMkRBQXNCO0FBQzVELFFBQVEsMERBQXFCO0FBQzdCLFFBQVEsZ0VBQTJCLHdCQUF3QiwyRUFBdUM7QUFDbEcsdUJBQXVCLDBEQUFxQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2REFBVTtBQUNoQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPLGdDQUFnQywwREFBVTtBQUNqRDtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsMENBQTBDLGlDQUFpQywrREFBMkIsa0JBQWtCLHNEQUFzRCxLQUFLO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMERBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBaUI7QUFDaEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQXNCO0FBQ2hELFVBQVUsMERBQXFCO0FBQy9CLFVBQVUsK0RBQTJCO0FBQ3JDLHVCQUF1QiwwREFBcUI7QUFDNUM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFlO0FBQzNCLFVBQVUsNkRBQVUsaUJBQWlCLDBEQUFxQjtBQUMxRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBc0I7QUFDOUMsUUFBUSwwREFBcUI7QUFDN0IsUUFBUSw0REFBd0I7QUFDaEMsK0JBQStCLDBEQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQixlQUFlLElBQUk7QUFDbkI7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0Esc0JBQXNCLDJEQUFzQjtBQUM1QyxNQUFNLDBEQUFxQjtBQUMzQixNQUFNLGdFQUEyQixVQUFVLDJFQUF1QztBQUNsRiw2QkFBNkIsMERBQXFCO0FBQ2xEO0FBQ0E7QUFDQSxNQUFNLDJFQUF1QztBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdEQUF3RCxxREFBZ0I7QUFDeEU7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSwrREFBWTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFzQjtBQUNoRCxNQUFNLDBEQUFxQjtBQUMzQixNQUFNLCtEQUEyQjtBQUNqQyxNQUFNLDZEQUFVLGlCQUFpQiwwREFBcUI7QUFDdEQ7QUFDQSwyQkFBMkIsMkRBQXNCO0FBQ2pELE1BQU0sMERBQXFCO0FBQzNCLE1BQU0sK0RBQTJCO0FBQ2pDLE1BQU0sNkRBQVUsaUJBQWlCLDBEQUFxQjtBQUN0RDtBQUNBLG9DQUFvQywyREFBc0I7QUFDMUQsTUFBTSwwREFBcUI7QUFDM0IsTUFBTSw2REFBVSxpQkFBaUIsMERBQXFCO0FBQ3REO0FBQ0Esb0NBQW9DLDJEQUFzQjtBQUMxRCxNQUFNLDBEQUFxQjtBQUMzQixNQUFNLGdFQUEyQix3QkFBd0IsMkVBQXVDO0FBQ2hHLE1BQU0sNkRBQVUsaUJBQWlCLDBEQUFxQjtBQUN0RCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwyREFBc0I7QUFDMUMsSUFBSSwwREFBcUI7QUFDekIsSUFBSSxnRUFBMkIsVUFBVSwyRUFBdUM7QUFDaEYsMkJBQTJCLDBEQUFxQjtBQUNoRDtBQUNBLE1BQU0saUVBQWM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9ub2RlX21vZHVsZXMveS13ZWJzb2NrZXQvc3JjL3ktd2Vic29ja2V0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblVubGlrZSBzdGF0ZWQgaW4gdGhlIExJQ0VOU0UgZmlsZSwgaXQgaXMgbm90IG5lY2Vzc2FyeSB0byBpbmNsdWRlIHRoZSBjb3B5cmlnaHQgbm90aWNlIGFuZCBwZXJtaXNzaW9uIG5vdGljZSB3aGVuIHlvdSBjb3B5IGNvZGUgZnJvbSB0aGlzIGZpbGUuXG4qL1xuXG4vKipcbiAqIEBtb2R1bGUgcHJvdmlkZXIvd2Vic29ja2V0XG4gKi9cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgKiBhcyBiYyBmcm9tICdsaWIwL2Jyb2FkY2FzdGNoYW5uZWwuanMnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZS5qcydcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nLmpzJ1xuaW1wb3J0ICogYXMgc3luY1Byb3RvY29sIGZyb20gJ3ktcHJvdG9jb2xzL3N5bmMuanMnXG5pbXBvcnQgKiBhcyBhdXRoUHJvdG9jb2wgZnJvbSAneS1wcm90b2NvbHMvYXV0aC5qcydcbmltcG9ydCAqIGFzIGF3YXJlbmVzc1Byb3RvY29sIGZyb20gJ3ktcHJvdG9jb2xzL2F3YXJlbmVzcy5qcydcbmltcG9ydCAqIGFzIG11dGV4IGZyb20gJ2xpYjAvbXV0ZXguanMnXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGguanMnXG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAnbGliMC91cmwuanMnXG5cbmNvbnN0IG1lc3NhZ2VTeW5jID0gMFxuY29uc3QgbWVzc2FnZVF1ZXJ5QXdhcmVuZXNzID0gM1xuY29uc3QgbWVzc2FnZUF3YXJlbmVzcyA9IDFcbmNvbnN0IG1lc3NhZ2VBdXRoID0gMlxuXG5jb25zdCByZWNvbm5lY3RUaW1lb3V0QmFzZSA9IDEyMDBcbmNvbnN0IG1heFJlY29ubmVjdFRpbWVvdXQgPSAyNTAwXG4vLyBAdG9kbyAtIHRoaXMgc2hvdWxkIGRlcGVuZCBvbiBhd2FyZW5lc3Mub3V0ZGF0ZWRUaW1lXG5jb25zdCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCA9IDMwMDAwXG5cbi8qKlxuICogQHBhcmFtIHtXZWJzb2NrZXRQcm92aWRlcn0gcHJvdmlkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAqL1xuY29uc3QgcGVybWlzc2lvbkRlbmllZEhhbmRsZXIgPSAocHJvdmlkZXIsIHJlYXNvbikgPT4gY29uc29sZS53YXJuKGBQZXJtaXNzaW9uIGRlbmllZCB0byBhY2Nlc3MgJHtwcm92aWRlci51cmx9LlxcbiR7cmVhc29ufWApXG5cbi8qKlxuICogQHBhcmFtIHtXZWJzb2NrZXRQcm92aWRlcn0gcHJvdmlkZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVtaXRTeW5jZWRcbiAqIEByZXR1cm4ge2VuY29kaW5nLkVuY29kZXJ9XG4gKi9cbmNvbnN0IHJlYWRNZXNzYWdlID0gKHByb3ZpZGVyLCBidWYsIGVtaXRTeW5jZWQpID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGNvbnN0IG1lc3NhZ2VUeXBlID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgIGNhc2UgbWVzc2FnZVN5bmM6IHtcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlU3luYylcbiAgICAgIGNvbnN0IHN5bmNNZXNzYWdlVHlwZSA9IHN5bmNQcm90b2NvbC5yZWFkU3luY01lc3NhZ2UoZGVjb2RlciwgZW5jb2RlciwgcHJvdmlkZXIuZG9jLCBwcm92aWRlcilcbiAgICAgIGlmIChlbWl0U3luY2VkICYmIHN5bmNNZXNzYWdlVHlwZSA9PT0gc3luY1Byb3RvY29sLm1lc3NhZ2VZanNTeW5jU3RlcDIgJiYgIXByb3ZpZGVyLnN5bmNlZCkge1xuICAgICAgICBwcm92aWRlci5zeW5jZWQgPSB0cnVlXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIG1lc3NhZ2VRdWVyeUF3YXJlbmVzczpcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIEFycmF5LmZyb20ocHJvdmlkZXIuYXdhcmVuZXNzLmdldFN0YXRlcygpLmtleXMoKSkpKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIG1lc3NhZ2VBd2FyZW5lc3M6XG4gICAgICBhd2FyZW5lc3NQcm90b2NvbC5hcHBseUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCBwcm92aWRlcilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlQXV0aDpcbiAgICAgIGF1dGhQcm90b2NvbC5yZWFkQXV0aE1lc3NhZ2UoZGVjb2RlciwgcHJvdmlkZXIuZG9jLCBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcilcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byBjb21wdXRlIG1lc3NhZ2UnKVxuICAgICAgcmV0dXJuIGVuY29kZXJcbiAgfVxuICByZXR1cm4gZW5jb2RlclxufVxuXG4vKipcbiAqIEBwYXJhbSB7V2Vic29ja2V0UHJvdmlkZXJ9IHByb3ZpZGVyXG4gKi9cbmNvbnN0IHNldHVwV1MgPSBwcm92aWRlciA9PiB7XG4gIGlmIChwcm92aWRlci5zaG91bGRDb25uZWN0ICYmIHByb3ZpZGVyLndzID09PSBudWxsKSB7XG4gICAgY29uc3Qgd2Vic29ja2V0ID0gbmV3IHByb3ZpZGVyLl9XUyhwcm92aWRlci51cmwpXG4gICAgd2Vic29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgcHJvdmlkZXIud3MgPSB3ZWJzb2NrZXRcbiAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSB0cnVlXG4gICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSBmYWxzZVxuICAgIHByb3ZpZGVyLnN5bmNlZCA9IGZhbHNlXG5cbiAgICB3ZWJzb2NrZXQub25tZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgcHJvdmlkZXIud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBjb25zdCBlbmNvZGVyID0gcmVhZE1lc3NhZ2UocHJvdmlkZXIsIG5ldyBVaW50OEFycmF5KGV2ZW50LmRhdGEpLCB0cnVlKVxuICAgICAgaWYgKGVuY29kaW5nLmxlbmd0aChlbmNvZGVyKSA+IDEpIHtcbiAgICAgICAgd2Vic29ja2V0LnNlbmQoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgfVxuICAgIH1cbiAgICB3ZWJzb2NrZXQub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIHByb3ZpZGVyLndzID0gbnVsbFxuICAgICAgcHJvdmlkZXIud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIGlmIChwcm92aWRlci53c2Nvbm5lY3RlZCkge1xuICAgICAgICBwcm92aWRlci53c2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICAgIHByb3ZpZGVyLnN5bmNlZCA9IGZhbHNlXG4gICAgICAgIC8vIHVwZGF0ZSBhd2FyZW5lc3MgKGFsbCB1c2VycyBleGNlcHQgbG9jYWwgbGVmdClcbiAgICAgICAgYXdhcmVuZXNzUHJvdG9jb2wucmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHByb3ZpZGVyLmF3YXJlbmVzcywgQXJyYXkuZnJvbShwcm92aWRlci5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKS5maWx0ZXIoY2xpZW50ID0+IGNsaWVudCAhPT0gcHJvdmlkZXIuZG9jLmNsaWVudElEKSwgcHJvdmlkZXIpXG4gICAgICAgIHByb3ZpZGVyLmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgICAgICAgc3RhdHVzOiAnZGlzY29ubmVjdGVkJ1xuICAgICAgICB9XSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3ZpZGVyLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cysrXG4gICAgICB9XG4gICAgICAvLyBTdGFydCB3aXRoIG5vIHJlY29ubmVjdCB0aW1lb3V0IGFuZCBpbmNyZWFzZSB0aW1lb3V0IGJ5XG4gICAgICAvLyBsb2cxMCh3c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMpLlxuICAgICAgLy8gVGhlIGlkZWEgaXMgdG8gaW5jcmVhc2UgcmVjb25uZWN0IHRpbWVvdXQgc2xvd2x5IGFuZCBoYXZlIG5vIHJlY29ubmVjdFxuICAgICAgLy8gdGltZW91dCBhdCB0aGUgYmVnaW5uaW5nIChsb2coMSkgPSAwKVxuICAgICAgc2V0VGltZW91dChzZXR1cFdTLCBtYXRoLm1pbihtYXRoLmxvZzEwKHByb3ZpZGVyLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyArIDEpICogcmVjb25uZWN0VGltZW91dEJhc2UsIG1heFJlY29ubmVjdFRpbWVvdXQpLCBwcm92aWRlcilcbiAgICB9XG4gICAgd2Vic29ja2V0Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHByb3ZpZGVyLndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgcHJvdmlkZXIud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIHByb3ZpZGVyLndzY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgcHJvdmlkZXIud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuICAgICAgcHJvdmlkZXIuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgICAgc3RhdHVzOiAnY29ubmVjdGVkJ1xuICAgICAgfV0pXG4gICAgICAvLyBhbHdheXMgc2VuZCBzeW5jIHN0ZXAgMSB3aGVuIGNvbm5lY3RlZFxuICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgc3luY1Byb3RvY29sLndyaXRlU3luY1N0ZXAxKGVuY29kZXIsIHByb3ZpZGVyLmRvYylcbiAgICAgIHdlYnNvY2tldC5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBhd2FyZW5lc3Mgc3RhdGVcbiAgICAgIGlmIChwcm92aWRlci5hd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXJBd2FyZW5lc3NTdGF0ZSA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzc1N0YXRlLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1N0YXRlLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUocHJvdmlkZXIuYXdhcmVuZXNzLCBbcHJvdmlkZXIuZG9jLmNsaWVudElEXSkpXG4gICAgICAgIHdlYnNvY2tldC5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHByb3ZpZGVyLmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgICBzdGF0dXM6ICdjb25uZWN0aW5nJ1xuICAgIH1dKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJzb2NrZXRQcm92aWRlcn0gcHJvdmlkZXJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZlxuICovXG5jb25zdCBicm9hZGNhc3RNZXNzYWdlID0gKHByb3ZpZGVyLCBidWYpID0+IHtcbiAgaWYgKHByb3ZpZGVyLndzY29ubmVjdGVkKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBXZSBrbm93IHRoYXQgd3Njb25uZWN0ZWQgPSB0cnVlXG4gICAgcHJvdmlkZXIud3Muc2VuZChidWYpXG4gIH1cbiAgaWYgKHByb3ZpZGVyLmJjY29ubmVjdGVkKSB7XG4gICAgcHJvdmlkZXIubXV4KCgpID0+IHtcbiAgICAgIGJjLnB1Ymxpc2gocHJvdmlkZXIuYmNDaGFubmVsLCBidWYpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIFdlYnNvY2tldCBQcm92aWRlciBmb3IgWWpzLiBDcmVhdGVzIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gdG8gc3luYyB0aGUgc2hhcmVkIGRvY3VtZW50LlxuICogVGhlIGRvY3VtZW50IG5hbWUgaXMgYXR0YWNoZWQgdG8gdGhlIHByb3ZpZGVkIHVybC4gSS5lLiB0aGUgZm9sbG93aW5nIGV4YW1wbGVcbiAqIGNyZWF0ZXMgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiB0byBodHRwOi8vbG9jYWxob3N0OjEyMzQvbXktZG9jdW1lbnQtbmFtZVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIGltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuICogICBpbXBvcnQgeyBXZWJzb2NrZXRQcm92aWRlciB9IGZyb20gJ3ktd2Vic29ja2V0J1xuICogICBjb25zdCBkb2MgPSBuZXcgWS5Eb2MoKVxuICogICBjb25zdCBwcm92aWRlciA9IG5ldyBXZWJzb2NrZXRQcm92aWRlcignaHR0cDovL2xvY2FsaG9zdDoxMjM0JywgJ215LWRvY3VtZW50LW5hbWUnLCBkb2MpXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYnNvY2tldFByb3ZpZGVyIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyVXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb29tbmFtZVxuICAgKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmNvbm5lY3RdXG4gICAqIEBwYXJhbSB7YXdhcmVuZXNzUHJvdG9jb2wuQXdhcmVuZXNzfSBbb3B0cy5hd2FyZW5lc3NdXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxzdHJpbmc+fSBbb3B0cy5wYXJhbXNdXG4gICAqIEBwYXJhbSB7dHlwZW9mIFdlYlNvY2tldH0gW29wdHMuV2ViU29ja2V0UG9seWZpbGxdIE9wdGlvbmFsbCBwcm92aWRlIGEgV2ViU29ja2V0IHBvbHlmaWxsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5yZXN5bmNJbnRlcnZhbF0gUmVxdWVzdCBzZXJ2ZXIgc3RhdGUgZXZlcnkgYHJlc3luY0ludGVydmFsYCBtaWxsaXNlY29uZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzZXJ2ZXJVcmwsIHJvb21uYW1lLCBkb2MsIHsgY29ubmVjdCA9IHRydWUsIGF3YXJlbmVzcyA9IG5ldyBhd2FyZW5lc3NQcm90b2NvbC5Bd2FyZW5lc3MoZG9jKSwgcGFyYW1zID0ge30sIFdlYlNvY2tldFBvbHlmaWxsID0gV2ViU29ja2V0LCByZXN5bmNJbnRlcnZhbCA9IC0xIH0gPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICAvLyBlbnN1cmUgdGhhdCB1cmwgaXMgYWx3YXlzIGVuZHMgd2l0aCAvXG4gICAgd2hpbGUgKHNlcnZlclVybFtzZXJ2ZXJVcmwubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgc2VydmVyVXJsID0gc2VydmVyVXJsLnNsaWNlKDAsIHNlcnZlclVybC5sZW5ndGggLSAxKVxuICAgIH1cbiAgICBjb25zdCBlbmNvZGVkUGFyYW1zID0gdXJsLmVuY29kZVF1ZXJ5UGFyYW1zKHBhcmFtcylcbiAgICB0aGlzLmJjQ2hhbm5lbCA9IHNlcnZlclVybCArICcvJyArIHJvb21uYW1lXG4gICAgdGhpcy51cmwgPSBzZXJ2ZXJVcmwgKyAnLycgKyByb29tbmFtZSArIChlbmNvZGVkUGFyYW1zLmxlbmd0aCA9PT0gMCA/ICcnIDogJz8nICsgZW5jb2RlZFBhcmFtcylcbiAgICB0aGlzLnJvb21uYW1lID0gcm9vbW5hbWVcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIHRoaXMuX1dTID0gV2ViU29ja2V0UG9seWZpbGxcbiAgICB0aGlzLmF3YXJlbmVzcyA9IGF3YXJlbmVzc1xuICAgIHRoaXMud3Njb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGlzLmJjY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcbiAgICB0aGlzLm11eCA9IG11dGV4LmNyZWF0ZU11dGV4KClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9zeW5jZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXZWJTb2NrZXQ/fVxuICAgICAqL1xuICAgIHRoaXMud3MgPSBudWxsXG4gICAgdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBjb25uZWN0IHRvIG90aGVyIHBlZXJzIG9yIG5vdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGNvbm5lY3RcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtOb2RlSlMuVGltZW91dCB8IG51bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9yZXN5bmNJbnRlcnZhbCA9IDBcbiAgICBpZiAocmVzeW5jSW50ZXJ2YWwgPiAwKSB7XG4gICAgICB0aGlzLl9yZXN5bmNJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAvLyByZXNlbmQgc3luYyBzdGVwIDFcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMShlbmNvZGVyLCBkb2MpXG4gICAgICAgICAgdGhpcy53cy5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgICAgfVxuICAgICAgfSwgcmVzeW5jSW50ZXJ2YWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuX2JjU3Vic2NyaWJlciA9IGRhdGEgPT4ge1xuICAgICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gcmVhZE1lc3NhZ2UodGhpcywgbmV3IFVpbnQ4QXJyYXkoZGF0YSksIGZhbHNlKVxuICAgICAgICBpZiAoZW5jb2RpbmcubGVuZ3RoKGVuY29kZXIpID4gMSkge1xuICAgICAgICAgIGJjLnB1Ymxpc2godGhpcy5iY0NoYW5uZWwsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVucyB0byBZanMgdXBkYXRlcyBhbmQgc2VuZHMgdGhlbSB0byByZW1vdGUgcGVlcnMgKHdzIGFuZCBicm9hZGNhc3RjaGFubmVsKVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gICAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgICAqL1xuICAgIHRoaXMuX3VwZGF0ZUhhbmRsZXIgPSAodXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgICAgIGlmIChvcmlnaW4gIT09IHRoaXMgfHwgb3JpZ2luID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgICBzeW5jUHJvdG9jb2wud3JpdGVVcGRhdGUoZW5jb2RlciwgdXBkYXRlKVxuICAgICAgICBicm9hZGNhc3RNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kb2Mub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZUhhbmRsZXIpXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAgICovXG4gICAgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlciA9ICh7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sIG9yaWdpbikgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlZENsaWVudHMgPSBhZGRlZC5jb25jYXQodXBkYXRlZCkuY29uY2F0KHJlbW92ZWQpXG4gICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUoYXdhcmVuZXNzLCBjaGFuZ2VkQ2xpZW50cykpXG4gICAgICBicm9hZGNhc3RNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsICgpID0+IHtcbiAgICAgIGF3YXJlbmVzc1Byb3RvY29sLnJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgW2RvYy5jbGllbnRJRF0sICd3aW5kb3cgdW5sb2FkJylcbiAgICB9KVxuICAgIGF3YXJlbmVzcy5vbigndXBkYXRlJywgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlcilcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud3Njb25uZWN0ZWQgJiYgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgPCB0aW1lLmdldFVuaXhUaW1lKCkgLSB0aGlzLndzTGFzdE1lc3NhZ2VSZWNlaXZlZCkge1xuICAgICAgICAvLyBubyBtZXNzYWdlIHJlY2VpdmVkIGluIGEgbG9uZyB0aW1lIC0gbm90IGV2ZW4geW91ciBvd24gYXdhcmVuZXNzXG4gICAgICAgIC8vIHVwZGF0ZXMgKHdoaWNoIGFyZSB1cGRhdGVkIGV2ZXJ5IDE1IHNlY29uZHMpXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViU29ja2V0fSAqLyAodGhpcy53cykuY2xvc2UoKVxuICAgICAgfVxuICAgIH0sIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IC8gMTApXG4gICAgaWYgKGNvbm5lY3QpIHtcbiAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHN5bmNlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmNlZFxuICB9XG5cbiAgc2V0IHN5bmNlZCAoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc3luY2VkICE9PSBzdGF0ZSkge1xuICAgICAgdGhpcy5fc3luY2VkID0gc3RhdGVcbiAgICAgIHRoaXMuZW1pdCgnc3luY2VkJywgW3N0YXRlXSlcbiAgICAgIHRoaXMuZW1pdCgnc3luYycsIFtzdGF0ZV0pXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMuX3Jlc3luY0ludGVydmFsICE9PSAwKSB7XG4gICAgICBjbGVhckludGVydmFsKC8qKiBAdHlwZSB7Tm9kZUpTLlRpbWVvdXR9ICovICh0aGlzLl9yZXN5bmNJbnRlcnZhbCkpXG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbClcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIHRoaXMuYXdhcmVuZXNzLm9mZigndXBkYXRlJywgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlcilcbiAgICB0aGlzLmRvYy5vZmYoJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZUhhbmRsZXIpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cblxuICBjb25uZWN0QmMgKCkge1xuICAgIGlmICghdGhpcy5iY2Nvbm5lY3RlZCkge1xuICAgICAgYmMuc3Vic2NyaWJlKHRoaXMuYmNDaGFubmVsLCB0aGlzLl9iY1N1YnNjcmliZXIpXG4gICAgICB0aGlzLmJjY29ubmVjdGVkID0gdHJ1ZVxuICAgIH1cbiAgICAvLyBzZW5kIHN5bmMgc3RlcDEgdG8gYmNcbiAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICAvLyB3cml0ZSBzeW5jIHN0ZXAgMVxuICAgICAgY29uc3QgZW5jb2RlclN5bmMgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyU3luYywgbWVzc2FnZVN5bmMpXG4gICAgICBzeW5jUHJvdG9jb2wud3JpdGVTeW5jU3RlcDEoZW5jb2RlclN5bmMsIHRoaXMuZG9jKVxuICAgICAgYmMucHVibGlzaCh0aGlzLmJjQ2hhbm5lbCwgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJTeW5jKSlcbiAgICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBzdGF0ZVxuICAgICAgY29uc3QgZW5jb2RlclN0YXRlID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlclN0YXRlLCBtZXNzYWdlU3luYylcbiAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMihlbmNvZGVyU3RhdGUsIHRoaXMuZG9jKVxuICAgICAgYmMucHVibGlzaCh0aGlzLmJjQ2hhbm5lbCwgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJTdGF0ZSkpXG4gICAgICAvLyB3cml0ZSBxdWVyeUF3YXJlbmVzc1xuICAgICAgY29uc3QgZW5jb2RlckF3YXJlbmVzc1F1ZXJ5ID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzc1F1ZXJ5LCBtZXNzYWdlUXVlcnlBd2FyZW5lc3MpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1F1ZXJ5KSlcbiAgICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBhd2FyZW5lc3Mgc3RhdGVcbiAgICAgIGNvbnN0IGVuY29kZXJBd2FyZW5lc3NTdGF0ZSA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZSh0aGlzLmF3YXJlbmVzcywgW3RoaXMuZG9jLmNsaWVudElEXSkpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1N0YXRlKSlcbiAgICB9KVxuICB9XG5cbiAgZGlzY29ubmVjdEJjICgpIHtcbiAgICAvLyBicm9hZGNhc3QgbWVzc2FnZSB3aXRoIGxvY2FsIGF3YXJlbmVzcyBzdGF0ZSBzZXQgdG8gbnVsbCAoaW5kaWNhdGluZyBkaXNjb25uZWN0KVxuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2MuY2xpZW50SURdLCBuZXcgTWFwKCkpKVxuICAgIGJyb2FkY2FzdE1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgIGlmICh0aGlzLmJjY29ubmVjdGVkKSB7XG4gICAgICBiYy51bnN1YnNjcmliZSh0aGlzLmJjQ2hhbm5lbCwgdGhpcy5fYmNTdWJzY3JpYmVyKVxuICAgICAgdGhpcy5iY2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gZmFsc2VcbiAgICB0aGlzLmRpc2Nvbm5lY3RCYygpXG4gICAgaWYgKHRoaXMud3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWVcbiAgICBpZiAoIXRoaXMud3Njb25uZWN0ZWQgJiYgdGhpcy53cyA9PT0gbnVsbCkge1xuICAgICAgc2V0dXBXUyh0aGlzKVxuICAgICAgdGhpcy5jb25uZWN0QmMoKVxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/y-websocket/src/y-websocket.js\n")},"../CoCreate-crdt/node_modules/yjs/dist/yjs.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractConnector\": () => (/* binding */ AbstractConnector),\n/* harmony export */   \"AbstractStruct\": () => (/* binding */ AbstractStruct),\n/* harmony export */   \"AbstractType\": () => (/* binding */ AbstractType),\n/* harmony export */   \"Array\": () => (/* binding */ YArray),\n/* harmony export */   \"ContentAny\": () => (/* binding */ ContentAny),\n/* harmony export */   \"ContentBinary\": () => (/* binding */ ContentBinary),\n/* harmony export */   \"ContentDeleted\": () => (/* binding */ ContentDeleted),\n/* harmony export */   \"ContentEmbed\": () => (/* binding */ ContentEmbed),\n/* harmony export */   \"ContentFormat\": () => (/* binding */ ContentFormat),\n/* harmony export */   \"ContentJSON\": () => (/* binding */ ContentJSON),\n/* harmony export */   \"ContentString\": () => (/* binding */ ContentString),\n/* harmony export */   \"ContentType\": () => (/* binding */ ContentType),\n/* harmony export */   \"Doc\": () => (/* binding */ Doc),\n/* harmony export */   \"GC\": () => (/* binding */ GC),\n/* harmony export */   \"ID\": () => (/* binding */ ID),\n/* harmony export */   \"Item\": () => (/* binding */ Item),\n/* harmony export */   \"Map\": () => (/* binding */ YMap),\n/* harmony export */   \"PermanentUserData\": () => (/* binding */ PermanentUserData),\n/* harmony export */   \"RelativePosition\": () => (/* binding */ RelativePosition),\n/* harmony export */   \"Snapshot\": () => (/* binding */ Snapshot),\n/* harmony export */   \"Text\": () => (/* binding */ YText),\n/* harmony export */   \"Transaction\": () => (/* binding */ Transaction),\n/* harmony export */   \"UndoManager\": () => (/* binding */ UndoManager),\n/* harmony export */   \"XmlElement\": () => (/* binding */ YXmlElement),\n/* harmony export */   \"XmlFragment\": () => (/* binding */ YXmlFragment),\n/* harmony export */   \"XmlHook\": () => (/* binding */ YXmlHook),\n/* harmony export */   \"XmlText\": () => (/* binding */ YXmlText),\n/* harmony export */   \"YArrayEvent\": () => (/* binding */ YArrayEvent),\n/* harmony export */   \"YEvent\": () => (/* binding */ YEvent),\n/* harmony export */   \"YMapEvent\": () => (/* binding */ YMapEvent),\n/* harmony export */   \"YTextEvent\": () => (/* binding */ YTextEvent),\n/* harmony export */   \"YXmlEvent\": () => (/* binding */ YXmlEvent),\n/* harmony export */   \"applyUpdate\": () => (/* binding */ applyUpdate),\n/* harmony export */   \"applyUpdateV2\": () => (/* binding */ applyUpdateV2),\n/* harmony export */   \"compareIDs\": () => (/* binding */ compareIDs),\n/* harmony export */   \"compareRelativePositions\": () => (/* binding */ compareRelativePositions),\n/* harmony export */   \"createAbsolutePositionFromRelativePosition\": () => (/* binding */ createAbsolutePositionFromRelativePosition),\n/* harmony export */   \"createDeleteSet\": () => (/* binding */ createDeleteSet),\n/* harmony export */   \"createDeleteSetFromStructStore\": () => (/* binding */ createDeleteSetFromStructStore),\n/* harmony export */   \"createDocFromSnapshot\": () => (/* binding */ createDocFromSnapshot),\n/* harmony export */   \"createID\": () => (/* binding */ createID),\n/* harmony export */   \"createRelativePositionFromJSON\": () => (/* binding */ createRelativePositionFromJSON),\n/* harmony export */   \"createRelativePositionFromTypeIndex\": () => (/* binding */ createRelativePositionFromTypeIndex),\n/* harmony export */   \"createSnapshot\": () => (/* binding */ createSnapshot),\n/* harmony export */   \"decodeSnapshot\": () => (/* binding */ decodeSnapshot),\n/* harmony export */   \"decodeSnapshotV2\": () => (/* binding */ decodeSnapshotV2),\n/* harmony export */   \"decodeStateVector\": () => (/* binding */ decodeStateVector),\n/* harmony export */   \"decodeStateVectorV2\": () => (/* binding */ decodeStateVectorV2),\n/* harmony export */   \"emptySnapshot\": () => (/* binding */ emptySnapshot),\n/* harmony export */   \"encodeSnapshot\": () => (/* binding */ encodeSnapshot),\n/* harmony export */   \"encodeSnapshotV2\": () => (/* binding */ encodeSnapshotV2),\n/* harmony export */   \"encodeStateAsUpdate\": () => (/* binding */ encodeStateAsUpdate),\n/* harmony export */   \"encodeStateAsUpdateV2\": () => (/* binding */ encodeStateAsUpdateV2),\n/* harmony export */   \"encodeStateVector\": () => (/* binding */ encodeStateVector),\n/* harmony export */   \"encodeStateVectorV2\": () => (/* binding */ encodeStateVectorV2),\n/* harmony export */   \"equalSnapshots\": () => (/* binding */ equalSnapshots),\n/* harmony export */   \"findRootTypeKey\": () => (/* binding */ findRootTypeKey),\n/* harmony export */   \"getItem\": () => (/* binding */ getItem),\n/* harmony export */   \"getState\": () => (/* binding */ getState),\n/* harmony export */   \"getTypeChildren\": () => (/* binding */ getTypeChildren),\n/* harmony export */   \"isDeleted\": () => (/* binding */ isDeleted),\n/* harmony export */   \"isParentOf\": () => (/* binding */ isParentOf),\n/* harmony export */   \"iterateDeletedStructs\": () => (/* binding */ iterateDeletedStructs),\n/* harmony export */   \"logType\": () => (/* binding */ logType),\n/* harmony export */   \"readUpdate\": () => (/* binding */ readUpdate),\n/* harmony export */   \"readUpdateV2\": () => (/* binding */ readUpdateV2),\n/* harmony export */   \"snapshot\": () => (/* binding */ snapshot),\n/* harmony export */   \"transact\": () => (/* binding */ transact),\n/* harmony export */   \"tryGc\": () => (/* binding */ tryGc),\n/* harmony export */   \"typeListToArraySnapshot\": () => (/* binding */ typeListToArraySnapshot),\n/* harmony export */   \"typeMapGetSnapshot\": () => (/* binding */ typeMapGetSnapshot)\n/* harmony export */ });\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable.js */ \"../CoCreate-crdt/node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/array.js */ \"../CoCreate-crdt/node_modules/lib0/array.js\");\n/* harmony import */ var lib0_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/math.js */ \"../CoCreate-crdt/node_modules/lib0/math.js\");\n/* harmony import */ var lib0_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/map.js */ \"../CoCreate-crdt/node_modules/lib0/map.js\");\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding.js */ \"../CoCreate-crdt/node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding.js */ \"../CoCreate-crdt/node_modules/lib0/decoding.js\");\n/* harmony import */ var lib0_random_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/random.js */ \"../CoCreate-crdt/node_modules/lib0/random.js\");\n/* harmony import */ var lib0_buffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/buffer.js */ \"../CoCreate-crdt/node_modules/lib0/buffer.js\");\n/* harmony import */ var lib0_error_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/error.js */ \"../CoCreate-crdt/node_modules/lib0/error.js\");\n/* harmony import */ var lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/binary.js */ \"../CoCreate-crdt/node_modules/lib0/binary.js\");\n/* harmony import */ var lib0_function_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/function.js */ \"../CoCreate-crdt/node_modules/lib0/function.js\");\n/* harmony import */ var lib0_set_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/set.js */ \"../CoCreate-crdt/node_modules/lib0/set.js\");\n/* harmony import */ var lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/logging.js */ \"../CoCreate-crdt/node_modules/lib0/logging.js\");\n/* harmony import */ var lib0_time_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/time.js */ \"../CoCreate-crdt/node_modules/lib0/time.js\");\n/* harmony import */ var lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/iterator.js */ \"../CoCreate-crdt/node_modules/lib0/iterator.js\");\n/* harmony import */ var lib0_object_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/object.js */ \"../CoCreate-crdt/node_modules/lib0/object.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {Observable<any>}\n */\nclass AbstractConnector extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor (ydoc, awareness) {\n    super();\n    this.doc = ydoc;\n    this.awareness = awareness;\n  }\n}\n\nclass DeleteItem {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock;\n    /**\n     * @type {number}\n     */\n    this.len = len;\n  }\n}\n\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */\nclass DeleteSet {\n  constructor () {\n    /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */\n    this.clients = new Map();\n  }\n}\n\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateDeletedStructs = (transaction, ds, f) =>\n  ds.clients.forEach((deletes, clientid) => {\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid));\n    for (let i = 0; i < deletes.length; i++) {\n      const del = deletes[i];\n      iterateStructs(transaction, structs, del.clock, del.len, f);\n    }\n  });\n\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nconst findIndexDS = (dis, clock) => {\n  let left = 0;\n  let right = dis.length - 1;\n  while (left <= right) {\n    const midindex = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.floor)((left + right) / 2);\n    const mid = dis[midindex];\n    const midclock = mid.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n  }\n  return null\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst isDeleted = (ds, id) => {\n  const dis = ds.clients.get(id.client);\n  return dis !== undefined && findIndexDS(dis, id.clock) !== null\n};\n\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst sortAndMergeDeleteSet = ds => {\n  ds.clients.forEach(dels => {\n    dels.sort((a, b) => a.clock - b.clock);\n    // merge items without filtering or splicing the array\n    // i is the current pointer\n    // j refers to the current insert position for the pointed item\n    // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n    let i, j;\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1];\n      const right = dels[i];\n      if (left.clock + left.len === right.clock) {\n        left.len += right.len;\n      } else {\n        if (j < i) {\n          dels[j] = right;\n        }\n        j++;\n      }\n    }\n    dels.length = j;\n  });\n};\n\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */\nconst mergeDeleteSets = dss => {\n  const merged = new DeleteSet();\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        /**\n         * @type {Array<DeleteItem>}\n         */\n        const dels = delsLeft.slice();\n        for (let i = dssI + 1; i < dss.length; i++) {\n          (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.appendTo)(dels, dss[i].clients.get(client) || []);\n        }\n        merged.clients.set(client, dels);\n      }\n    });\n  }\n  sortAndMergeDeleteSet(merged);\n  return merged\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nconst addToDeleteSet = (ds, client, clock, length) => {\n  (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(ds.clients, client, () => []).push(new DeleteItem(clock, length));\n};\n\nconst createDeleteSet = () => new DeleteSet();\n\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */\nconst createDeleteSetFromStructStore = ss => {\n  const ds = createDeleteSet();\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<DeleteItem>}\n     */\n    const dsitems = [];\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i];\n      if (struct.deleted) {\n        const clock = struct.id.clock;\n        let len = struct.length;\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.id.clock === clock + len && next.deleted; next = structs[++i + 1]) {\n            len += next.length;\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len));\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems);\n    }\n  });\n  return ds\n};\n\n/**\n * @param {AbstractDSEncoder} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst writeDeleteSet = (encoder, ds) => {\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, ds.clients.size);\n  ds.clients.forEach((dsitems, client) => {\n    encoder.resetDsCurVal();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, client);\n    const len = dsitems.length;\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, len);\n    for (let i = 0; i < len; i++) {\n      const item = dsitems[i];\n      encoder.writeDsClock(item.clock);\n      encoder.writeDsLen(item.len);\n    }\n  });\n};\n\n/**\n * @param {AbstractDSDecoder} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */\nconst readDeleteSet = decoder => {\n  const ds = new DeleteSet();\n  const numClients = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const numberOfDeletes = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    if (numberOfDeletes > 0) {\n      const dsField = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(ds.clients, client, () => []);\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n      }\n    }\n  }\n  return ds\n};\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {AbstractDSDecoder} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n *\n * @private\n * @function\n */\nconst readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet();\n  const numClients = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const numberOfDeletes = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const structs = store.clients.get(client) || [];\n    const state = getState(store, client);\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock();\n      const clockEnd = clock + decoder.readDsLen();\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n        }\n        let index = findIndexSS(structs, clock);\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */\n        // @ts-ignore\n        let struct = structs[index];\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n          index++; // increase we now want to use the next struct\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++];\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n              }\n              struct.delete(transaction);\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    // TODO: no need for encoding+decoding ds anymore\n    const unappliedDSEncoder = new DSEncoderV2();\n    writeDeleteSet(unappliedDSEncoder, unappliedDS);\n    store.pendingDeleteReaders.push(new DSDecoderV2((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)((unappliedDSEncoder.toUint8Array()))));\n  }\n};\n\n/**\n * @module Y\n */\n\nconst generateNewClientId = lib0_random_js__WEBPACK_IMPORTED_MODULE_6__.uint32;\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends Observable<string>\n */\nclass Doc extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {DocOpts} [opts] configuration\n   */\n  constructor ({ guid = (0,lib0_random_js__WEBPACK_IMPORTED_MODULE_6__.uuidv4)(), gc = true, gcFilter = () => true, meta = null, autoLoad = false } = {}) {\n    super();\n    this.gc = gc;\n    this.gcFilter = gcFilter;\n    this.clientID = generateNewClientId();\n    this.guid = guid;\n    /**\n     * @type {Map<string, AbstractType<YEvent>>}\n     */\n    this.share = new Map();\n    this.store = new StructStore();\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null;\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = [];\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set();\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null;\n    this.shouldLoad = autoLoad;\n    this.autoLoad = autoLoad;\n    this.meta = meta;\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item;\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this);\n      }, null, true);\n    }\n    this.shouldLoad = true;\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(Array.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @param {function(Transaction):void} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    transact(this, f, origin);\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = AbstractType) {\n    const type = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor();\n      t._integrate(this, null);\n      return t\n    });\n    const Constr = type.constructor;\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor();\n        t._map = type._map;\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t;\n          }\n        });\n        t._start = type._start;\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t;\n        }\n        t._length = type._length;\n        this.share.set(name, t);\n        t._integrate(this, null);\n        return t\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return type\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    // @ts-ignore\n    return this.get(name, YArray)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    // @ts-ignore\n    return this.get(name, YText)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YMap<any>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    // @ts-ignore\n    return this.get(name, YMap)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    // @ts-ignore\n    return this.get(name, YXmlFragment)\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {};\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON();\n    });\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.from)(this.subdocs).forEach(subdoc => subdoc.destroy());\n    const item = this._item;\n    if (item !== null) {\n      this._item = null;\n      const content = /** @type {ContentDoc} */ (item.content);\n      if (item.deleted) {\n        // @ts-ignore\n        content.doc = null;\n      } else {\n        content.doc = new Doc({ guid: this.guid, ...content.opts });\n        content.doc._item = item;\n      }\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(content.doc);\n        }\n        transaction.subdocsRemoved.add(this);\n      }, null, true);\n    }\n    this.emit('destroyed', [true]);\n    this.emit('destroy', [this]);\n    super.destroy();\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on (eventName, f) {\n    super.on(eventName, f);\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off (eventName, f) {\n    super.off(eventName, f);\n  }\n}\n\nclass DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n}\n\nclass UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder), (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder), (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8)(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny)(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return (0,lib0_buffer_js__WEBPACK_IMPORTED_MODULE_7__.copyUint8Array)((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(this.restDecoder)\n  }\n}\n\nclass DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.dsCurrVal = 0;\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  readDsClock () {\n    this.dsCurrVal += (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder);\n    return this.dsCurrVal\n  }\n\n  readDsLen () {\n    const diff = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder) + 1;\n    this.dsCurrVal += diff;\n    return diff\n  }\n}\n\nclass UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder);\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = [];\n    (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8)(decoder); // read feature flag - currently unused\n    this.keyClockDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.clientDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.leftClockDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.rightClockDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.infoDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.RleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder), lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.stringDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.StringDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.parentInfoDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.RleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder), lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.typeRefDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.lenDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny)(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny)(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read();\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read();\n      this.keys.push(key);\n      return key\n    }\n  }\n}\n\nclass DSEncoderV1 {\n  constructor () {\n    this.restEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.Encoder();\n  }\n\n  toUint8Array () {\n    return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, clock);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, len);\n  }\n}\n\nclass UpdateEncoderV1 extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.client);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.client);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.clock);\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8)(this.restEncoder, info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(this.restEncoder, s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny)(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(this.restEncoder, buf);\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(this.restEncoder, JSON.stringify(embed));\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(this.restEncoder, key);\n  }\n}\n\nclass DSEncoderV2 {\n  constructor () {\n    this.restEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.Encoder(); // encodes all the rest / non-optimized\n    this.dsCurrVal = 0;\n  }\n\n  toUint8Array () {\n    return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    const diff = clock - this.dsCurrVal;\n    this.dsCurrVal = clock;\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, diff);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    if (len === 0) {\n      (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n    }\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, len - 1);\n    this.dsCurrVal += len;\n  }\n}\n\nclass UpdateEncoderV2 extends DSEncoderV2 {\n  constructor () {\n    super();\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map();\n    /**\n     * Refers to the next uniqe key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0;\n    this.keyClockEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.clientEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.leftClockEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.rightClockEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.infoEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.stringEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.StringEncoder();\n    this.parentInfoEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.typeRefEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.lenEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n  }\n\n  toUint8Array () {\n    const encoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8)(encoder, 0); // this is a feature flag that we might use in the future\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.keyClockEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.clientEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.leftClockEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.rightClockEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.infoEncoder));\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.stringEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.parentInfoEncoder));\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.typeRefEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.lenEncoder.toUint8Array());\n    // @note The rest encoder is appended! (note the missing var)\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array)(encoder, (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.restEncoder));\n    return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client);\n    this.leftClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client);\n    this.rightClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny)(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(this.restEncoder, buf);\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny)(this.restEncoder, embed);\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key);\n    if (clock === undefined) {\n      this.keyClockEncoder.write(this.keyClock++);\n      this.stringEncoder.write(key);\n    } else {\n      this.keyClockEncoder.write(this.keyClock++);\n    }\n  }\n}\n\nlet DefaultDSEncoder = DSEncoderV1;\nlet DefaultDSDecoder = DSDecoderV1;\nlet DefaultUpdateEncoder = UpdateEncoderV1;\nlet DefaultUpdateDecoder = UpdateDecoderV1;\n\n/**\n * @param {AbstractUpdateEncoder} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, clock) => {\n  // write first id\n  const startNewStructs = findIndexSS(structs, clock);\n  // write # encoded structs\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, structs.length - startNewStructs);\n  encoder.writeClient(client);\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, clock);\n  const firstStruct = structs[startNewStructs];\n  // write first struct with an offset\n  firstStruct.write(encoder, clock - firstStruct.id.clock);\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0);\n  }\n};\n\n/**\n * @param {AbstractUpdateEncoder} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nconst writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map();\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock);\n    }\n  });\n  getStateVector(store).forEach((clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0);\n    }\n  });\n  // write # states that were updated\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, sm.size);\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  Array.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    // @ts-ignore\n    writeStructs(encoder, store.clients.get(client), client, clock);\n  });\n};\n\n/**\n * @param {AbstractUpdateDecoder} decoder The decoder object to read data from.\n * @param {Map<number,Array<GC|Item>>} clientRefs\n * @param {Doc} doc\n * @return {Map<number,Array<GC|Item>>}\n *\n * @private\n * @function\n */\nconst readClientsStructRefs = (decoder, clientRefs, doc) => {\n  const numOfStateUpdates = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs);\n    const client = decoder.readClient();\n    let clock = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    // const start = performance.now()\n    clientRefs.set(client, refs);\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      if ((lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5 & info) !== 0) {\n        /**\n         * The optimized implementation doesn't use any variables because inlining variables is faster.\n         * Below a non-optimized version is shown that implements the basic algorithm with\n         * a few comments\n         */\n        const cantCopyParentInfo = (info & (lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 | lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8)) === 0;\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // leftd\n          (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 ? decoder.readRightID() : null, // right origin\n          cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        );\n        /* A non-optimized implementation of the above algorithm:\n\n        // The item that was originally to the left of this item.\n        const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n        // The item that was originally to the right of this item.\n        const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n        const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n        const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n        const struct = new Item(\n          createID(client, clock),\n          null, // leftd\n          origin, // origin\n          null, // right\n          rightOrigin, // right origin\n          cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n          cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        )\n        */\n        refs[i] = struct;\n        clock += struct.length;\n      } else {\n        const len = decoder.readLen();\n        refs[i] = new GC(createID(client, clock), len);\n        clock += len;\n      }\n    }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n  }\n  return clientRefs\n};\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n *\n * @private\n * @function\n */\nconst resumeStructIntegration = (transaction, store) => {\n  const stack = store.pendingStack; // @todo don't forget to append stackhead at the end\n  const clientsStructRefs = store.pendingClientsStructRefs;\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  const clientsStructRefsIds = Array.from(clientsStructRefs.keys()).sort((a, b) => a - b);\n  if (clientsStructRefsIds.length === 0) {\n    return\n  }\n  const getNextStructTarget = () => {\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop();\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n      } else {\n        store.pendingClientsStructRefs.clear();\n        return null\n      }\n    }\n    return nextStructsTarget\n  };\n  let curStructsTarget = getNextStructTarget();\n  if (curStructsTarget === null && stack.length === 0) {\n    return\n  }\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = stack.length > 0\n    ? /** @type {GC|Item} */ (stack.pop())\n    : /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];\n  // caching the state because it is used very often\n  const state = new Map();\n  // iterate over all struct readers until we are done\n  while (true) {\n    const localClock = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n    const offset = stackHead.id.clock < localClock ? localClock - stackHead.id.clock : 0;\n    if (stackHead.id.clock + offset !== localClock) {\n      // A previous message from this client is missing\n      // check if there is a pending structRef with a smaller clock and switch them\n      /**\n       * @type {{ refs: Array<GC|Item>, i: number }}\n       */\n      const structRefs = clientsStructRefs.get(stackHead.id.client) || { refs: [], i: 0 };\n      if (structRefs.refs.length !== structRefs.i) {\n        const r = structRefs.refs[structRefs.i];\n        if (r.id.clock < stackHead.id.clock) {\n          // put ref with smaller clock on stack instead and continue\n          structRefs.refs[structRefs.i] = stackHead;\n          stackHead = r;\n          // sort the set because this approach might bring the list out of order\n          structRefs.refs = structRefs.refs.slice(structRefs.i).sort((r1, r2) => r1.id.clock - r2.id.clock);\n          structRefs.i = 0;\n          continue\n        }\n      }\n      // wait until missing struct is available\n      stack.push(stackHead);\n      return\n    }\n    const missing = stackHead.getMissing(transaction, store);\n    if (missing === null) {\n      if (offset === 0 || offset < stackHead.length) {\n        stackHead.integrate(transaction, offset);\n        state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n      }\n      // iterate to next stackHead\n      if (stack.length > 0) {\n        stackHead = /** @type {GC|Item} */ (stack.pop());\n      } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n      } else {\n        curStructsTarget = getNextStructTarget();\n        if (curStructsTarget === null) {\n          // we are done!\n          break\n        } else {\n          stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n        }\n      }\n    } else {\n      // get the struct reader that has the missing struct\n      /**\n       * @type {{ refs: Array<GC|Item>, i: number }}\n       */\n      const structRefs = clientsStructRefs.get(missing) || { refs: [], i: 0 };\n      if (structRefs.refs.length === structRefs.i) {\n        // This update message causally depends on another update message.\n        stack.push(stackHead);\n        return\n      }\n      stack.push(stackHead);\n      stackHead = structRefs.refs[structRefs.i++];\n    }\n  }\n  store.pendingClientsStructRefs.clear();\n};\n\n/**\n * @param {Transaction} transaction\n * @param {StructStore} store\n *\n * @private\n * @function\n */\nconst tryResumePendingDeleteReaders = (transaction, store) => {\n  const pendingReaders = store.pendingDeleteReaders;\n  store.pendingDeleteReaders = [];\n  for (let i = 0; i < pendingReaders.length; i++) {\n    readAndApplyDeleteSet(pendingReaders[i], transaction, store);\n  }\n};\n\n/**\n * @param {AbstractUpdateEncoder} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nconst writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n\n/**\n * @param {StructStore} store\n * @param {Map<number, Array<GC|Item>>} clientsStructsRefs\n *\n * @private\n * @function\n */\nconst mergeReadStructsIntoPendingReads = (store, clientsStructsRefs) => {\n  const pendingClientsStructRefs = store.pendingClientsStructRefs;\n  clientsStructsRefs.forEach((structRefs, client) => {\n    const pendingStructRefs = pendingClientsStructRefs.get(client);\n    if (pendingStructRefs === undefined) {\n      pendingClientsStructRefs.set(client, { refs: structRefs, i: 0 });\n    } else {\n      // merge into existing structRefs\n      const merged = pendingStructRefs.i > 0 ? pendingStructRefs.refs.slice(pendingStructRefs.i) : pendingStructRefs.refs;\n      for (let i = 0; i < structRefs.length; i++) {\n        merged.push(structRefs[i]);\n      }\n      pendingStructRefs.i = 0;\n      pendingStructRefs.refs = merged.sort((r1, r2) => r1.id.clock - r2.id.clock);\n    }\n  });\n};\n\n/**\n * @param {Map<number,{refs:Array<GC|Item>,i:number}>} pendingClientsStructRefs\n */\nconst cleanupPendingStructs = pendingClientsStructRefs => {\n  // cleanup pendingClientsStructs if not fully finished\n  pendingClientsStructRefs.forEach((refs, client) => {\n    if (refs.i === refs.refs.length) {\n      pendingClientsStructRefs.delete(client);\n    } else {\n      refs.refs.splice(0, refs.i);\n      refs.i = 0;\n    }\n  });\n};\n\n/**\n * Read the next Item in a Decoder and fill this Item with the read data.\n *\n * This is called when data is received from a remote peer.\n *\n * @param {AbstractUpdateDecoder} decoder The decoder object to read data from.\n * @param {Transaction} transaction\n * @param {StructStore} store\n *\n * @private\n * @function\n */\nconst readStructs = (decoder, transaction, store) => {\n  const clientsStructRefs = new Map();\n  // let start = performance.now()\n  readClientsStructRefs(decoder, clientsStructRefs, transaction.doc);\n  // console.log('time to read structs: ', performance.now() - start) // @todo remove\n  // start = performance.now()\n  mergeReadStructsIntoPendingReads(store, clientsStructRefs);\n  // console.log('time to merge: ', performance.now() - start) // @todo remove\n  // start = performance.now()\n  resumeStructIntegration(transaction, store);\n  // console.log('time to integrate: ', performance.now() - start) // @todo remove\n  // start = performance.now()\n  cleanupPendingStructs(store.pendingClientsStructRefs);\n  // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n  // start = performance.now()\n  tryResumePendingDeleteReaders(transaction, store);\n  // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n  // start = performance.now()\n};\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {AbstractUpdateDecoder} [structDecoder]\n *\n * @function\n */\nconst readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    readStructs(structDecoder, transaction, ydoc.store);\n    readAndApplyDeleteSet(structDecoder, transaction, ydoc.store);\n  }, transactionOrigin, false);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new DefaultUpdateDecoder(decoder));\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nconst applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update);\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, DefaultUpdateDecoder);\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {AbstractUpdateEncoder} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nconst writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector);\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {AbstractUpdateEncoder} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdateV2 = (doc, encodedTargetStateVector, encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = encodedTargetStateVector == null ? new Map() : decodeStateVector(encodedTargetStateVector);\n  writeStateAsUpdate(encoder, doc, targetStateVector);\n  return encoder.toUint8Array()\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new DefaultUpdateEncoder());\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {AbstractDSDecoder} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst readStateVector = decoder => {\n  const ss = new Map();\n  const ssLength = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < ssLength; i++) {\n    const client = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const clock = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    ss.set(client, clock);\n  }\n  return ss\n};\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(decodedState)));\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst decodeStateVector = decodedState => readStateVector(new DefaultDSDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(decodedState)));\n\n/**\n * @param {AbstractDSEncoder} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nconst writeStateVector = (encoder, sv) => {\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, sv.size);\n  sv.forEach((clock, client) => {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, clock);\n  });\n  return encoder\n};\n\n/**\n * @param {AbstractDSEncoder} encoder\n * @param {Doc} doc\n *\n * @function\n */\nconst writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store));\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc} doc\n * @param {AbstractDSEncoder} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) => {\n  writeDocumentStateVector(encoder, doc);\n  return encoder.toUint8Array()\n};\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc} doc\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVector = doc => encodeStateVectorV2(doc, new DefaultDSEncoder());\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nclass EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = [];\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nconst createEventHandler = () => new EventHandler();\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nconst addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f);\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nconst removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l;\n  const len = l.length;\n  eventHandler.l = l.filter(g => f !== g);\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.');\n  }\n};\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nconst callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  (0,lib0_function_js__WEBPACK_IMPORTED_MODULE_10__.callAll)(eventHandler.l, [arg0, arg1]);\n\nclass ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client;\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock;\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock);\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nconst createID = (client, clock) => new ID(client, clock);\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nconst findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n};\n\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */\nconst isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true\n    }\n    child = /** @type {AbstractType<any>} */ (child.parent)._item;\n  }\n  return false\n};\n\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */\nconst logType = type => {\n  const res = [];\n  let n = type._start;\n  while (n) {\n    res.push(n);\n    n = n.right;\n  }\n  console.log('Children: ', res);\n  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content));\n};\n\nclass PermanentUserData {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor (doc, storeType = doc.getMap('users')) {\n    /**\n     * @type {Map<string,DeleteSet>}\n     */\n    const dss = new Map();\n    this.yusers = storeType;\n    this.doc = doc;\n    /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */\n    this.clients = new Map();\n    this.dss = dss;\n    /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */\n    const initUser = (user, userDescription) => {\n      /**\n       * @type {YArray<Uint8Array>}\n       */\n      const ds = user.get('ds');\n      const ids = user.get('ids');\n      const addClientId = /** @param {number} clientid */ clientid => this.clients.set(clientid, userDescription);\n      ds.observe(/** @param {YArrayEvent<any>} event */ event => {\n        event.changes.added.forEach(item => {\n          item.content.getContent().forEach(encodedDs => {\n            if (encodedDs instanceof Uint8Array) {\n              this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(encodedDs)))]));\n            }\n          });\n        });\n      });\n      this.dss.set(userDescription, mergeDeleteSets(ds.map(encodedDs => readDeleteSet(new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(encodedDs))))));\n      ids.observe(/** @param {YArrayEvent<any>} event */ event =>\n        event.changes.added.forEach(item => item.content.getContent().forEach(addClientId))\n      );\n      ids.forEach(addClientId);\n    };\n    // observe users\n    storeType.observe(event => {\n      event.keysChanged.forEach(userDescription =>\n        initUser(storeType.get(userDescription), userDescription)\n      );\n    });\n    // add intial data\n    storeType.forEach(initUser);\n  }\n\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} [conf]\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping (doc, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers;\n    let user = users.get(userDescription);\n    if (!user) {\n      user = new YMap();\n      user.set('ids', new YArray());\n      user.set('ds', new YArray());\n      users.set(userDescription, user);\n    }\n    user.get('ids').push([clientid]);\n    users.observe(event => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription);\n        if (userOverwrite !== user) {\n          // user was overwritten, port all data over to the next user object\n          // @todo Experiment with Y.Sets here\n          user = userOverwrite;\n          // @todo iterate over old type\n          this.clients.forEach((_userDescription, clientid) => {\n            if (userDescription === _userDescription) {\n              user.get('ids').push([clientid]);\n            }\n          });\n          const encoder = new DSEncoderV1();\n          const ds = this.dss.get(userDescription);\n          if (ds) {\n            writeDeleteSet(encoder, ds);\n            user.get('ds').push([encoder.toUint8Array()]);\n          }\n        }\n      }, 0);\n    });\n    doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      setTimeout(() => {\n        const yds = user.get('ds');\n        const ds = transaction.deleteSet;\n        if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n          const encoder = new DSEncoderV1();\n          writeDeleteSet(encoder, ds);\n          yds.push([encoder.toUint8Array()]);\n        }\n      });\n    });\n  }\n\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId (clientid) {\n    return this.clients.get(clientid) || null\n  }\n\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId (id) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id)) {\n        return userDescription\n      }\n    }\n    return null\n  }\n}\n\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */\nclass RelativePosition {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor (type, tname, item, assoc = 0) {\n    /**\n     * @type {ID|null}\n     */\n    this.type = type;\n    /**\n     * @type {string|null}\n     */\n    this.tname = tname;\n    /**\n     * @type {ID | null}\n     */\n    this.item = item;\n    /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the caharacter\n     * before the meant position.\n     *\n     * @type {number}\n     */\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock));\n\nclass AbsolutePosition {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor (type, index, assoc = 0) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n    /**\n     * @type {number}\n     */\n    this.index = index;\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */\nconst createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\n\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */\nconst createRelativePosition = (type, item, assoc) => {\n  let typeid = null;\n  let tname = null;\n  if (type._item === null) {\n    tname = findRootTypeKey(type);\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock);\n  }\n  return new RelativePosition(typeid, tname, item, assoc)\n};\n\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start;\n  if (assoc < 0) {\n    // associated to the left character or the beginning of a type, increment index if possible.\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc)\n    }\n    index--;\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        // case 1: found position somewhere in the linked list\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)\n      }\n      index -= t.length;\n    }\n    if (t.right === null && assoc < 0) {\n      // left-associated position, return last available id\n      return createRelativePosition(type, t.lastId, assoc)\n    }\n    t = t.right;\n  }\n  return createRelativePosition(type, null, assoc)\n};\n\n/**\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @return {AbsolutePosition|null}\n *\n * @function\n */\nconst createAbsolutePositionFromRelativePosition = (rpos, doc) => {\n  const store = doc.store;\n  const rightID = rpos.item;\n  const typeID = rpos.type;\n  const tname = rpos.tname;\n  const assoc = rpos.assoc;\n  let type = null;\n  let index = 0;\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null\n    }\n    const res = followRedone(store, rightID);\n    const right = res.item;\n    if (!(right instanceof Item)) {\n      return null\n    }\n    type = /** @type {AbstractType<any>} */ (right.parent);\n    if (type._item === null || !type._item.deleted) {\n      index = (right.deleted || !right.countable) ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)); // adjust position based on left association if necessary\n      let n = right.left;\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length;\n        }\n        n = n.left;\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc.get(tname);\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        // type does not exist yet\n        return null\n      }\n      const { item } = followRedone(store, typeID);\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type;\n      } else {\n        // struct is garbage collected\n        return null\n      }\n    } else {\n      throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n    }\n    if (assoc >= 0) {\n      index = type._length;\n    } else {\n      index = 0;\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc)\n};\n\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareRelativePositions = (a, b) => a === b || (\n  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc\n);\n\nclass Snapshot {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {DeleteSet}\n     */\n    this.ds = ds;\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv;\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nconst equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients;\n  const ds2 = snap2.ds.clients;\n  const sv1 = snap1.sv;\n  const sv2 = snap2.sv;\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || [];\n    if (dsitems1.length !== dsitems2.length) {\n      return false\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i];\n      const dsitem2 = dsitems2[i];\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false\n      }\n    }\n  }\n  return true\n};\n\n/**\n * @param {Snapshot} snapshot\n * @param {AbstractDSEncoder} [encoder]\n * @return {Uint8Array}\n */\nconst encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot.ds);\n  writeStateVector(encoder, snapshot.sv);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nconst encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new DefaultDSEncoder());\n\n/**\n * @param {Uint8Array} buf\n * @param {AbstractDSDecoder} [decoder]\n * @return {Snapshot}\n */\nconst decodeSnapshotV2 = (buf, decoder = new DSDecoderV2((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))\n};\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nconst decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(buf)));\n\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nconst createSnapshot = (ds, sm) => new Snapshot(ds, sm);\n\nconst emptySnapshot = createSnapshot(createDeleteSet(), new Map());\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nconst snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nconst isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : (\n  snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id)\n);\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nconst splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(transaction.meta, splitSnapshotAffectedStructs, lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create);\n  const store = transaction.doc.store;\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n    });\n    iterateDeletedStructs(transaction, snapshot.ds, item => {});\n    meta.add(snapshot);\n  }\n};\n\n/**\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nconst createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('originDoc must not be garbage collected')\n  }\n  const { sv, ds } = snapshot;\n\n  const encoder = new UpdateEncoderV2();\n  originDoc.transact(transaction => {\n    let size = 0;\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++;\n      }\n    });\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, size);\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n      const structs = originDoc.store.clients.get(client) || [];\n      const lastStructIndex = findIndexSS(structs, clock - 1);\n      // write # encoded structs\n      (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, lastStructIndex + 1);\n      encoder.writeClient(client);\n      // first clock written is 0\n      (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, 0);\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0);\n      }\n    }\n    writeDeleteSet(encoder, ds);\n  });\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');\n  return newDoc\n};\n\nclass StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map();\n    /**\n     * Store incompleted struct reads here\n     * `i` denotes to the next read operation\n     * We could shift the array of refs instead, but shift is incredible\n     * slow in Chrome for arrays with more than 100k elements\n     * @see tryResumePendingStructRefs\n     * @type {Map<number,{i:number,refs:Array<GC|Item>}>}\n     */\n    this.pendingClientsStructRefs = new Map();\n    /**\n     * Stack of pending structs waiting for struct dependencies\n     * Maximum length of stack is structReaders.size\n     * @type {Array<GC|Item>}\n     */\n    this.pendingStack = [];\n    /**\n     * @type {Array<DSDecoderV2>}\n     */\n    this.pendingDeleteReaders = [];\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nconst getStateVector = store => {\n  const sm = new Map();\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1];\n    sm.set(client, struct.id.clock + struct.length);\n  });\n  return sm\n};\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nconst getState = (store, client) => {\n  const structs = store.clients.get(client);\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1];\n  return lastStruct.id.clock + lastStruct.length\n};\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nconst addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client);\n  if (structs === undefined) {\n    structs = [];\n    store.clients.set(struct.id.client, structs);\n  } else {\n    const lastStruct = structs[structs.length - 1];\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n    }\n  }\n  structs.push(struct);\n};\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nconst findIndexSS = (structs, clock) => {\n  let left = 0;\n  let right = structs.length - 1;\n  let mid = structs[right];\n  let midclock = mid.id.clock;\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.floor)((clock / (midclock + mid.length - 1)) * right); // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex];\n    midclock = mid.id.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n    midindex = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.floor)((left + right) / 2);\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nconst find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  return structs[findIndexSS(structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nconst getItem = /** @type {function(StructStore,ID):Item} */ (find);\n\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nconst findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock);\n  const struct = structs[index];\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n    return index + 1\n  }\n  return index\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client));\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  const index = findIndexSS(structs, id.clock);\n  const struct = structs[index];\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));\n  }\n  return struct\n};\n\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nconst replaceStruct = (store, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (store.clients.get(struct.id.client));\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len;\n  let index = findIndexCleanStart(transaction, structs, clockStart);\n  let struct;\n  do {\n    struct = structs[index++];\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd);\n    }\n    f(struct);\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n};\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const map = y.define('map', YMap)\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * y.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nclass Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */\n    this.deleteSet = new DeleteSet();\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */\n    this.beforeState = getStateVector(doc.store);\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */\n    this.afterState = new Map();\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent>,Set<String|null>>}\n     */\n    this.changed = new Map();\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent>,Array<YEvent>>}\n     */\n    this.changedParentTypes = new Map();\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = [];\n    /**\n     * @type {any}\n     */\n    this.origin = origin;\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map();\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local;\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set();\n  }\n}\n\n/**\n * @param {AbstractUpdateEncoder} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nconst writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !(0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.any)(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet);\n  writeStructsFromTransaction(encoder, transaction);\n  writeDeleteSet(encoder, transaction.deleteSet);\n  return true\n};\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent>} type\n * @param {string|null} parentSub\n */\nconst addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item;\n  if (item === null || (item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted)) {\n    (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(transaction.changed, type, lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create).add(parentSub);\n  }\n};\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n */\nconst tryToMergeWithLeft = (structs, pos) => {\n  const left = structs[pos - 1];\n  const right = structs[pos];\n  if (left.deleted === right.deleted && left.constructor === right.constructor) {\n    if (left.mergeWith(right)) {\n      structs.splice(pos, 1);\n      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n        /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left));\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si];\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(store, false);\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */\nconst tryMergeDeleteSet = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiecy and so we don't miss any merge targets\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.min)(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[--si]\n      ) {\n        tryToMergeWithLeft(structs, si);\n      }\n    }\n  });\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter);\n  tryMergeDeleteSet(ds, store);\n};\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i];\n    const doc = transaction.doc;\n    const store = doc.store;\n    const ds = transaction.deleteSet;\n    const mergeStructs = transaction._mergeStructs;\n    try {\n      sortAndMergeDeleteSet(ds);\n      transaction.afterState = getStateVector(transaction.doc.store);\n      doc._transaction = null;\n      doc.emit('beforeObserverCalls', [transaction, doc]);\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = [];\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs);\n          }\n        })\n      );\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) =>\n          fs.push(() => {\n            // We need to think about the possibility that the user transforms the\n            // Y.Doc in the event.\n            if (type._item === null || !type._item.deleted) {\n              events = events\n                .filter(event =>\n                  event.target._item === null || !event.target._item.deleted\n                );\n              events\n                .forEach(event => {\n                  event.currentTarget = type;\n                });\n              // sort events by path length so that top-level events are fired first.\n              events\n                .sort((event1, event2) => event1.path.length - event2.path.length);\n              // We don't need to check for events.length\n              // because we know it has at least one element\n              callEventHandlerListeners(type._dEH, events, transaction);\n            }\n          })\n        );\n        fs.push(() => doc.emit('afterTransaction', [transaction, doc]));\n      });\n      (0,lib0_function_js__WEBPACK_IMPORTED_MODULE_10__.callAll)(fs, []);\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(ds, store, doc.gcFilter);\n      }\n      tryMergeDeleteSet(ds, store);\n\n      // on all affected store.clients props, try to merge\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0;\n        if (beforeClock !== clock) {\n          const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n          // we iterate from right to left so we can safely remove entries\n          const firstChangePos = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(findIndexSS(structs, beforeClock), 1);\n          for (let i = structs.length - 1; i >= firstChangePos; i--) {\n            tryToMergeWithLeft(structs, i);\n          }\n        }\n      });\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = 0; i < mergeStructs.length; i++) {\n        const { client, clock } = mergeStructs[i].id;\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n        const replacedStructPos = findIndexSS(structs, clock);\n        if (replacedStructPos + 1 < structs.length) {\n          tryToMergeWithLeft(structs, replacedStructPos + 1);\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLeft(structs, replacedStructPos);\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n        doc.clientID = generateNewClientId();\n        (0,lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.print)(lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.ORANGE, lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.BOLD, '[yjs] ', lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.UNBOLD, lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.RED, 'Changed the client-id because another client seems to be using it.');\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc]);\n      if (doc._observers.has('update')) {\n        const encoder = new DefaultUpdateEncoder();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      transaction.subdocsAdded.forEach(subdoc => doc.subdocs.add(subdoc));\n      transaction.subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc));\n\n      doc.emit('subdocs', [{ loaded: transaction.subdocsLoaded, added: transaction.subdocsAdded, removed: transaction.subdocsRemoved }]);\n      transaction.subdocsRemoved.forEach(subdoc => subdoc.destroy());\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = [];\n        doc.emit('afterAllTransactions', [doc, transactionCleanups]);\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1);\n      }\n    }\n  }\n};\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @param {Doc} doc\n * @param {function(Transaction):void} f\n * @param {any} [origin=true]\n *\n * @function\n */\nconst transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups;\n  let initialCall = false;\n  if (doc._transaction === null) {\n    initialCall = true;\n    doc._transaction = new Transaction(doc, origin, local);\n    transactionCleanups.push(doc._transaction);\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc]);\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc]);\n  }\n  try {\n    f(doc._transaction);\n  } finally {\n    if (initialCall && transactionCleanups[0] === doc._transaction) {\n      // The first transaction ended, now process observer calls.\n      // Observer call may create new transactions for which we need to call the observers and do cleanup.\n      // We don't want to nest these calls, so we execute these calls one after\n      // another.\n      // Also we need to ensure that all cleanups are called, even if the\n      // observes throw errors.\n      // This file is full of hacky try {} finally {} blocks to ensure that an\n      // event can throw errors and also that the cleanup is called.\n      cleanupTransactions(transactionCleanups, 0);\n    }\n  }\n};\n\nclass StackItem {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} beforeState\n   * @param {Map<number,number>} afterState\n   */\n  constructor (ds, beforeState, afterState) {\n    this.ds = ds;\n    this.beforeState = beforeState;\n    this.afterState = afterState;\n    /**\n     * Use this to save and restore metadata like selection range\n     */\n    this.meta = new Map();\n  }\n}\n\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {string} eventType\n * @return {StackItem?}\n */\nconst popStackItem = (undoManager, stack, eventType) => {\n  /**\n   * Whether a change happened\n   * @type {StackItem?}\n   */\n  let result = null;\n  const doc = undoManager.doc;\n  const scope = undoManager.scope;\n  transact(doc, transaction => {\n    while (stack.length > 0 && result === null) {\n      const store = doc.store;\n      const stackItem = /** @type {StackItem} */ (stack.pop());\n      /**\n       * @type {Set<Item>}\n       */\n      const itemsToRedo = new Set();\n      /**\n       * @type {Array<Item>}\n       */\n      const itemsToDelete = [];\n      let performedChange = false;\n      stackItem.afterState.forEach((endClock, client) => {\n        const startClock = stackItem.beforeState.get(client) || 0;\n        const len = endClock - startClock;\n        // @todo iterateStructs should not need the structs parameter\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n        if (startClock !== endClock) {\n          // make sure structs don't overlap with the range of created operations [stackItem.start, stackItem.start + stackItem.end)\n          // this must be executed before deleted structs are iterated.\n          getItemCleanStart(transaction, createID(client, startClock));\n          if (endClock < getState(doc.store, client)) {\n            getItemCleanStart(transaction, createID(client, endClock));\n          }\n          iterateStructs(transaction, structs, startClock, len, struct => {\n            if (struct instanceof Item) {\n              if (struct.redone !== null) {\n                let { item, diff } = followRedone(store, struct.id);\n                if (diff > 0) {\n                  item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n                }\n                if (item.length > len) {\n                  getItemCleanStart(transaction, createID(item.id.client, endClock));\n                }\n                struct = item;\n              }\n              if (!struct.deleted && scope.some(type => isParentOf(type, /** @type {Item} */ (struct)))) {\n                itemsToDelete.push(struct);\n              }\n            }\n          });\n        }\n      });\n      iterateDeletedStructs(transaction, stackItem.ds, struct => {\n        const id = struct.id;\n        const clock = id.clock;\n        const client = id.client;\n        const startClock = stackItem.beforeState.get(client) || 0;\n        const endClock = stackItem.afterState.get(client) || 0;\n        if (\n          struct instanceof Item &&\n          scope.some(type => isParentOf(type, struct)) &&\n          // Never redo structs in [stackItem.start, stackItem.start + stackItem.end) because they were created and deleted in the same capture interval.\n          !(clock >= startClock && clock < endClock)\n        ) {\n          itemsToRedo.add(struct);\n        }\n      });\n      itemsToRedo.forEach(struct => {\n        performedChange = redoItem(transaction, struct, itemsToRedo) !== null || performedChange;\n      });\n      // We want to delete in reverse order so that children are deleted before\n      // parents, so we have more information available when items are filtered.\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i];\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction);\n          performedChange = true;\n        }\n      }\n      result = stackItem;\n    }\n    transaction.changed.forEach((subProps, type) => {\n      // destroy search marker if necessary\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0;\n      }\n    });\n  }, undoManager);\n  if (result != null) {\n    undoManager.emit('stack-item-popped', [{ stackItem: result, type: eventType }, undoManager]);\n  }\n  return result\n};\n\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter whan an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n */\n\n/**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {Observable<'stack-item-added'|'stack-item-popped'>}\n */\nclass UndoManager extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */\n  constructor (typeScope, { captureTimeout = 500, deleteFilter = () => true, trackedOrigins = new Set([null]) } = {}) {\n    super();\n    this.scope = typeScope instanceof Array ? typeScope : [typeScope];\n    this.deleteFilter = deleteFilter;\n    trackedOrigins.add(this);\n    this.trackedOrigins = trackedOrigins;\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.undoStack = [];\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.redoStack = [];\n    /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */\n    this.undoing = false;\n    this.redoing = false;\n    this.doc = /** @type {Doc} */ (this.scope[0].doc);\n    this.lastChange = 0;\n    this.doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      // Only track certain transactions\n      if (!this.scope.some(type => transaction.changedParentTypes.has(type)) || (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))) {\n        return\n      }\n      const undoing = this.undoing;\n      const redoing = this.redoing;\n      const stack = undoing ? this.redoStack : this.undoStack;\n      if (undoing) {\n        this.stopCapturing(); // next undo should not be appended to last stack item\n      } else if (!redoing) {\n        // neither undoing nor redoing: delete redoStack\n        this.redoStack = [];\n      }\n      const beforeState = transaction.beforeState;\n      const afterState = transaction.afterState;\n      const now = (0,lib0_time_js__WEBPACK_IMPORTED_MODULE_13__.getUnixTime)();\n      if (now - this.lastChange < captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        // append change to last stack op\n        const lastOp = stack[stack.length - 1];\n        lastOp.ds = mergeDeleteSets([lastOp.ds, transaction.deleteSet]);\n        lastOp.afterState = afterState;\n      } else {\n        // create a new stack op\n        stack.push(new StackItem(transaction.deleteSet, beforeState, afterState));\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now;\n      }\n      // make sure that deleted structs are not gc'd\n      iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {\n        if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n          keepItem(item, true);\n        }\n      });\n      this.emit('stack-item-added', [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo' }, this]);\n    });\n  }\n\n  clear () {\n    this.doc.transact(transaction => {\n      /**\n       * @param {StackItem} stackItem\n       */\n      const clearItem = stackItem => {\n        iterateDeletedStructs(transaction, stackItem.ds, item => {\n          if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n            keepItem(item, false);\n          }\n        });\n      };\n      this.undoStack.forEach(clearItem);\n      this.redoStack.forEach(clearItem);\n    });\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing () {\n    this.lastChange = 0;\n  }\n\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo () {\n    this.undoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.undoStack, 'undo');\n    } finally {\n      this.undoing = false;\n    }\n    return res\n  }\n\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo () {\n    this.redoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.redoStack, 'redo');\n    } finally {\n      this.redoing = false;\n    }\n    return res\n  }\n}\n\n/**\n * YEvent describes the changes on a YType.\n */\nclass YEvent {\n  /**\n   * @param {AbstractType<any>} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor (target, transaction) {\n    /**\n     * The type on which this event was created on.\n     * @type {AbstractType<any>}\n     */\n    this.target = target;\n    /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */\n    this.currentTarget = target;\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction;\n    /**\n     * @type {Object|null}\n     */\n    this._changes = null;\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    // @ts-ignore _item is defined because target is integrated\n    return getPathTo(this.currentTarget, this.target)\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id)\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0)\n  }\n\n  /**\n   * @return {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert:Array<any>}|{delete:number}|{retain:number}>}}\n   */\n  get changes () {\n    let changes = this._changes;\n    if (changes === null) {\n      const target = this.target;\n      const added = (0,lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create)();\n      const deleted = (0,lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create)();\n      /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */\n      const delta = [];\n      /**\n       * @type {Map<string,{ action: 'add' | 'update' | 'delete', oldValue: any}>}\n       */\n      const keys = new Map();\n      changes = {\n        added, deleted, delta, keys\n      };\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      if (changed.has(null)) {\n        /**\n         * @type {any}\n         */\n        let lastOp = null;\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp);\n          }\n        };\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === undefined) {\n                packOp();\n                lastOp = { delete: 0 };\n              }\n              lastOp.delete += item.length;\n              deleted.add(item);\n            } // else nop\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === undefined) {\n                packOp();\n                lastOp = { insert: [] };\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent());\n              added.add(item);\n            } else {\n              if (lastOp === null || lastOp.retain === undefined) {\n                packOp();\n                lastOp = { retain: 0 };\n              }\n              lastOp.retain += item.length;\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === undefined) {\n          packOp();\n        }\n      }\n      changed.forEach(key => {\n        if (key !== null) {\n          const item = /** @type {Item} */ (target._map.get(key));\n          /**\n           * @type {'delete' | 'add' | 'update'}\n           */\n          let action;\n          let oldValue;\n          if (this.adds(item)) {\n            let prev = item.left;\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left;\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'delete';\n                oldValue = (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.last)(prev.content.getContent());\n              } else {\n                return\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'update';\n                oldValue = (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.last)(prev.content.getContent());\n              } else {\n                action = 'add';\n                oldValue = undefined;\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = 'delete';\n              oldValue = (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.last)(/** @type {Item} */ item.content.getContent());\n            } else {\n              return // nop\n            }\n          }\n          keys.set(key, { action, oldValue });\n        }\n      });\n      this._changes = changes;\n    }\n    return /** @type {any} */ (changes)\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nconst getPathTo = (parent, child) => {\n  const path = [];\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub);\n    } else {\n      // parent is array-ish\n      let i = 0;\n      let c = /** @type {AbstractType<any>} */ (child._item.parent)._start;\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++;\n        }\n        c = c.right;\n      }\n      path.unshift(i);\n    }\n    child = /** @type {AbstractType<any>} */ (child._item.parent);\n  }\n  return path\n};\n\nconst maxSearchMarker = 80;\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0;\n\nclass ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true;\n    this.p = p;\n    this.index = index;\n    this.timestamp = globalSearchMarkerTimestamp++;\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++; };\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false;\n  marker.p = p;\n  p.marker = true;\n  marker.index = index;\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n    overwriteMarker(marker, p, index);\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index);\n    searchMarker.push(pm);\n    return pm\n  }\n};\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */\nconst findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(index - a.index) < (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(index - b.index) ? a : b);\n  let p = yarray._start;\n  let pindex = 0;\n  if (marker !== null) {\n    p = marker.p;\n    pindex = marker.index;\n    refreshMarkerTimestamp(marker); // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length;\n    }\n    p = p.right;\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengthes == null) {\n  //     window.lengthes = []\n  //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)\n  //   }\n  //   window.lengthes.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(marker.index - pindex) < /** @type {YText|YArray<any>} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex);\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n};\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nconst updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i];\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p;\n      p.marker = false;\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left;\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length;\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1);\n        continue\n      }\n      m.p = p;\n      p.marker = true;\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(index, m.index + len);\n    }\n  }\n};\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */\nconst getTypeChildren = t => {\n  let s = t._start;\n  const arr = [];\n  while (s) {\n    arr.push(s);\n    s = s.right;\n  }\n  return arr\n};\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */\nconst callTypeObservers = (type, transaction, event) => {\n  const changedType = type;\n  const changedParentTypes = transaction.changedParentTypes;\n  while (true) {\n    // @ts-ignore\n    (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(changedParentTypes, type, () => []).push(event);\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {AbstractType<any>} */ (type._item.parent);\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction);\n};\n\n/**\n * @template EventType\n * Abstract Yjs Type class\n */\nclass AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null;\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map();\n    /**\n     * @type {Item|null}\n     */\n    this._start = null;\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null;\n    this._length = 0;\n    /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */\n    this._eH = createEventHandler();\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent>,Transaction>}\n     */\n    this._dEH = createEventHandler();\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null;\n  }\n\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent () {\n    return this._item ? /** @type {AbstractType<any>} */ (this._item.parent) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y;\n    this._item = item;\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy () {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone () {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   */\n  _write (encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0;\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start;\n  }\n  if (end < 0) {\n    end = type._length + end;\n  }\n  let len = end - start;\n  const cs = [];\n  let n = type._start;\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      if (c.length <= start) {\n        start -= c.length;\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i]);\n          len--;\n        }\n        start = 0;\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArray = type => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArraySnapshot = (type, snapshot) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nconst typeListForEach = (type, f) => {\n  let index = 0;\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type);\n      }\n    }\n    n = n.right;\n  }\n};\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nconst typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = [];\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type));\n  });\n  return result\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nconst typeListCreateIterator = type => {\n  let n = type._start;\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null;\n  let currentContentIndex = 0;\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right;\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent();\n        currentContentIndex = 0;\n        n = n.right; // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++];\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null;\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nconst typeListGet = (type, index) => {\n  const marker = findMarker(type, index);\n  let n = type._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length;\n    }\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const store = doc.store;\n  const right = referenceItem === null ? parent._start : referenceItem.right;\n  /**\n   * @type {Array<Object|Array<any>|number>}\n   */\n  let jsonContent = [];\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n      left.integrate(transaction, 0);\n      jsonContent = [];\n    }\n  };\n  content.forEach(c => {\n    switch (c.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        jsonContent.push(c);\n        break\n      default:\n        packJsonContent();\n        switch (c.constructor) {\n          case Uint8Array:\n          case ArrayBuffer:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))));\n            left.integrate(transaction, 0);\n            break\n          case Doc:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)));\n            left.integrate(transaction, 0);\n            break\n          default:\n            if (c instanceof AbstractType) {\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n              left.integrate(transaction, 0);\n            } else {\n              throw new Error('Unexpected content type in insert operation')\n            }\n        }\n    }\n  });\n  packJsonContent();\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev; // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0;\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        break\n      }\n      index -= n.length;\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nconst typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index;\n  const startLength = length;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n      }\n      index -= n.length;\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));\n      }\n      n.delete(transaction);\n      length -= n.length;\n    }\n    n = n.right;\n  }\n  if (length > 0) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.create)('array length exceeded')\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nconst typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key);\n  if (c !== undefined) {\n    c.delete(transaction);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */\nconst typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let content;\n  if (value == null) {\n    content = new ContentAny([value]);\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value]);\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value));\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value));\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value);\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGet = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nconst typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {};\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1];\n    }\n  });\n  return res\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst typeMapHas = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null;\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left;\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n};\n\n/**\n * @param {Map<string,Item>} map\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nconst createMapIterator = map => (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorFilter)(map.entries(), /** @param {any} entry */ entry => !entry[1].deleted);\n\n/**\n * @module YArray\n */\n\n/**\n * Event that describes the changes on a YArray\n * @template T\n */\nclass YArrayEvent extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor (yarray, transaction) {\n    super(yarray, transaction);\n    this._transaction = transaction;\n  }\n}\n\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YArray extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    const a = new YArray();\n    a.push(items);\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YArray()\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  clone () {\n    const arr = new YArray();\n    arr.insert(0, this.toArray().map(el =>\n      el instanceof AbstractType ? el.clone() : el\n    ));\n    return arr\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length);\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template T,M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function on once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f);\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID);\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n *\n * @private\n * @function\n */\nconst readYArray = decoder => new YArray();\n\n/**\n * @template T\n * Event that describes the changes on a YMap.\n */\nclass YMapEvent extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor (ymap, transaction, subs) {\n    super(ymap, transaction);\n    this.keysChanged = subs;\n  }\n}\n\n/**\n * @template T number|string|Object|Array|Uint8Array\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super();\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null;\n\n    if (entries === undefined) {\n      this._prelimContent = new Map();\n    } else {\n      this._prelimContent = new Map(entries);\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value);\n    });\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YMap()\n  }\n\n  /**\n   * @return {YMap<T>}\n   */\n  clone () {\n    const map = new YMap();\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? value.clone() : value);\n    });\n    return map\n  }\n\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,T>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1];\n        map[key] = v instanceof AbstractType ? v.toJSON() : v;\n      }\n    });\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this._map)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorMap)(createMapIterator(this._map), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values () {\n    return (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorMap)(createMapIterator(this._map), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries () {\n    return (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorMap)(createMapIterator(this._map), /** @param {any} v */ v => [v[0], v[1].content.getContent()[v[1].length - 1]])\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(T,string,YMap<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this);\n      }\n    });\n    return map\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key);\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {T} value The value of the element to add\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, value);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value);\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {T|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID);\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n *\n * @private\n * @function\n */\nconst readYMap = decoder => new YMap();\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && (0,lib0_object_js__WEBPACK_IMPORTED_MODULE_15__.equalFlat)(a, b));\n\nclass ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor (left, right, index, currentAttributes) {\n    this.left = left;\n    this.right = right;\n    this.index = index;\n    this.currentAttributes = currentAttributes;\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n    }\n    switch (this.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!this.right.deleted) {\n          this.index += this.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content));\n        }\n        break\n    }\n    this.left = this.right;\n    this.right = this.right.right;\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n          }\n          pos.index += pos.right.length;\n          count -= pos.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content));\n        }\n        break\n    }\n    pos.left = pos.right;\n    pos.right = pos.right.right;\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index) => {\n  const currentAttributes = new Map();\n  const marker = findMarker(parent, index);\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n    return findNextPosition(transaction, pos, index)\n  }\n};\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      currPos.right.deleted === true || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key);\n    }\n    currPos.forward();\n  }\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let left = currPos.left;\n  const right = currPos.right;\n  negatedAttributes.forEach((val, key) => {\n    left = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n    left.integrate(transaction, 0);\n    currPos.currentAttributes.set(key, val);\n    updateCurrentAttributes(currPos.currentAttributes, /** @type {ContentFormat} */ (left.content));\n  });\n};\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format;\n  if (value === null) {\n    currentAttributes.delete(key);\n  } else {\n    currentAttributes.set(key, value);\n  }\n};\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] || null, /** @type {ContentFormat} */ (currPos.right.content).value))) ; else {\n      break\n    }\n    currPos.forward();\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const negatedAttributes = new Map();\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key];\n    const currentVal = currPos.currentAttributes.get(key) || null;\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal);\n      const { left, right } = currPos;\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n  }\n  return negatedAttributes\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nconst insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null;\n    }\n  });\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : new ContentEmbed(text);\n  let { left, right, index } = currPos;\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n  right.integrate(transaction, 0);\n  currPos.right = right;\n  currPos.index = index;\n  currPos.forward();\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst formatText = (transaction, parent, currPos, length, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // iterate until first non-format or null is found\n  // delete all formats with attributes[format.key] != null\n  while (length > 0 && currPos.right !== null) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (currPos.right.content);\n          const attr = attributes[key];\n          if (attr !== undefined) {\n            if (equalAttrs(attr, value)) {\n              negatedAttributes.delete(key);\n            } else {\n              negatedAttributes.set(key, value);\n            }\n            currPos.right.delete(transaction);\n          }\n          break\n        }\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          break\n      }\n    }\n    currPos.forward();\n  }\n  // Quill just assumes that the editor starts with a newline and that it always\n  // ends with a newline. We only insert that newline when a new newline is\n  // inserted - i.e when length is bigger than type.length\n  if (length > 0) {\n    let newlines = '';\n    for (; length > 0; length--) {\n      newlines += '\\n';\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n    currPos.right.integrate(transaction, 0);\n    currPos.forward();\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} end exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} endAttributes This attribute is modified!\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, end, startAttributes, endAttributes) => {\n  while (end && end.content.constructor !== ContentString && end.content.constructor !== ContentEmbed) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      updateCurrentAttributes(endAttributes, /** @type {ContentFormat} */ (end.content));\n    }\n    end = end.right;\n  }\n  let cleanups = 0;\n  while (start !== end) {\n    if (!start.deleted) {\n      const content = start.content;\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content);\n          if ((endAttributes.get(key) || null) !== value || (startAttributes.get(key) || null) === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction);\n            cleanups++;\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right);\n  }\n  return cleanups\n};\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || (item.right.content.constructor !== ContentString && item.right.content.constructor !== ContentEmbed))) {\n    item = item.right;\n  }\n  const attrs = new Set();\n  // iterate back until a content item is found\n  while (item && (item.deleted || (item.content.constructor !== ContentString && item.content.constructor !== ContentEmbed))) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key;\n      if (attrs.has(key)) {\n        item.delete(transaction);\n      } else {\n        attrs.add(key);\n      }\n    }\n    item = item.left;\n  }\n};\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nconst cleanupYTextFormatting = type => {\n  let res = 0;\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start);\n    let end = type._start;\n    let startAttributes = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.create)();\n    const currentAttributes = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(startAttributes);\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content));\n            break\n          case ContentEmbed:\n          case ContentString:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n            startAttributes = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(currentAttributes);\n            start = end;\n            break\n        }\n      }\n      end = end.right;\n    }\n  });\n  return res\n};\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst deleteText = (transaction, currPos, length) => {\n  const startLength = length;\n  const startAttrs = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(currPos.currentAttributes);\n  const start = currPos.right;\n  while (length > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          currPos.right.delete(transaction);\n          break\n      }\n    }\n    currPos.forward();\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(currPos.currentAttributes));\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);\n  }\n  return currPos\n};\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * @typedef {Object} DeltaItem\n * @property {number|undefined} DeltaItem.delete\n * @property {number|undefined} DeltaItem.retain\n * @property {string|undefined} DeltaItem.insert\n * @property {Object<string,any>} DeltaItem.attributes\n */\n\n/**\n * Event that describes the changes on a YText type.\n */\nclass YTextEvent extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor (ytext, transaction, subs) {\n    super(ytext, transaction);\n    /**\n     * @type {Array<DeltaItem>|null}\n     */\n    this._delta = null;\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.keysChanged.add(sub);\n      }\n    });\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<DeltaItem>}\n   *\n   * @public\n   */\n  get delta () {\n    if (this._delta === null) {\n      const y = /** @type {Doc} */ (this.target.doc);\n      this._delta = [];\n      transact(y, transaction => {\n        const delta = /** @type {Array<DeltaItem>} */ (this._delta);\n        const currentAttributes = new Map(); // saves all current attributes for insert\n        const oldAttributes = new Map();\n        let item = this.target._start;\n        /**\n         * @type {string?}\n         */\n        let action = null;\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {}; // counts added or removed new attributes for retain\n        /**\n         * @type {string|object}\n         */\n        let insert = '';\n        let retain = 0;\n        let deleteLen = 0;\n        const addOp = () => {\n          if (action !== null) {\n            /**\n             * @type {any}\n             */\n            let op;\n            switch (action) {\n              case 'delete':\n                op = { delete: deleteLen };\n                deleteLen = 0;\n                break\n              case 'insert':\n                op = { insert };\n                if (currentAttributes.size > 0) {\n                  op.attributes = {};\n                  currentAttributes.forEach((value, key) => {\n                    if (value !== null) {\n                      op.attributes[key] = value;\n                    }\n                  });\n                }\n                insert = '';\n                break\n              case 'retain':\n                op = { retain };\n                if (Object.keys(attributes).length > 0) {\n                  op.attributes = {};\n                  for (const key in attributes) {\n                    op.attributes[key] = attributes[key];\n                  }\n                }\n                retain = 0;\n                break\n            }\n            delta.push(op);\n            action = null;\n          }\n        };\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp();\n                  action = 'insert';\n                  insert = /** @type {ContentEmbed} */ (item.content).embed;\n                  addOp();\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += 1;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += 1;\n              }\n              break\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== 'insert') {\n                    addOp();\n                    action = 'insert';\n                  }\n                  insert += /** @type {ContentString} */ (item.content).str;\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += item.length;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += item.length;\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (item.content);\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (equalAttrs(value, (oldAttributes.get(key) || null))) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value);\n                const curVal = currentAttributes.get(key) || null;\n                if (!equalAttrs(curVal, value)) {\n                  if (action === 'retain') {\n                    addOp();\n                  }\n                  attributes[key] = curVal;\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value);\n                const attr = attributes[key];\n                if (attr !== undefined) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (value === null) {\n                      attributes[key] = value;\n                    } else {\n                      delete attributes[key];\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === 'insert') {\n                  addOp();\n                }\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content));\n              }\n              break\n            }\n          }\n          item = item.right;\n        }\n        addOp();\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1];\n          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n            // retain delta's if they don't assign attributes\n            delta.pop();\n          } else {\n            break\n          }\n        }\n      });\n    }\n    return this._delta\n  }\n}\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */\nclass YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super();\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f());\n    } catch (e) {\n      console.error(e);\n    }\n    this._pending = null;\n  }\n\n  _copy () {\n    return new YText()\n  }\n\n  /**\n   * @return {YText}\n   */\n  clone () {\n    const text = new YText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    const event = new YTextEvent(this, transaction, parentSubs);\n    const doc = transaction.doc;\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local) {\n      // check if another formatting item was inserted\n      let foundFormattingItem = false;\n      for (const [client, afterClock] of transaction.afterState.entries()) {\n        const clock = transaction.beforeState.get(client) || 0;\n        if (afterClock === clock) {\n          continue\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ (doc.store.clients.get(client)), clock, afterClock, item => {\n          if (!item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n        if (foundFormattingItem) {\n          break\n        }\n      }\n      if (!foundFormattingItem) {\n        iterateDeletedStructs(transaction, transaction.deleteSet, item => {\n          if (item instanceof GC || foundFormattingItem) {\n            return\n          }\n          if (item.parent === this && item.content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n      }\n      transact(doc, (t) => {\n        if (foundFormattingItem) {\n          // If a formatting item was inserted, we simply clean the whole type.\n          // We need to compute currentAttributes for the current position anyway.\n          cleanupYTextFormatting(this);\n        } else {\n          // If no formatting attribute was inserted, we can make due with contextless\n          // formatting cleanups.\n          // Contextless: it is not necessary to compute currentAttributes for the affected position.\n          iterateDeletedStructs(t, t.deleteSet, item => {\n            if (item instanceof GC) {\n              return\n            }\n            if (item.parent === this) {\n              cleanupContextlessFormattingGap(t, item);\n            }\n          });\n        }\n      });\n    }\n    callTypeObservers(this, transaction, event);\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    let str = '';\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start;\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str;\n      }\n      n = n.right;\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  [opts]\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta (delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map());\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i];\n          if (op.insert !== undefined) {\n            // Quill assumes that the content starts with an empty paragraph.\n            // Yjs/Y.Text assumes that it starts empty. We always hide that\n            // there is a newline at the end of the content.\n            // If we omit this step, clients will see a different number of\n            // paragraphs, but nothing bad will happen.\n            const ins = (!sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\\n') ? op.insert.slice(0, -1) : op.insert;\n            if (typeof ins !== 'string' || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {});\n            }\n          } else if (op.retain !== undefined) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {});\n          } else if (op.delete !== undefined) {\n            deleteText(transaction, currPos, op.delete);\n          }\n        }\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.applyDelta(delta));\n    }\n  }\n\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta (snapshot, prevSnapshot, computeYChange) {\n    /**\n     * @type{Array<any>}\n     */\n    const ops = [];\n    const currentAttributes = new Map();\n    const doc = /** @type {Doc} */ (this.doc);\n    let str = '';\n    let n = this._start;\n    function packStr () {\n      if (str.length > 0) {\n        // pack str with attributes to ops\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {};\n        let addAttributes = false;\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true;\n          attributes[key] = value;\n        });\n        /**\n         * @type {Object<string,any>}\n         */\n        const op = { insert: str };\n        if (addAttributes) {\n          op.attributes = attributes;\n        }\n        ops.push(op);\n        str = '';\n      }\n    }\n    // snapshots are merged again after the transaction, so we need to keep the\n    // transalive until we are done\n    transact(doc, transaction => {\n      if (snapshot) {\n        splitSnapshotAffectedStructs(transaction, snapshot);\n      }\n      if (prevSnapshot) {\n        splitSnapshotAffectedStructs(transaction, prevSnapshot);\n      }\n      while (n !== null) {\n        if (isVisible(n, snapshot) || (prevSnapshot !== undefined && isVisible(n, prevSnapshot))) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get('ychange');\n              if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'removed') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' });\n                }\n              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'added') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' });\n                }\n              } else if (cur !== undefined) {\n                packStr();\n                currentAttributes.delete('ychange');\n              }\n              str += /** @type {ContentString} */ (n.content).str;\n              break\n            }\n            case ContentEmbed: {\n              packStr();\n              /**\n               * @type {Object<string,any>}\n               */\n              const op = {\n                insert: /** @type {ContentEmbed} */ (n.content).embed\n              };\n              if (currentAttributes.size > 0) {\n                const attrs = /** @type {Object<string,any>} */ ({});\n                op.attributes = attrs;\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value;\n                });\n              }\n              ops.push(op);\n              break\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot)) {\n                packStr();\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content));\n              }\n              break\n          }\n        }\n        n = n.right;\n      }\n      packStr();\n    }, splitSnapshotAffectedStructs);\n    return ops\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (!attributes) {\n          attributes = {};\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v; });\n        }\n        insertText(transaction, this, pos, text, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes));\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes = {}) {\n    if (embed.constructor !== Object) {\n      throw new Error('Embed must be an Object')\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        insertText(transaction, this, pos, embed, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes));\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index), length);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length));\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (pos.right === null) {\n          return\n        }\n        formatText(transaction, this, pos, length, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes));\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName));\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue));\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID);\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n * @return {YText}\n *\n * @private\n * @function\n */\nconst readYText = decoder => new YText();\n\n/**\n * @module YXml\n */\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */\nclass YXmlTreeWalker {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor (root, f = () => true) {\n    this._filter = f;\n    this._root = root;\n    /**\n     * @type {Item}\n     */\n    this._currentNode = /** @type {Item} */ (root._start);\n    this._firstCall = true;\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next () {\n    /**\n     * @type {Item|null}\n     */\n    let n = this._currentNode;\n    let type = /** @type {any} */ (n.content).type;\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item\n      do {\n        type = /** @type {any} */ (n.content).type;\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          // walk down in the tree\n          n = type._start;\n        } else {\n          // walk right or up in the tree\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right;\n              break\n            } else if (n.parent === this._root) {\n              n = null;\n            } else {\n              n = /** @type {AbstractType<any>} */ (n.parent)._item;\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))\n    }\n    this._firstCall = false;\n    if (n === null) {\n      // @ts-ignore\n      return { value: undefined, done: true }\n    }\n    this._currentNode = n;\n    return { value: /** @type {any} */ (n.content).type, done: false }\n  }\n}\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */\nclass YXmlFragment extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = [];\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first;\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YXmlFragment()\n  }\n\n  /**\n   * @return {YXmlFragment}\n   */\n  clone () {\n    const el = new YXmlFragment();\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query);\n    const next = iterator.next();\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    return Array.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query))\n  }\n\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment();\n    if (binding !== undefined) {\n      binding._createAssociation(fragment, this);\n    }\n    typeListForEach(this, xmlType => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n    });\n    return fragment\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref;\n        typeListInsertGenericsAfter(transaction, this, refItem, content);\n      });\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent);\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1;\n      if (index === 0 && ref !== null) {\n        throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.create)('Reference item not found')\n      }\n      pc.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length);\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {AbstractUpdateEncoder} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID);\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */\nconst readYXmlFragment = decoder => new YXmlFragment();\n\n/**\n * An YXmlElement imitates the behavior of a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n */\nclass YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super();\n    this.nodeName = nodeName;\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map();\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value);\n    });\n    this._prelimAttrs = null;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy () {\n    return new YXmlElement(this.nodeName)\n  }\n\n  /**\n   * @return {YXmlElement}\n   */\n  clone () {\n    const el = new YXmlElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      el.setAttribute(key, attrs[key]);\n    }\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes();\n    const stringBuilder = [];\n    const keys = [];\n    for (const key in attrs) {\n      keys.push(key);\n    }\n    keys.sort();\n    const keysLen = keys.length;\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i];\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase();\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName);\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {String} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue);\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {String} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      dom.setAttribute(key, attrs[key]);\n    }\n    typeListForEach(this, yxml => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding));\n    });\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {AbstractUpdateEncoder} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID);\n    encoder.writeKey(this.nodeName);\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n * @return {YXmlElement}\n *\n * @function\n */\nconst readYXmlElement = decoder => new YXmlElement(decoder.readKey());\n\n/**\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */\nclass YXmlEvent extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor (target, subs, transaction) {\n    super(target, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.attributesChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.attributesChanged.add(sub);\n      }\n    });\n  }\n}\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nclass YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super();\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy () {\n    return new YXmlHook(this.hookName)\n  }\n\n  /**\n   * @return {YXmlHook}\n   */\n  clone () {\n    const el = new YXmlHook(this.hookName);\n    this.forEach((value, key) => {\n      el.set(key, value);\n    });\n    return el\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName];\n    let dom;\n    if (hook !== undefined) {\n      dom = hook.createDom(this);\n    } else {\n      dom = document.createElement(this.hookName);\n    }\n    dom.setAttribute('data-yjs-hook', this.hookName);\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {AbstractUpdateEncoder} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID);\n    encoder.writeKey(this.hookName);\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */\nconst readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey());\n\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */\nclass YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  _copy () {\n    return new YXmlText()\n  }\n\n  /**\n   * @return {YXmlText}\n   */\n  clone () {\n    const text = new YXmlText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString());\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  toString () {\n    // @ts-ignore\n    return this.toDelta().map(delta => {\n      const nestedNodes = [];\n      for (const nodeName in delta.attributes) {\n        const attrs = [];\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] });\n        }\n        // sort attributes to get a unique order\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n        nestedNodes.push({ nodeName, attrs });\n      }\n      // sort node order to get a unique order\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n      // now convert to dom string\n      let str = '';\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i];\n        str += `<${node.nodeName}`;\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j];\n          str += ` ${attr.key}=\"${attr.value}\"`;\n        }\n        str += '>';\n      }\n      str += delta.insert;\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`;\n      }\n      return str\n    }).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID);\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */\nconst readYXmlText = decoder => new YXmlText();\n\nclass AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id;\n    this.length = length;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {AbstractUpdateEncoder} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n}\n\nconst structGCRefNumber = 0;\n\n/**\n * @private\n */\nclass GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.length -= offset;\n    }\n    addStruct(transaction.doc.store, this);\n  }\n\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structGCRefNumber);\n    encoder.writeLen(this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\nclass ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeBuf(this.content);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n * @return {ContentBinary}\n */\nconst readContentBinary = decoder => new ContentBinary(decoder.readBuf());\n\nclass ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset);\n    this.len = offset;\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n    item.markDeleted();\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeLen(this.len - offset);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {AbstractUpdateDecoder} decoder\n * @return {ContentDeleted}\n */\nconst readContentDeleted = decoder => new ContentDeleted(decoder.readLen());\n\n/**\n * @private\n */\nclass ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * @type {any}\n     */\n    const opts = {};\n    this.opts = opts;\n    if (!doc.gc) {\n      opts.gc = false;\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true;\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta;\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(this.doc)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item;\n    transaction.subdocsAdded.add(this.doc);\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc);\n    } else {\n      transaction.subdocsRemoved.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) { }\n\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(this.doc.guid);\n    encoder.writeAny(this.opts);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {AbstractUpdateDecoder} decoder\n * @return {ContentDoc}\n */\nconst readContentDoc = decoder => new ContentDoc(new Doc({ guid: decoder.readString(), ...decoder.readAny() }));\n\n/**\n * @private\n */\nclass ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeJSON(this.embed);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {AbstractUpdateDecoder} decoder\n * @return {ContentEmbed}\n */\nconst readContentEmbed = decoder => new ContentEmbed(decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentFormat}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentFormat} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    /** @type {AbstractType<any>} */ (item.parent)._searchMarker = null;\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeKey(this.key);\n    encoder.writeJSON(this.value);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n * @return {ContentFormat}\n */\nconst readContentFormat = decoder => new ContentFormat(decoder.readString(), decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {AbstractUpdateDecoder} decoder\n * @return {ContentJSON}\n */\nconst readContentJSON = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString();\n    if (c === 'undefined') {\n      cs.push(undefined);\n    } else {\n      cs.push(JSON.parse(c));\n    }\n  }\n  return new ContentJSON(cs)\n};\n\nclass ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeAny(c);\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n * @return {ContentAny}\n */\nconst readContentAny = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny());\n  }\n  return new ContentAny(cs)\n};\n\n/**\n * @private\n */\nclass ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset));\n    this.str = this.str.slice(0, offset);\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1);\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character (� / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + '�';\n      // replace right as well\n      right.str = '�' + right.str.slice(1);\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {AbstractUpdateDecoder} decoder\n * @return {ContentString}\n */\nconst readContentString = decoder => new ContentString(decoder.readString());\n\n/**\n * @type {Array<function(AbstractUpdateDecoder):AbstractType<any>>}\n * @private\n */\nconst typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n];\n\nconst YArrayRefID = 0;\nconst YMapRefID = 1;\nconst YTextRefID = 2;\nconst YXmlElementRefID = 3;\nconst YXmlFragmentRefID = 4;\nconst YXmlHookRefID = 5;\nconst YXmlTextRefID = 6;\n\n/**\n * @private\n */\nclass ContentType {\n  /**\n   * @param {AbstractType<YEvent>} type\n   */\n  constructor (type) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start;\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // Whis will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item);\n      }\n      item = item.right;\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // same as above\n        transaction._mergeStructs.push(item);\n      }\n    });\n    transaction.changed.delete(this.type);\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    let item = this.type._start;\n    while (item !== null) {\n      item.gc(store, true);\n      item = item.right;\n    }\n    this.type._start = null;\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(store, true);\n        item = item.left;\n      }\n    });\n    this.type._map = new Map();\n  }\n\n  /**\n   * @param {AbstractUpdateEncoder} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    this.type._write(encoder);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {AbstractUpdateDecoder} decoder\n * @return {ContentType}\n */\nconst readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nconst followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id;\n  let diff = 0;\n  let item;\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff);\n    }\n    item = getItem(store, nextID);\n    diff = nextID.clock - item.id.clock;\n    nextID = item.redone;\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n};\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nconst keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep;\n    item = /** @type {AbstractType<any>} */ (item.parent)._item;\n  }\n};\n\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nconst splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id;\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  );\n  if (leftItem.deleted) {\n    rightItem.markDeleted();\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true;\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n  }\n  // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n  leftItem.right = rightItem;\n  // update right\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem;\n  }\n  // right is more specific.\n  transaction._mergeStructs.push(rightItem);\n  // update parent._map\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    /** @type {AbstractType<any>} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem);\n  }\n  leftItem.length = diff;\n  return rightItem\n};\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n *\n * @return {Item|null}\n *\n * @private\n */\nconst redoItem = (transaction, item, redoitems) => {\n  const doc = transaction.doc;\n  const store = doc.store;\n  const ownClientID = doc.clientID;\n  const redone = item.redone;\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {AbstractType<any>} */ (item.parent)._item;\n  /**\n   * @type {Item|null}\n   */\n  let left;\n  /**\n   * @type {Item|null}\n   */\n  let right;\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left;\n    right = item;\n  } else {\n    // Is a map item. Insert as current value\n    left = item;\n    while (left.right !== null) {\n      left = left.right;\n      if (left.id.client !== ownClientID) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    }\n    if (left.right !== null) {\n      left = /** @type {Item} */ (/** @type {AbstractType<any>} */ (item.parent)._map.get(item.parentSub));\n    }\n    right = null;\n  }\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true && parentItem.redone === null) {\n    // try to undo parent if it will be undone anyway\n    if (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems) === null) {\n      return null\n    }\n  }\n  if (parentItem !== null && parentItem.redone !== null) {\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone);\n    }\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left;\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace;\n        break\n      }\n      left = left.left;\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right;\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace;\n        break\n      }\n      right = right.right;\n    }\n  }\n  const nextClock = getState(store, ownClientID);\n  const nextId = createID(ownClientID, nextClock);\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentItem === null ? item.parent : /** @type {ContentType} */ (parentItem.content).type,\n    item.parentSub,\n    item.content.copy()\n  );\n  item.redone = nextId;\n  keepItem(redoneItem, true);\n  redoneItem.integrate(transaction, 0);\n  return redoneItem\n};\n\n/**\n * Abstract class that represents any content.\n */\nclass Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength());\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin;\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left;\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right;\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin;\n    /**\n     * @type {AbstractType<any>|ID|null}\n     */\n    this.parent = parent;\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub;\n    /**\n     * If this type's effect is reundone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null;\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content;\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT2 : 0;\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT4) > 0) !== isMarked) {\n      this.info ^= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT4;\n    }\n  }\n\n  get marker () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT1;\n    }\n  }\n\n  get countable () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT3;\n    }\n  }\n\n  markDeleted () {\n    this.info |= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT3;\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client\n    }\n\n    // We have all missing ids, now find the items\n\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin);\n      this.origin = this.left.lastId;\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin);\n      this.rightOrigin = this.right.id;\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null;\n    }\n    // only set parent if this shouldn't be garbage collected\n    if (!this.parent) {\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent;\n        this.parentSub = this.left.parentSub;\n      }\n      if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent;\n        this.parentSub = this.right.parentSub;\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent);\n      if (parentItem.constructor === GC) {\n        this.parent = null;\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type;\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n      this.origin = this.left.lastId;\n      this.content = this.content.splice(offset);\n      this.length -= offset;\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left;\n\n        /**\n         * @type {Item|null}\n         */\n        let o;\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right;\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (o !== null && o.left !== null) {\n            o = o.left;\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start;\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set();\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set();\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o);\n          conflictingItems.add(o);\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o;\n              conflictingItems.clear();\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o;\n              conflictingItems.clear();\n            }\n          } else {\n            break\n          }\n          o = o.right;\n        }\n        this.left = left;\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right;\n        this.right = right;\n        this.left.right = this;\n      } else {\n        let r;\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (r !== null && r.left !== null) {\n            r = r.left;\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this;\n        }\n        this.right = r;\n      }\n      if (this.right !== null) {\n        this.right.left = this;\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this);\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction);\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length;\n      }\n      addStruct(transaction.doc.store, this);\n      this.content.integrate(transaction, this);\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub);\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction);\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0);\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left;\n    while (n !== null && n.deleted) {\n      n = n.left;\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      if (right.keep) {\n        this.keep = true;\n      }\n      this.right = right.right;\n      if (this.right !== null) {\n        this.right.left = this;\n      }\n      this.length += right.length;\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length;\n      }\n      this.markDeleted();\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n      addChangedTypeToTransaction(transaction, parent, this.parentSub);\n      this.content.delete(transaction);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc (store, parentGCd) {\n    if (!this.deleted) {\n      throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n    }\n    this.content.gc(store);\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length));\n    } else {\n      this.content = new ContentDeleted(this.length);\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {AbstractUpdateEncoder} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n    const rightOrigin = this.rightOrigin;\n    const parentSub = this.parentSub;\n    const info = (this.content.getRef() & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5) |\n      (origin === null ? 0 : lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6); // parentSub is non-null\n    encoder.writeInfo(info);\n    if (origin !== null) {\n      encoder.writeLeftID(origin);\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin);\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      const parentItem = parent._item;\n      if (parentItem === null) {\n        // parent type on y._map\n        // find the correct key\n        const ykey = findRootTypeKey(parent);\n        encoder.writeParentInfo(true); // write parentYKey\n        encoder.writeString(ykey);\n      } else {\n        encoder.writeParentInfo(false); // write parent id\n        encoder.writeLeftID(parentItem.id);\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub);\n      }\n    }\n    this.content.write(encoder, offset);\n  }\n}\n\n/**\n * @param {AbstractUpdateDecoder} decoder\n * @param {number} info\n */\nconst readItemContent = (decoder, info) => contentRefs[info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5](decoder);\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(AbstractUpdateDecoder):AbstractContent>}\n */\nconst contentRefs = [\n  () => { throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)() }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc // 9\n];\n\n\n//# sourceMappingURL=yjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL3lqcy9kaXN0L3lqcy5tanM/NjY4OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDSztBQUNEO0FBQ3dCO0FBQ3lKO0FBQzdDO0FBQ3hJO0FBQ0E7QUFDd0M7QUFDUDtBQUN0QztBQUNOO0FBQzhCO0FBQ3hCO0FBQ29CO0FBQ3BCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQ0FBZ0MsMERBQVU7QUFDMUM7QUFDQSxhQUFhLElBQUk7QUFDakIsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsVUFBVTtBQUNyQixXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUMsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJB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Q0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlEQUFLO0FBQy9DLDZCQUE2QixnREFBSTtBQUNqQyxrQ0FBa0MsZ0RBQUk7QUFDdEMsZ0NBQWdDLGdEQUFJLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLE9BQU87QUFDUCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsOERBQThELGlEQUFLOztBQUVuRTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVMsT0FBTyw2REFBYyxJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVncEM7QUFDaHBDIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNyZHQvbm9kZV9tb2R1bGVzL3lqcy9kaXN0L3lqcy5tanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlLmpzJztcbmltcG9ydCB7IGFwcGVuZFRvLCBmcm9tLCBsYXN0IH0gZnJvbSAnbGliMC9hcnJheS5qcyc7XG5pbXBvcnQgeyBmbG9vciwgbWluLCBtYXgsIGFicyB9IGZyb20gJ2xpYjAvbWF0aC5qcyc7XG5pbXBvcnQgeyBzZXRJZlVuZGVmaW5lZCwgYW55LCBjcmVhdGUgYXMgY3JlYXRlJDIsIGNvcHkgfSBmcm9tICdsaWIwL21hcC5qcyc7XG5pbXBvcnQgeyB3cml0ZVZhclVpbnQsIEVuY29kZXIsIHRvVWludDhBcnJheSwgSW50RGlmZk9wdFJsZUVuY29kZXIsIFVpbnRPcHRSbGVFbmNvZGVyLCBSbGVFbmNvZGVyLCB3cml0ZVVpbnQ4LCBTdHJpbmdFbmNvZGVyLCBjcmVhdGVFbmNvZGVyLCB3cml0ZVZhclVpbnQ4QXJyYXksIHdyaXRlVWludDhBcnJheSwgd3JpdGVBbnksIHdyaXRlVmFyU3RyaW5nIH0gZnJvbSAnbGliMC9lbmNvZGluZy5qcyc7XG5pbXBvcnQgeyByZWFkVmFyVWludCwgY3JlYXRlRGVjb2RlciwgcmVhZFVpbnQ4LCBJbnREaWZmT3B0UmxlRGVjb2RlciwgcmVhZFZhclVpbnQ4QXJyYXksIFVpbnRPcHRSbGVEZWNvZGVyLCBSbGVEZWNvZGVyLCBTdHJpbmdEZWNvZGVyLCByZWFkQW55LCByZWFkVmFyU3RyaW5nIH0gZnJvbSAnbGliMC9kZWNvZGluZy5qcyc7XG5pbXBvcnQgeyB1dWlkdjQsIHVpbnQzMiB9IGZyb20gJ2xpYjAvcmFuZG9tLmpzJztcbmltcG9ydCB7IGNvcHlVaW50OEFycmF5IH0gZnJvbSAnbGliMC9idWZmZXIuanMnO1xuaW1wb3J0IHsgdW5leHBlY3RlZENhc2UsIG1ldGhvZFVuaW1wbGVtZW50ZWQsIGNyZWF0ZSBhcyBjcmVhdGUkMSB9IGZyb20gJ2xpYjAvZXJyb3IuanMnO1xuaW1wb3J0IHsgQklUUzUsIEJJVDgsIEJJVDcsIEJJVDYsIEJJVDIsIEJJVDQsIEJJVDEsIEJJVDMgfSBmcm9tICdsaWIwL2JpbmFyeS5qcyc7XG5pbXBvcnQgeyBjYWxsQWxsIH0gZnJvbSAnbGliMC9mdW5jdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICdsaWIwL3NldC5qcyc7XG5pbXBvcnQgeyBwcmludCwgT1JBTkdFLCBCT0xELCBVTkJPTEQsIFJFRCB9IGZyb20gJ2xpYjAvbG9nZ2luZy5qcyc7XG5pbXBvcnQgeyBnZXRVbml4VGltZSB9IGZyb20gJ2xpYjAvdGltZS5qcyc7XG5pbXBvcnQgeyBpdGVyYXRvckZpbHRlciwgaXRlcmF0b3JNYXAgfSBmcm9tICdsaWIwL2l0ZXJhdG9yLmpzJztcbmltcG9ydCB7IGVxdWFsRmxhdCB9IGZyb20gJ2xpYjAvb2JqZWN0LmpzJztcblxuLyoqXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IGludGVyZmFjZSB0aGF0IGFsbCBDb25uZWN0b3JzIHNob3VsZCBpbXBsZW1lbnQgdG8ga2VlcCB0aGVtIGludGVyY2hhbmdlYWJsZS5cbiAqXG4gKiBAbm90ZSBUaGlzIGludGVyZmFjZSBpcyBleHBlcmltZW50YWwgYW5kIGl0IGlzIG5vdCBhZHZpc2VkIHRvIGFjdHVhbGx5IGluaGVyaXQgdGhpcyBjbGFzcy5cbiAqICAgICAgIEl0IGp1c3Qgc2VydmVzIGFzIHR5cGluZyBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZTxhbnk+fVxuICovXG5jbGFzcyBBYnN0cmFjdENvbm5lY3RvciBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IHlkb2NcbiAgICogQHBhcmFtIHthbnl9IGF3YXJlbmVzc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHlkb2MsIGF3YXJlbmVzcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2MgPSB5ZG9jO1xuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzO1xuICB9XG59XG5cbmNsYXNzIERlbGV0ZUl0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChjbG9jaywgbGVuKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5vIGxvbmdlciBtYWludGFpbiBhIERlbGV0ZVN0b3JlLiBEZWxldGVTZXQgaXMgYSB0ZW1wb3Jhcnkgb2JqZWN0IHRoYXQgaXMgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqIC0gV2hlbiBjcmVhdGVkIGluIGEgdHJhbnNhY3Rpb24sIGl0IG11c3Qgb25seSBiZSBhY2Nlc3NlZCBhZnRlciBzb3J0aW5nLCBhbmQgbWVyZ2luZ1xuICogICAtIFRoaXMgRGVsZXRlU2V0IGlzIHNlbmQgdG8gb3RoZXIgY2xpZW50c1xuICogLSBXZSBkbyBub3QgY3JlYXRlIGEgRGVsZXRlU2V0IHdoZW4gd2Ugc2VuZCBhIHN5bmMgbWVzc2FnZS4gVGhlIERlbGV0ZVNldCBtZXNzYWdlIGlzIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBTdHJ1Y3RTdG9yZVxuICogLSBXZSByZWFkIGEgRGVsZXRlU2V0IGFzIHBhcnQgb2YgYSBzeW5jL3VwZGF0ZSBtZXNzYWdlLiBJbiB0aGlzIGNhc2UgdGhlIERlbGV0ZVNldCBpcyBhbHJlYWR5IHNvcnRlZCBhbmQgbWVyZ2VkLlxuICovXG5jbGFzcyBEZWxldGVTZXQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsQXJyYXk8RGVsZXRlSXRlbT4+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0cyB0aGF0IHRoZSBEZWxldGVTZXQgZ2Mncy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEdDfEl0ZW0pOnZvaWR9IGZcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBkcywgZikgPT5cbiAgZHMuY2xpZW50cy5mb3JFYWNoKChkZWxldGVzLCBjbGllbnRpZCkgPT4ge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAodHJhbnNhY3Rpb24uZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudGlkKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWwgPSBkZWxldGVzW2ldO1xuICAgICAgaXRlcmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIHN0cnVjdHMsIGRlbC5jbG9jaywgZGVsLmxlbiwgZik7XG4gICAgfVxuICB9KTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PERlbGV0ZUl0ZW0+fSBkaXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kSW5kZXhEUyA9IChkaXMsIGNsb2NrKSA9PiB7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gZGlzLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgY29uc3QgbWlkaW5kZXggPSBmbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuICAgIGNvbnN0IG1pZCA9IGRpc1ttaWRpbmRleF07XG4gICAgY29uc3QgbWlkY2xvY2sgPSBtaWQuY2xvY2s7XG4gICAgaWYgKG1pZGNsb2NrIDw9IGNsb2NrKSB7XG4gICAgICBpZiAoY2xvY2sgPCBtaWRjbG9jayArIG1pZC5sZW4pIHtcbiAgICAgICAgcmV0dXJuIG1pZGluZGV4XG4gICAgICB9XG4gICAgICBsZWZ0ID0gbWlkaW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IG1pZGluZGV4IC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGlzRGVsZXRlZCA9IChkcywgaWQpID0+IHtcbiAgY29uc3QgZGlzID0gZHMuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgcmV0dXJuIGRpcyAhPT0gdW5kZWZpbmVkICYmIGZpbmRJbmRleERTKGRpcywgaWQuY2xvY2spICE9PSBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgc29ydEFuZE1lcmdlRGVsZXRlU2V0ID0gZHMgPT4ge1xuICBkcy5jbGllbnRzLmZvckVhY2goZGVscyA9PiB7XG4gICAgZGVscy5zb3J0KChhLCBiKSA9PiBhLmNsb2NrIC0gYi5jbG9jayk7XG4gICAgLy8gbWVyZ2UgaXRlbXMgd2l0aG91dCBmaWx0ZXJpbmcgb3Igc3BsaWNpbmcgdGhlIGFycmF5XG4gICAgLy8gaSBpcyB0aGUgY3VycmVudCBwb2ludGVyXG4gICAgLy8gaiByZWZlcnMgdG8gdGhlIGN1cnJlbnQgaW5zZXJ0IHBvc2l0aW9uIGZvciB0aGUgcG9pbnRlZCBpdGVtXG4gICAgLy8gdHJ5IHRvIG1lcmdlIGRlbHNbaV0gaW50byBkZWxzW2otMV0gb3Igc2V0IGRlbHNbal09ZGVsc1tpXVxuICAgIGxldCBpLCBqO1xuICAgIGZvciAoaSA9IDEsIGogPSAxOyBpIDwgZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGVmdCA9IGRlbHNbaiAtIDFdO1xuICAgICAgY29uc3QgcmlnaHQgPSBkZWxzW2ldO1xuICAgICAgaWYgKGxlZnQuY2xvY2sgKyBsZWZ0LmxlbiA9PT0gcmlnaHQuY2xvY2spIHtcbiAgICAgICAgbGVmdC5sZW4gKz0gcmlnaHQubGVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGogPCBpKSB7XG4gICAgICAgICAgZGVsc1tqXSA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgZGVscy5sZW5ndGggPSBqO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxEZWxldGVTZXQ+fSBkc3NcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH0gQSBmcmVzaCBEZWxldGVTZXRcbiAqL1xuY29uc3QgbWVyZ2VEZWxldGVTZXRzID0gZHNzID0+IHtcbiAgY29uc3QgbWVyZ2VkID0gbmV3IERlbGV0ZVNldCgpO1xuICBmb3IgKGxldCBkc3NJID0gMDsgZHNzSSA8IGRzcy5sZW5ndGg7IGRzc0krKykge1xuICAgIGRzc1tkc3NJXS5jbGllbnRzLmZvckVhY2goKGRlbHNMZWZ0LCBjbGllbnQpID0+IHtcbiAgICAgIGlmICghbWVyZ2VkLmNsaWVudHMuaGFzKGNsaWVudCkpIHtcbiAgICAgICAgLy8gV3JpdGUgYWxsIG1pc3Npbmcga2V5cyBmcm9tIGN1cnJlbnQgZHMgYW5kIGFsbCBmb2xsb3dpbmcuXG4gICAgICAgIC8vIElmIG1lcmdlZCBhbHJlYWR5IGNvbnRhaW5zIGBjbGllbnRgIGN1cnJlbnQgZHMgaGFzIGFscmVhZHkgYmVlbiBhZGRlZC5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxEZWxldGVJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGRlbHMgPSBkZWxzTGVmdC5zbGljZSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gZHNzSSArIDE7IGkgPCBkc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcHBlbmRUbyhkZWxzLCBkc3NbaV0uY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VkLmNsaWVudHMuc2V0KGNsaWVudCwgZGVscyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KG1lcmdlZCk7XG4gIHJldHVybiBtZXJnZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFkZFRvRGVsZXRlU2V0ID0gKGRzLCBjbGllbnQsIGNsb2NrLCBsZW5ndGgpID0+IHtcbiAgc2V0SWZVbmRlZmluZWQoZHMuY2xpZW50cywgY2xpZW50LCAoKSA9PiBbXSkucHVzaChuZXcgRGVsZXRlSXRlbShjbG9jaywgbGVuZ3RoKSk7XG59O1xuXG5jb25zdCBjcmVhdGVEZWxldGVTZXQgPSAoKSA9PiBuZXcgRGVsZXRlU2V0KCk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3NcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH0gTWVyZ2VkIGFuZCBzb3J0ZWQgRGVsZXRlU2V0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUgPSBzcyA9PiB7XG4gIGNvbnN0IGRzID0gY3JlYXRlRGVsZXRlU2V0KCk7XG4gIHNzLmNsaWVudHMuZm9yRWFjaCgoc3RydWN0cywgY2xpZW50KSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PERlbGV0ZUl0ZW0+fVxuICAgICAqL1xuICAgIGNvbnN0IGRzaXRlbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaV07XG4gICAgICBpZiAoc3RydWN0LmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBzdHJ1Y3QuaWQuY2xvY2s7XG4gICAgICAgIGxldCBsZW4gPSBzdHJ1Y3QubGVuZ3RoO1xuICAgICAgICBpZiAoaSArIDEgPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAobGV0IG5leHQgPSBzdHJ1Y3RzW2kgKyAxXTsgaSArIDEgPCBzdHJ1Y3RzLmxlbmd0aCAmJiBuZXh0LmlkLmNsb2NrID09PSBjbG9jayArIGxlbiAmJiBuZXh0LmRlbGV0ZWQ7IG5leHQgPSBzdHJ1Y3RzWysraSArIDFdKSB7XG4gICAgICAgICAgICBsZW4gKz0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRzaXRlbXMucHVzaChuZXcgRGVsZXRlSXRlbShjbG9jaywgbGVuKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkc2l0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGRzLmNsaWVudHMuc2V0KGNsaWVudCwgZHNpdGVtcyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3REU0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVEZWxldGVTZXQgPSAoZW5jb2RlciwgZHMpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGRzLmNsaWVudHMuc2l6ZSk7XG4gIGRzLmNsaWVudHMuZm9yRWFjaCgoZHNpdGVtcywgY2xpZW50KSA9PiB7XG4gICAgZW5jb2Rlci5yZXNldERzQ3VyVmFsKCk7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsaWVudCk7XG4gICAgY29uc3QgbGVuID0gZHNpdGVtcy5sZW5ndGg7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRzaXRlbXNbaV07XG4gICAgICBlbmNvZGVyLndyaXRlRHNDbG9jayhpdGVtLmNsb2NrKTtcbiAgICAgIGVuY29kZXIud3JpdGVEc0xlbihpdGVtLmxlbik7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdERTRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7RGVsZXRlU2V0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZERlbGV0ZVNldCA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBkcyA9IG5ldyBEZWxldGVTZXQoKTtcbiAgY29uc3QgbnVtQ2xpZW50cyA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsaWVudHM7IGkrKykge1xuICAgIGRlY29kZXIucmVzZXREc0N1clZhbCgpO1xuICAgIGNvbnN0IGNsaWVudCA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGNvbnN0IG51bWJlck9mRGVsZXRlcyA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGlmIChudW1iZXJPZkRlbGV0ZXMgPiAwKSB7XG4gICAgICBjb25zdCBkc0ZpZWxkID0gc2V0SWZVbmRlZmluZWQoZHMuY2xpZW50cywgY2xpZW50LCAoKSA9PiBbXSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRGVsZXRlczsgaSsrKSB7XG4gICAgICAgIGRzRmllbGQucHVzaChuZXcgRGVsZXRlSXRlbShkZWNvZGVyLnJlYWREc0Nsb2NrKCksIGRlY29kZXIucmVhZERzTGVuKCkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRzXG59O1xuXG4vKipcbiAqIEB0b2RvIFlEZWNvZGVyIGFsc28gY29udGFpbnMgcmVmZXJlbmNlcyB0byBTdHJpbmcgYW5kIG90aGVyIERlY29kZXJzLiBXb3VsZCBtYWtlIHNlbnNlIHRvIGV4Y2hhbmdlIFlEZWNvZGVyLnRvVWludDhBcnJheSBmb3IgWURlY29kZXIuRHNUb1VpbnQ4QXJyYXkoKS4uXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0RFNEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRBbmRBcHBseURlbGV0ZVNldCA9IChkZWNvZGVyLCB0cmFuc2FjdGlvbiwgc3RvcmUpID0+IHtcbiAgY29uc3QgdW5hcHBsaWVkRFMgPSBuZXcgRGVsZXRlU2V0KCk7XG4gIGNvbnN0IG51bUNsaWVudHMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGllbnRzOyBpKyspIHtcbiAgICBkZWNvZGVyLnJlc2V0RHNDdXJWYWwoKTtcbiAgICBjb25zdCBjbGllbnQgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBudW1iZXJPZkRlbGV0ZXMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKHN0b3JlLCBjbGllbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEZWxldGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGNsb2NrID0gZGVjb2Rlci5yZWFkRHNDbG9jaygpO1xuICAgICAgY29uc3QgY2xvY2tFbmQgPSBjbG9jayArIGRlY29kZXIucmVhZERzTGVuKCk7XG4gICAgICBpZiAoY2xvY2sgPCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPCBjbG9ja0VuZCkge1xuICAgICAgICAgIGFkZFRvRGVsZXRlU2V0KHVuYXBwbGllZERTLCBjbGllbnQsIHN0YXRlLCBjbG9ja0VuZCAtIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBjYW4gaWdub3JlIHRoZSBjYXNlIG9mIEdDIGFuZCBEZWxldGUgc3RydWN0cywgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gc2tpcCB0aGVtXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgc3RydWN0ID0gc3RydWN0c1tpbmRleF07XG4gICAgICAgIC8vIHNwbGl0IHRoZSBmaXJzdCBpdGVtIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkICYmIHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrKSB7XG4gICAgICAgICAgc3RydWN0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2sgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICAgICAgICBpbmRleCsrOyAvLyBpbmNyZWFzZSB3ZSBub3cgd2FudCB0byB1c2UgdGhlIG5leHQgc3RydWN0XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXTtcbiAgICAgICAgICBpZiAoc3RydWN0LmlkLmNsb2NrIDwgY2xvY2tFbmQpIHtcbiAgICAgICAgICAgIGlmICghc3RydWN0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGNsb2NrRW5kIDwgc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4LCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2tFbmQgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJ1Y3QuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFRvRGVsZXRlU2V0KHVuYXBwbGllZERTLCBjbGllbnQsIGNsb2NrLCBjbG9ja0VuZCAtIGNsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHVuYXBwbGllZERTLmNsaWVudHMuc2l6ZSA+IDApIHtcbiAgICAvLyBUT0RPOiBubyBuZWVkIGZvciBlbmNvZGluZytkZWNvZGluZyBkcyBhbnltb3JlXG4gICAgY29uc3QgdW5hcHBsaWVkRFNFbmNvZGVyID0gbmV3IERTRW5jb2RlclYyKCk7XG4gICAgd3JpdGVEZWxldGVTZXQodW5hcHBsaWVkRFNFbmNvZGVyLCB1bmFwcGxpZWREUyk7XG4gICAgc3RvcmUucGVuZGluZ0RlbGV0ZVJlYWRlcnMucHVzaChuZXcgRFNEZWNvZGVyVjIoY3JlYXRlRGVjb2RlcigodW5hcHBsaWVkRFNFbmNvZGVyLnRvVWludDhBcnJheSgpKSkpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAbW9kdWxlIFlcbiAqL1xuXG5jb25zdCBnZW5lcmF0ZU5ld0NsaWVudElkID0gdWludDMyO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERvY09wdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW0RvY09wdHMuZ2M9dHJ1ZV0gRGlzYWJsZSBnYXJiYWdlIGNvbGxlY3Rpb24gKGRlZmF1bHQ6IGdjPXRydWUpXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IFtEb2NPcHRzLmdjRmlsdGVyXSBXaWxsIGJlIGNhbGxlZCBiZWZvcmUgYW4gSXRlbSBpcyBnYXJiYWdlIGNvbGxlY3RlZC4gUmV0dXJuIGZhbHNlIHRvIGtlZXAgdGhlIEl0ZW0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0RvY09wdHMuZ3VpZF0gRGVmaW5lIGEgZ2xvYmFsbHkgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZG9jdW1lbnRcbiAqIEBwcm9wZXJ0eSB7YW55fSBbRG9jT3B0cy5tZXRhXSBBbnkga2luZCBvZiBtZXRhIGluZm9ybWF0aW9uIHlvdSB3YW50IHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZG9jdW1lbnQuIElmIHRoaXMgaXMgYSBzdWJkb2N1bWVudCwgcmVtb3RlIHBlZXJzIHdpbGwgc3RvcmUgdGhlIG1ldGEgaW5mb3JtYXRpb24gYXMgd2VsbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW0RvY09wdHMuYXV0b0xvYWRdIElmIGEgc3ViZG9jdW1lbnQsIGF1dG9tYXRpY2FsbHkgbG9hZCBkb2N1bWVudC4gSWYgdGhpcyBpcyBhIHN1YmRvY3VtZW50LCByZW1vdGUgcGVlcnMgd2lsbCBsb2FkIHRoZSBkb2N1bWVudCBhcyB3ZWxsIGF1dG9tYXRpY2FsbHkuXG4gKi9cblxuLyoqXG4gKiBBIFlqcyBpbnN0YW5jZSBoYW5kbGVzIHRoZSBzdGF0ZSBvZiBzaGFyZWQgZGF0YS5cbiAqIEBleHRlbmRzIE9ic2VydmFibGU8c3RyaW5nPlxuICovXG5jbGFzcyBEb2MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jT3B0c30gW29wdHNdIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh7IGd1aWQgPSB1dWlkdjQoKSwgZ2MgPSB0cnVlLCBnY0ZpbHRlciA9ICgpID0+IHRydWUsIG1ldGEgPSBudWxsLCBhdXRvTG9hZCA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5nYyA9IGdjO1xuICAgIHRoaXMuZ2NGaWx0ZXIgPSBnY0ZpbHRlcjtcbiAgICB0aGlzLmNsaWVudElEID0gZ2VuZXJhdGVOZXdDbGllbnRJZCgpO1xuICAgIHRoaXMuZ3VpZCA9IGd1aWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIEFic3RyYWN0VHlwZTxZRXZlbnQ+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXJlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgU3RydWN0U3RvcmUoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VHJhbnNhY3Rpb24gfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uQ2xlYW51cHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgZG9jdW1lbnQgaXMgYSBzdWJkb2N1bWVudCAtIGEgZG9jdW1lbnQgaW50ZWdyYXRlZCBpbnRvIGFub3RoZXIgZG9jdW1lbnQgLSB0aGVuIF9pdGVtIGlzIGRlZmluZWQuXG4gICAgICogQHR5cGUge0l0ZW0/fVxuICAgICAqL1xuICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgIHRoaXMuc2hvdWxkTG9hZCA9IGF1dG9Mb2FkO1xuICAgIHRoaXMuYXV0b0xvYWQgPSBhdXRvTG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSB0aGUgcGFyZW50IGRvY3VtZW50IHRoYXQgeW91IHJlcXVlc3QgdG8gbG9hZCBkYXRhIGludG8gdGhpcyBzdWJkb2N1bWVudCAoaWYgaXQgaXMgYSBzdWJkb2N1bWVudCkuXG4gICAqXG4gICAqIGBsb2FkKClgIG1pZ2h0IGJlIHVzZWQgaW4gdGhlIGZ1dHVyZSB0byByZXF1ZXN0IGFueSBwcm92aWRlciB0byBsb2FkIHRoZSBtb3N0IGN1cnJlbnQgZGF0YS5cbiAgICpcbiAgICogSXQgaXMgc2FmZSB0byBjYWxsIGBsb2FkKClgIG11bHRpcGxlIHRpbWVzLlxuICAgKi9cbiAgbG9hZCAoKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW07XG4gICAgaWYgKGl0ZW0gIT09IG51bGwgJiYgIXRoaXMuc2hvdWxkTG9hZCkge1xuICAgICAgdHJhbnNhY3QoLyoqIEB0eXBlIHthbnl9ICovIChpdGVtLnBhcmVudCkuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NMb2FkZWQuYWRkKHRoaXMpO1xuICAgICAgfSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuc2hvdWxkTG9hZCA9IHRydWU7XG4gIH1cblxuICBnZXRTdWJkb2NzICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJkb2NzXG4gIH1cblxuICBnZXRTdWJkb2NHdWlkcyAoKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbSh0aGlzLnN1YmRvY3MpLm1hcChkb2MgPT4gZG9jLmd1aWQpKVxuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhhdCBoYXBwZW4gaW5zaWRlIG9mIGEgdHJhbnNhY3Rpb24gYXJlIGJ1bmRsZWQuIFRoaXMgbWVhbnMgdGhhdFxuICAgKiB0aGUgb2JzZXJ2ZXIgZmlyZXMgX2FmdGVyXyB0aGUgdHJhbnNhY3Rpb24gaXMgZmluaXNoZWQgYW5kIHRoYXQgYWxsIGNoYW5nZXNcbiAgICogdGhhdCBoYXBwZW5lZCBpbnNpZGUgb2YgdGhlIHRyYW5zYWN0aW9uIGFyZSBzZW50IGFzIG9uZSBtZXNzYWdlIHRvIHRoZVxuICAgKiBvdGhlciBwZWVycy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbik6dm9pZH0gZiBUaGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgYXMgYSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge2FueX0gW29yaWdpbl0gT3JpZ2luIG9mIHdobyBzdGFydGVkIHRoZSB0cmFuc2FjdGlvbi4gV2lsbCBiZSBzdG9yZWQgb24gdHJhbnNhY3Rpb24ub3JpZ2luXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRyYW5zYWN0IChmLCBvcmlnaW4gPSBudWxsKSB7XG4gICAgdHJhbnNhY3QodGhpcywgZiwgb3JpZ2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBzaGFyZWQgZGF0YSB0eXBlLlxuICAgKlxuICAgKiBNdWx0aXBsZSBjYWxscyBvZiBgeS5nZXQobmFtZSwgVHlwZUNvbnN0cnVjdG9yKWAgeWllbGQgdGhlIHNhbWUgcmVzdWx0XG4gICAqIGFuZCBkbyBub3Qgb3ZlcndyaXRlIGVhY2ggb3RoZXIuIEkuZS5cbiAgICogYHkuZGVmaW5lKG5hbWUsIFkuQXJyYXkpID09PSB5LmRlZmluZShuYW1lLCBZLkFycmF5KWBcbiAgICpcbiAgICogQWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgdHlwZSBpcyBhbHNvIGF2YWlsYWJsZSBvbiBgeS5zaGFyZS5nZXQobmFtZSlgLlxuICAgKlxuICAgKiAqQmVzdCBQcmFjdGljZXM6KlxuICAgKiBEZWZpbmUgYWxsIHR5cGVzIHJpZ2h0IGFmdGVyIHRoZSBZanMgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgc3RvcmUgdGhlbSBpbiBhIHNlcGFyYXRlIG9iamVjdC5cbiAgICogQWxzbyB1c2UgdGhlIHR5cGVkIG1ldGhvZHMgYGdldFRleHQobmFtZSlgLCBgZ2V0QXJyYXkobmFtZSlgLCAuLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGNvbnN0IHkgPSBuZXcgWSguLilcbiAgICogICBjb25zdCBhcHBTdGF0ZSA9IHtcbiAgICogICAgIGRvY3VtZW50OiB5LmdldFRleHQoJ2RvY3VtZW50JylcbiAgICogICAgIGNvbW1lbnRzOiB5LmdldEFycmF5KCdjb21tZW50cycpXG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBUeXBlQ29uc3RydWN0b3IgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSB0eXBlIGRlZmluaXRpb24uIEUuZy4gWS5UZXh0LCBZLkFycmF5LCBZLk1hcCwgLi4uXG4gICAqIEByZXR1cm4ge0Fic3RyYWN0VHlwZTxhbnk+fSBUaGUgY3JlYXRlZCB0eXBlLiBDb25zdHJ1Y3RlZCB3aXRoIFR5cGVDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgKG5hbWUsIFR5cGVDb25zdHJ1Y3RvciA9IEFic3RyYWN0VHlwZSkge1xuICAgIGNvbnN0IHR5cGUgPSBzZXRJZlVuZGVmaW5lZCh0aGlzLnNoYXJlLCBuYW1lLCAoKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ID0gbmV3IFR5cGVDb25zdHJ1Y3RvcigpO1xuICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpO1xuICAgICAgcmV0dXJuIHRcbiAgICB9KTtcbiAgICBjb25zdCBDb25zdHIgPSB0eXBlLmNvbnN0cnVjdG9yO1xuICAgIGlmIChUeXBlQ29uc3RydWN0b3IgIT09IEFic3RyYWN0VHlwZSAmJiBDb25zdHIgIT09IFR5cGVDb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKENvbnN0ciA9PT0gQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdCA9IG5ldyBUeXBlQ29uc3RydWN0b3IoKTtcbiAgICAgICAgdC5fbWFwID0gdHlwZS5fbWFwO1xuICAgICAgICB0eXBlLl9tYXAuZm9yRWFjaCgvKiogQHBhcmFtIHtJdGVtP30gbiAqLyBuID0+IHtcbiAgICAgICAgICBmb3IgKDsgbiAhPT0gbnVsbDsgbiA9IG4ubGVmdCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbi5wYXJlbnQgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHQuX3N0YXJ0ID0gdHlwZS5fc3RhcnQ7XG4gICAgICAgIGZvciAobGV0IG4gPSB0Ll9zdGFydDsgbiAhPT0gbnVsbDsgbiA9IG4ucmlnaHQpIHtcbiAgICAgICAgICBuLnBhcmVudCA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdC5fbGVuZ3RoID0gdHlwZS5fbGVuZ3RoO1xuICAgICAgICB0aGlzLnNoYXJlLnNldChuYW1lLCB0KTtcbiAgICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpO1xuICAgICAgICByZXR1cm4gdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIHdpdGggdGhlIG5hbWUgJHtuYW1lfSBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgd2l0aCBhIGRpZmZlcmVudCBjb25zdHJ1Y3RvcmApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEFycmF5IChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlBcnJheSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lUZXh0fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRUZXh0IChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlUZXh0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WU1hcDxhbnk+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRNYXAgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWU1hcClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0WG1sRnJhZ21lbnQgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWVhtbEZyYWdtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBlbnRpcmUgZG9jdW1lbnQgaW50byBhIGpzIG9iamVjdCwgcmVjdXJzaXZlbHkgdHJhdmVyc2luZyBlYWNoIHlqcyB0eXBlXG4gICAqIERvZXNuJ3QgbG9nIHR5cGVzIHRoYXQgaGF2ZSBub3QgYmVlbiBkZWZpbmVkICh1c2luZyB5ZG9jLmdldFR5cGUoLi4pKS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBhbmQgcmF0aGVyIGNhbGwgdG9KU09OIGRpcmVjdGx5IG9uIHRoZSBzaGFyZWQgdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IGRvYyA9IHt9O1xuXG4gICAgdGhpcy5zaGFyZS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBkb2Nba2V5XSA9IHZhbHVlLnRvSlNPTigpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRvY1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYGRlc3Ryb3lgIGV2ZW50IGFuZCB1bnJlZ2lzdGVyIGFsbCBldmVudCBoYW5kbGVycy5cbiAgICovXG4gIGRlc3Ryb3kgKCkge1xuICAgIGZyb20odGhpcy5zdWJkb2NzKS5mb3JFYWNoKHN1YmRvYyA9PiBzdWJkb2MuZGVzdHJveSgpKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbTtcbiAgICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5faXRlbSA9IG51bGw7XG4gICAgICBjb25zdCBjb250ZW50ID0gLyoqIEB0eXBlIHtDb250ZW50RG9jfSAqLyAoaXRlbS5jb250ZW50KTtcbiAgICAgIGlmIChpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb250ZW50LmRvYyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50LmRvYyA9IG5ldyBEb2MoeyBndWlkOiB0aGlzLmd1aWQsIC4uLmNvbnRlbnQub3B0cyB9KTtcbiAgICAgICAgY29udGVudC5kb2MuX2l0ZW0gPSBpdGVtO1xuICAgICAgfVxuICAgICAgdHJhbnNhY3QoLyoqIEB0eXBlIHthbnl9ICovIChpdGVtKS5wYXJlbnQuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmFkZChjb250ZW50LmRvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuYWRkKHRoaXMpO1xuICAgICAgfSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnZGVzdHJveWVkJywgW3RydWVdKTtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBbdGhpc10pO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55KTphbnl9IGZcbiAgICovXG4gIG9uIChldmVudE5hbWUsIGYpIHtcbiAgICBzdXBlci5vbihldmVudE5hbWUsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb2ZmIChldmVudE5hbWUsIGYpIHtcbiAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBmKTtcbiAgfVxufVxuXG5jbGFzcyBEU0RlY29kZXJWMSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgdGhpcy5yZXN0RGVjb2RlciA9IGRlY29kZXI7XG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICAvLyBub3BcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkRHNDbG9jayAoKSB7XG4gICAgcmV0dXJuIHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzTGVuICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVEZWNvZGVyVjEgZXh0ZW5kcyBEU0RlY29kZXJWMSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRMZWZ0SUQgKCkge1xuICAgIHJldHVybiBjcmVhdGVJRChyZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSwgcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkUmlnaHRJRCAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUlEKHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpLCByZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBuZXh0IGNsaWVudCBpZC5cbiAgICogVXNlIHRoaXMgaW4gZmF2b3Igb2YgcmVhZElEIHdoZW5ldmVyIHBvc3NpYmxlIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIG9iamVjdHMgY3JlYXRlZC5cbiAgICovXG4gIHJlYWRDbGllbnQgKCkge1xuICAgIHJldHVybiByZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkSW5mbyAoKSB7XG4gICAgcmV0dXJuIHJlYWRVaW50OCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRTdHJpbmcgKCkge1xuICAgIHJldHVybiByZWFkVmFyU3RyaW5nKHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gaXNLZXlcbiAgICovXG4gIHJlYWRQYXJlbnRJbmZvICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikgPT09IDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZFR5cGVSZWYgKCkge1xuICAgIHJldHVybiByZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gbGVuXG4gICAqL1xuICByZWFkTGVuICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkQW55ICgpIHtcbiAgICByZXR1cm4gcmVhZEFueSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gICAqL1xuICByZWFkQnVmICgpIHtcbiAgICByZXR1cm4gY29weVVpbnQ4QXJyYXkocmVhZFZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogTGVnYWN5IGltcGxlbWVudGF0aW9uIHVzZXMgSlNPTiBwYXJzZS4gV2UgdXNlIGFueS1kZWNvZGluZyBpbiB2Mi5cbiAgICpcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEpTT04gKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZEtleSAoKSB7XG4gICAgcmV0dXJuIHJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxufVxuXG5jbGFzcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICAgIHRoaXMucmVzdERlY29kZXIgPSBkZWNvZGVyO1xuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICB9XG5cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpO1xuICAgIHJldHVybiB0aGlzLmRzQ3VyclZhbFxuICB9XG5cbiAgcmVhZERzTGVuICgpIHtcbiAgICBjb25zdCBkaWZmID0gcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikgKyAxO1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGRpZmY7XG4gICAgcmV0dXJuIGRpZmZcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVEZWNvZGVyVjIgZXh0ZW5kcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgc3VwZXIoZGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBjYWNoZWQga2V5cy4gSWYgdGhlIGtleXNbaWRdIGRvZXMgbm90IGV4aXN0LCB3ZSByZWFkIGEgbmV3IGtleVxuICAgICAqIGZyb20gc3RyaW5nRW5jb2RlciBhbmQgcHVzaCBpdCB0byBrZXlzLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgcmVhZFVpbnQ4KGRlY29kZXIpOyAvLyByZWFkIGZlYXR1cmUgZmxhZyAtIGN1cnJlbnRseSB1bnVzZWRcbiAgICB0aGlzLmtleUNsb2NrRGVjb2RlciA9IG5ldyBJbnREaWZmT3B0UmxlRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5jbGllbnREZWNvZGVyID0gbmV3IFVpbnRPcHRSbGVEZWNvZGVyKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLmxlZnRDbG9ja0RlY29kZXIgPSBuZXcgSW50RGlmZk9wdFJsZURlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMucmlnaHRDbG9ja0RlY29kZXIgPSBuZXcgSW50RGlmZk9wdFJsZURlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMuaW5mb0RlY29kZXIgPSBuZXcgUmxlRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgcmVhZFVpbnQ4KTtcbiAgICB0aGlzLnN0cmluZ0RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5wYXJlbnRJbmZvRGVjb2RlciA9IG5ldyBSbGVEZWNvZGVyKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCByZWFkVWludDgpO1xuICAgIHRoaXMudHlwZVJlZkRlY29kZXIgPSBuZXcgVWludE9wdFJsZURlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMubGVuRGVjb2RlciA9IG5ldyBVaW50T3B0UmxlRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkTGVmdElEICgpIHtcbiAgICByZXR1cm4gbmV3IElEKHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKCksIHRoaXMubGVmdENsb2NrRGVjb2Rlci5yZWFkKCkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkUmlnaHRJRCAoKSB7XG4gICAgcmV0dXJuIG5ldyBJRCh0aGlzLmNsaWVudERlY29kZXIucmVhZCgpLCB0aGlzLnJpZ2h0Q2xvY2tEZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBuZXh0IGNsaWVudCBpZC5cbiAgICogVXNlIHRoaXMgaW4gZmF2b3Igb2YgcmVhZElEIHdoZW5ldmVyIHBvc3NpYmxlIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIG9iamVjdHMgY3JlYXRlZC5cbiAgICovXG4gIHJlYWRDbGllbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudERlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRJbmZvICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmluZm9EZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdEZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZWFkUGFyZW50SW5mbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50SW5mb0RlY29kZXIucmVhZCgpID09PSAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkVHlwZVJlZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZVJlZkRlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZExlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkQW55ICgpIHtcbiAgICByZXR1cm4gcmVhZEFueSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gICAqL1xuICByZWFkQnVmICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIG1haW5seSBoZXJlIGZvciBsZWdhY3kgcHVycG9zZXMuXG4gICAqXG4gICAqIEluaXRpYWwgd2UgaW5jb2RlZCBvYmplY3RzIHVzaW5nIEpTT04uIE5vdyB3ZSB1c2UgdGhlIG11Y2ggZmFzdGVyIGxpYjAvYW55LWVuY29kZXIuIFRoaXMgbWV0aG9kIG1haW5seSBleGlzdHMgZm9yIGxlZ2FjeSBwdXJwb3NlcyBmb3IgdGhlIHYxIGVuY29kZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRKU09OICgpIHtcbiAgICByZXR1cm4gcmVhZEFueSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRLZXkgKCkge1xuICAgIGNvbnN0IGtleUNsb2NrID0gdGhpcy5rZXlDbG9ja0RlY29kZXIucmVhZCgpO1xuICAgIGlmIChrZXlDbG9jayA8IHRoaXMua2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleXNba2V5Q2xvY2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuc3RyaW5nRGVjb2Rlci5yZWFkKCk7XG4gICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgcmV0dXJuIGtleVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBEU0VuY29kZXJWMSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnJlc3RFbmNvZGVyID0gbmV3IEVuY29kZXIoKTtcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyKVxuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgLy8gbm9wXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqL1xuICB3cml0ZURzQ2xvY2sgKGNsb2NrKSB7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZURzTGVuIChsZW4pIHtcbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgbGVuKTtcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVFbmNvZGVyVjEgZXh0ZW5kcyBEU0VuY29kZXJWMSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVMZWZ0SUQgKGlkKSB7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsaWVudCk7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVSaWdodElEIChpZCkge1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbGllbnQpO1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHdyaXRlQ2xpZW50IGFuZCB3cml0ZUNsb2NrIGluc3RlYWQgb2Ygd3JpdGVJRCBpZiBwb3NzaWJsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKi9cbiAgd3JpdGVDbGllbnQgKGNsaWVudCkge1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBjbGllbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlSW5mbyAoaW5mbykge1xuICAgIHdyaXRlVWludDgodGhpcy5yZXN0RW5jb2RlciwgaW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICovXG4gIHdyaXRlU3RyaW5nIChzKSB7XG4gICAgd3JpdGVWYXJTdHJpbmcodGhpcy5yZXN0RW5jb2Rlciwgcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1lLZXlcbiAgICovXG4gIHdyaXRlUGFyZW50SW5mbyAoaXNZS2V5KSB7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlzWUtleSA/IDEgOiAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZVR5cGVSZWYgKGluZm8pIHtcbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVMZW4gKGxlbikge1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBsZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhbnlcbiAgICovXG4gIHdyaXRlQW55IChhbnkpIHtcbiAgICB3cml0ZUFueSh0aGlzLnJlc3RFbmNvZGVyLCBhbnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqL1xuICB3cml0ZUJ1ZiAoYnVmKSB7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIsIGJ1Zik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGVtYmVkXG4gICAqL1xuICB3cml0ZUpTT04gKGVtYmVkKSB7XG4gICAgd3JpdGVWYXJTdHJpbmcodGhpcy5yZXN0RW5jb2RlciwgSlNPTi5zdHJpbmdpZnkoZW1iZWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICB3cml0ZUtleSAoa2V5KSB7XG4gICAgd3JpdGVWYXJTdHJpbmcodGhpcy5yZXN0RW5jb2Rlciwga2V5KTtcbiAgfVxufVxuXG5jbGFzcyBEU0VuY29kZXJWMiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnJlc3RFbmNvZGVyID0gbmV3IEVuY29kZXIoKTsgLy8gZW5jb2RlcyBhbGwgdGhlIHJlc3QgLyBub24tb3B0aW1pemVkXG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICB0aGlzLmRzQ3VyclZhbCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqL1xuICB3cml0ZURzQ2xvY2sgKGNsb2NrKSB7XG4gICAgY29uc3QgZGlmZiA9IGNsb2NrIC0gdGhpcy5kc0N1cnJWYWw7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSBjbG9jaztcbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgZGlmZik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVEc0xlbiAobGVuKSB7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdW5leHBlY3RlZENhc2UoKTtcbiAgICB9XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbiAtIDEpO1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGxlbjtcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVFbmNvZGVyVjIgZXh0ZW5kcyBEU0VuY29kZXJWMiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogUmVmZXJzIHRvIHRoZSBuZXh0IHVuaXFlIGtleS1pZGVudGlmaWVyIHRvIG1lIHVzZWQuXG4gICAgICogU2VlIHdyaXRlS2V5IG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5rZXlDbG9jayA9IDA7XG4gICAgdGhpcy5rZXlDbG9ja0VuY29kZXIgPSBuZXcgSW50RGlmZk9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIgPSBuZXcgVWludE9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmxlZnRDbG9ja0VuY29kZXIgPSBuZXcgSW50RGlmZk9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyID0gbmV3IEludERpZmZPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5pbmZvRW5jb2RlciA9IG5ldyBSbGVFbmNvZGVyKHdyaXRlVWludDgpO1xuICAgIHRoaXMuc3RyaW5nRW5jb2RlciA9IG5ldyBTdHJpbmdFbmNvZGVyKCk7XG4gICAgdGhpcy5wYXJlbnRJbmZvRW5jb2RlciA9IG5ldyBSbGVFbmNvZGVyKHdyaXRlVWludDgpO1xuICAgIHRoaXMudHlwZVJlZkVuY29kZXIgPSBuZXcgVWludE9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmxlbkVuY29kZXIgPSBuZXcgVWludE9wdFJsZUVuY29kZXIoKTtcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoKTtcbiAgICB3cml0ZVVpbnQ4KGVuY29kZXIsIDApOyAvLyB0aGlzIGlzIGEgZmVhdHVyZSBmbGFnIHRoYXQgd2UgbWlnaHQgdXNlIGluIHRoZSBmdXR1cmVcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5rZXlDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmNsaWVudEVuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmxlZnRDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdG9VaW50OEFycmF5KHRoaXMuaW5mb0VuY29kZXIpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5zdHJpbmdFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdG9VaW50OEFycmF5KHRoaXMucGFyZW50SW5mb0VuY29kZXIpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy50eXBlUmVmRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVuRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgLy8gQG5vdGUgVGhlIHJlc3QgZW5jb2RlciBpcyBhcHBlbmRlZCEgKG5vdGUgdGhlIG1pc3NpbmcgdmFyKVxuICAgIHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB0b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcikpO1xuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVMZWZ0SUQgKGlkKSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGlkLmNsaWVudCk7XG4gICAgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyLndyaXRlKGlkLmNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVSaWdodElEIChpZCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShpZC5jbGllbnQpO1xuICAgIHRoaXMucmlnaHRDbG9ja0VuY29kZXIud3JpdGUoaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICovXG4gIHdyaXRlQ2xpZW50IChjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoY2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZUluZm8gKGluZm8pIHtcbiAgICB0aGlzLmluZm9FbmNvZGVyLndyaXRlKGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqL1xuICB3cml0ZVN0cmluZyAocykge1xuICAgIHRoaXMuc3RyaW5nRW5jb2Rlci53cml0ZShzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzWUtleVxuICAgKi9cbiAgd3JpdGVQYXJlbnRJbmZvIChpc1lLZXkpIHtcbiAgICB0aGlzLnBhcmVudEluZm9FbmNvZGVyLndyaXRlKGlzWUtleSA/IDEgOiAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZVR5cGVSZWYgKGluZm8pIHtcbiAgICB0aGlzLnR5cGVSZWZFbmNvZGVyLndyaXRlKGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlTGVuIChsZW4pIHtcbiAgICB0aGlzLmxlbkVuY29kZXIud3JpdGUobGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYW55XG4gICAqL1xuICB3cml0ZUFueSAoYW55KSB7XG4gICAgd3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgYW55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKi9cbiAgd3JpdGVCdWYgKGJ1Zikge1xuICAgIHdyaXRlVmFyVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyLCBidWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIGxlZ2FjeSBwdXJwb3Nlcy5cbiAgICpcbiAgICogSW5pdGlhbCB3ZSBpbmNvZGVkIG9iamVjdHMgdXNpbmcgSlNPTi4gTm93IHdlIHVzZSB0aGUgbXVjaCBmYXN0ZXIgbGliMC9hbnktZW5jb2Rlci4gVGhpcyBtZXRob2QgbWFpbmx5IGV4aXN0cyBmb3IgbGVnYWN5IHB1cnBvc2VzIGZvciB0aGUgdjEgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGVtYmVkXG4gICAqL1xuICB3cml0ZUpTT04gKGVtYmVkKSB7XG4gICAgd3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgZW1iZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5IGtleXMgYXJlIG9mdGVuIHJldXNlZC4gRm9yIGV4YW1wbGUsIGluIHktcHJvc2VtaXJyb3IgdGhlIGtleSBgYm9sZGAgbWlnaHRcbiAgICogb2NjdXIgdmVyeSBvZnRlbi4gRm9yIGEgM2QgYXBwbGljYXRpb24sIHRoZSBrZXkgYHBvc2l0aW9uYCBtaWdodCBvY2N1ciB2ZXJ5IG9mdGVuLlxuICAgKlxuICAgKiBXZSBjYWNoZSB0aGVzZSBrZXlzIGluIGEgTWFwIGFuZCByZWZlciB0byB0aGVtIHZpYSBhIHVuaXF1ZSBudW1iZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIHdyaXRlS2V5IChrZXkpIHtcbiAgICBjb25zdCBjbG9jayA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIGlmIChjbG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmtleUNsb2NrRW5jb2Rlci53cml0ZSh0aGlzLmtleUNsb2NrKyspO1xuICAgICAgdGhpcy5zdHJpbmdFbmNvZGVyLndyaXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyLndyaXRlKHRoaXMua2V5Q2xvY2srKyk7XG4gICAgfVxuICB9XG59XG5cbmxldCBEZWZhdWx0RFNFbmNvZGVyID0gRFNFbmNvZGVyVjE7XG5sZXQgRGVmYXVsdERTRGVjb2RlciA9IERTRGVjb2RlclYxO1xubGV0IERlZmF1bHRVcGRhdGVFbmNvZGVyID0gVXBkYXRlRW5jb2RlclYxO1xubGV0IERlZmF1bHRVcGRhdGVEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYxO1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0FycmF5PEdDfEl0ZW0+fSBzdHJ1Y3RzIEFsbCBzdHJ1Y3RzIGJ5IGBjbGllbnRgXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgd3JpdGUgc3RydWN0cyBzdGFydGluZyB3aXRoIGBJRChjbGllbnQsY2xvY2spYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0cnVjdHMgPSAoZW5jb2Rlciwgc3RydWN0cywgY2xpZW50LCBjbG9jaykgPT4ge1xuICAvLyB3cml0ZSBmaXJzdCBpZFxuICBjb25zdCBzdGFydE5ld1N0cnVjdHMgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBzdHJ1Y3RzLmxlbmd0aCAtIHN0YXJ0TmV3U3RydWN0cyk7XG4gIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KTtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsb2NrKTtcbiAgY29uc3QgZmlyc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0YXJ0TmV3U3RydWN0c107XG4gIC8vIHdyaXRlIGZpcnN0IHN0cnVjdCB3aXRoIGFuIG9mZnNldFxuICBmaXJzdFN0cnVjdC53cml0ZShlbmNvZGVyLCBjbG9jayAtIGZpcnN0U3RydWN0LmlkLmNsb2NrKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0TmV3U3RydWN0cyArIDE7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBfc21cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlQ2xpZW50c1N0cnVjdHMgPSAoZW5jb2Rlciwgc3RvcmUsIF9zbSkgPT4ge1xuICAvLyB3ZSBmaWx0ZXIgYWxsIHZhbGlkIF9zbSBlbnRyaWVzIGludG8gc21cbiAgY29uc3Qgc20gPSBuZXcgTWFwKCk7XG4gIF9zbS5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgLy8gb25seSB3cml0ZSBpZiBuZXcgc3RydWN0cyBhcmUgYXZhaWxhYmxlXG4gICAgaWYgKGdldFN0YXRlKHN0b3JlLCBjbGllbnQpID4gY2xvY2spIHtcbiAgICAgIHNtLnNldChjbGllbnQsIGNsb2NrKTtcbiAgICB9XG4gIH0pO1xuICBnZXRTdGF0ZVZlY3RvcihzdG9yZSkuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIGlmICghX3NtLmhhcyhjbGllbnQpKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCAwKTtcbiAgICB9XG4gIH0pO1xuICAvLyB3cml0ZSAjIHN0YXRlcyB0aGF0IHdlcmUgdXBkYXRlZFxuICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc20uc2l6ZSk7XG4gIC8vIFdyaXRlIGl0ZW1zIHdpdGggaGlnaGVyIGNsaWVudCBpZHMgZmlyc3RcbiAgLy8gVGhpcyBoZWF2aWx5IGltcHJvdmVzIHRoZSBjb25mbGljdCBhbGdvcml0aG0uXG4gIEFycmF5LmZyb20oc20uZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSkuZm9yRWFjaCgoW2NsaWVudCwgY2xvY2tdKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyaXRlU3RydWN0cyhlbmNvZGVyLCBzdG9yZS5jbGllbnRzLmdldChjbGllbnQpLCBjbGllbnQsIGNsb2NrKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAqIEBwYXJhbSB7TWFwPG51bWJlcixBcnJheTxHQ3xJdGVtPj59IGNsaWVudFJlZnNcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsQXJyYXk8R0N8SXRlbT4+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZENsaWVudHNTdHJ1Y3RSZWZzID0gKGRlY29kZXIsIGNsaWVudFJlZnMsIGRvYykgPT4ge1xuICBjb25zdCBudW1PZlN0YXRlVXBkYXRlcyA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mU3RhdGVVcGRhdGVzOyBpKyspIHtcbiAgICBjb25zdCBudW1iZXJPZlN0cnVjdHMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59XG4gICAgICovXG4gICAgY29uc3QgcmVmcyA9IG5ldyBBcnJheShudW1iZXJPZlN0cnVjdHMpO1xuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kZXIucmVhZENsaWVudCgpO1xuICAgIGxldCBjbG9jayA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIC8vIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjbGllbnRSZWZzLnNldChjbGllbnQsIHJlZnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTdHJ1Y3RzOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZm8gPSBkZWNvZGVyLnJlYWRJbmZvKCk7XG4gICAgICBpZiAoKEJJVFM1ICYgaW5mbykgIT09IDApIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgYW55IHZhcmlhYmxlcyBiZWNhdXNlIGlubGluaW5nIHZhcmlhYmxlcyBpcyBmYXN0ZXIuXG4gICAgICAgICAqIEJlbG93IGEgbm9uLW9wdGltaXplZCB2ZXJzaW9uIGlzIHNob3duIHRoYXQgaW1wbGVtZW50cyB0aGUgYmFzaWMgYWxnb3JpdGhtIHdpdGhcbiAgICAgICAgICogYSBmZXcgY29tbWVudHNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNhbnRDb3B5UGFyZW50SW5mbyA9IChpbmZvICYgKEJJVDcgfCBCSVQ4KSkgPT09IDA7XG4gICAgICAgIC8vIElmIHBhcmVudCA9IG51bGwgYW5kIG5laXRoZXIgbGVmdCBub3IgcmlnaHQgYXJlIGRlZmluZWQsIHRoZW4gd2Uga25vdyB0aGF0IGBwYXJlbnRgIGlzIGNoaWxkIG9mIGB5YFxuICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgLy8gSXQgaW5kaWNhdGVzIGhvdyB3ZSBzdG9yZS9yZXRyaWV2ZSBwYXJlbnQgZnJvbSBgeS5zaGFyZWBcbiAgICAgICAgLy8gQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgSXRlbShcbiAgICAgICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSxcbiAgICAgICAgICBudWxsLCAvLyBsZWZ0ZFxuICAgICAgICAgIChpbmZvICYgQklUOCkgPT09IEJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGwsIC8vIG9yaWdpblxuICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgKGluZm8gJiBCSVQ3KSA9PT0gQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGwsIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkb2MuZ2V0KGRlY29kZXIucmVhZFN0cmluZygpKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIEJJVDYpID09PSBCSVQ2ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsLCAvLyBwYXJlbnRTdWJcbiAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICk7XG4gICAgICAgIC8qIEEgbm9uLW9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYWJvdmUgYWxnb3JpdGhtOlxuXG4gICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAgICBjb25zdCBvcmlnaW4gPSAoaW5mbyAmIGJpbmFyeS5CSVQ4KSA9PT0gYmluYXJ5LkJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGxcbiAgICAgICAgLy8gVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAgICBjb25zdCByaWdodE9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGxcbiAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwXG4gICAgICAgIGNvbnN0IGhhc1BhcmVudFlLZXkgPSBjYW50Q29weVBhcmVudEluZm8gPyBkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgOiBmYWxzZVxuICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgLy8gYW5kIHdlIHJlYWQgdGhlIG5leHQgc3RyaW5nIGFzIHBhcmVudFlLZXkuXG4gICAgICAgIC8vIEl0IGluZGljYXRlcyBob3cgd2Ugc3RvcmUvcmV0cmlldmUgcGFyZW50IGZyb20gYHkuc2hhcmVgXG4gICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgY29uc3QgcGFyZW50WUtleSA9IGNhbnRDb3B5UGFyZW50SW5mbyAmJiBoYXNQYXJlbnRZS2V5ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsXG5cbiAgICAgICAgY29uc3Qgc3RydWN0ID0gbmV3IEl0ZW0oXG4gICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgbnVsbCwgLy8gbGVmdGRcbiAgICAgICAgICBvcmlnaW4sIC8vIG9yaWdpblxuICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgcmlnaHRPcmlnaW4sIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAhaGFzUGFyZW50WUtleSA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogKHBhcmVudFlLZXkgIT09IG51bGwgPyBkb2MuZ2V0KHBhcmVudFlLZXkpIDogbnVsbCksIC8vIHBhcmVudFxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIGJpbmFyeS5CSVQ2KSA9PT0gYmluYXJ5LkJJVDYgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGwsIC8vIHBhcmVudFN1YlxuICAgICAgICAgIHJlYWRJdGVtQ29udGVudChkZWNvZGVyLCBpbmZvKSAvLyBpdGVtIGNvbnRlbnRcbiAgICAgICAgKVxuICAgICAgICAqL1xuICAgICAgICByZWZzW2ldID0gc3RydWN0O1xuICAgICAgICBjbG9jayArPSBzdHJ1Y3QubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKCk7XG4gICAgICAgIHJlZnNbaV0gPSBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gcmVhZDogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gIH1cbiAgcmV0dXJuIGNsaWVudFJlZnNcbn07XG5cbi8qKlxuICogUmVzdW1lIGNvbXB1dGluZyBzdHJ1Y3RzIGdlbmVyYXRlZCBieSBzdHJ1Y3QgcmVhZGVycy5cbiAqXG4gKiBXaGlsZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8sIHdlIGludGVncmF0ZSBzdHJ1Y3RzIGluIHRoaXMgb3JkZXJcbiAqIDEuIHRvcCBlbGVtZW50IG9uIHN0YWNrLCBpZiBzdGFjayBpcyBub3QgZW1wdHlcbiAqIDIuIG5leHQgZWxlbWVudCBmcm9tIGN1cnJlbnQgc3RydWN0IHJlYWRlciAoaWYgZW1wdHksIHVzZSBuZXh0IHN0cnVjdCByZWFkZXIpXG4gKlxuICogSWYgc3RydWN0IGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciBzdHJ1Y3QgKHJlZi5taXNzaW5nKSwgd2UgcHV0IG5leHQgcmVhZGVyIG9mXG4gKiBgcmVmLmlkLmNsaWVudGAgb24gdG9wIG9mIHN0YWNrLlxuICpcbiAqIEF0IHNvbWUgcG9pbnQgd2UgZmluZCBhIHN0cnVjdCB0aGF0IGhhcyBubyBjYXVzYWwgZGVwZW5kZW5jaWVzLFxuICogdGhlbiB3ZSBzdGFydCBlbXB0eWluZyB0aGUgc3RhY2suXG4gKlxuICogSXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgY2lyY2xlczogaS5lLiBzdHJ1Y3QxIChmcm9tIGNsaWVudDEpIGRlcGVuZHMgb24gc3RydWN0MiAoZnJvbSBjbGllbnQyKVxuICogZGVwZW5kcyBvbiBzdHJ1Y3QzIChmcm9tIGNsaWVudDEpLiBUaGVyZWZvcmUgdGhlIG1heCBzdGFjayBzaXplIGlzIGVxYXVsIHRvIGBzdHJ1Y3RSZWFkZXJzLmxlbmd0aGAuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgaW1wbGVtZW50ZWQgaW4gYSB3YXkgc28gdGhhdCB3ZSBjYW4gcmVzdW1lIGNvbXB1dGF0aW9uIGlmIHRoaXMgdXBkYXRlXG4gKiBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgdXBkYXRlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVzdW1lU3RydWN0SW50ZWdyYXRpb24gPSAodHJhbnNhY3Rpb24sIHN0b3JlKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gc3RvcmUucGVuZGluZ1N0YWNrOyAvLyBAdG9kbyBkb24ndCBmb3JnZXQgdG8gYXBwZW5kIHN0YWNraGVhZCBhdCB0aGUgZW5kXG4gIGNvbnN0IGNsaWVudHNTdHJ1Y3RSZWZzID0gc3RvcmUucGVuZGluZ0NsaWVudHNTdHJ1Y3RSZWZzO1xuICAvLyBzb3J0IHRoZW0gc28gdGhhdCB3ZSB0YWtlIHRoZSBoaWdoZXIgaWQgZmlyc3QsIGluIGNhc2Ugb2YgY29uZmxpY3RzIHRoZSBsb3dlciBpZCB3aWxsIHByb2JhYmx5IG5vdCBjb25mbGljdCB3aXRoIHRoZSBpZCBmcm9tIHRoZSBoaWdoZXIgdXNlci5cbiAgY29uc3QgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBBcnJheS5mcm9tKGNsaWVudHNTdHJ1Y3RSZWZzLmtleXMoKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgZ2V0TmV4dFN0cnVjdFRhcmdldCA9ICgpID0+IHtcbiAgICBsZXQgbmV4dFN0cnVjdHNUYXJnZXQgPSAvKiogQHR5cGUge3tpOm51bWJlcixyZWZzOkFycmF5PEdDfEl0ZW0+fX0gKi8gKGNsaWVudHNTdHJ1Y3RSZWZzLmdldChjbGllbnRzU3RydWN0UmVmc0lkc1tjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggLSAxXSkpO1xuICAgIHdoaWxlIChuZXh0U3RydWN0c1RhcmdldC5yZWZzLmxlbmd0aCA9PT0gbmV4dFN0cnVjdHNUYXJnZXQuaSkge1xuICAgICAgY2xpZW50c1N0cnVjdFJlZnNJZHMucG9wKCk7XG4gICAgICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBuZXh0U3RydWN0c1RhcmdldCA9IC8qKiBAdHlwZSB7e2k6bnVtYmVyLHJlZnM6QXJyYXk8R0N8SXRlbT59fSAqLyAoY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudHNTdHJ1Y3RSZWZzSWRzW2NsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCAtIDFdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5wZW5kaW5nQ2xpZW50c1N0cnVjdFJlZnMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTdHJ1Y3RzVGFyZ2V0XG4gIH07XG4gIGxldCBjdXJTdHJ1Y3RzVGFyZ2V0ID0gZ2V0TmV4dFN0cnVjdFRhcmdldCgpO1xuICBpZiAoY3VyU3RydWN0c1RhcmdldCA9PT0gbnVsbCAmJiBzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKipcbiAgICogQHR5cGUge0dDfEl0ZW19XG4gICAqL1xuICBsZXQgc3RhY2tIZWFkID0gc3RhY2subGVuZ3RoID4gMFxuICAgID8gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoc3RhY2sucG9wKCkpXG4gICAgOiAvKiogQHR5cGUge2FueX0gKi8gKGN1clN0cnVjdHNUYXJnZXQpLnJlZnNbLyoqIEB0eXBlIHthbnl9ICovIChjdXJTdHJ1Y3RzVGFyZ2V0KS5pKytdO1xuICAvLyBjYWNoaW5nIHRoZSBzdGF0ZSBiZWNhdXNlIGl0IGlzIHVzZWQgdmVyeSBvZnRlblxuICBjb25zdCBzdGF0ZSA9IG5ldyBNYXAoKTtcbiAgLy8gaXRlcmF0ZSBvdmVyIGFsbCBzdHJ1Y3QgcmVhZGVycyB1bnRpbCB3ZSBhcmUgZG9uZVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvY2FsQ2xvY2sgPSBzZXRJZlVuZGVmaW5lZChzdGF0ZSwgc3RhY2tIZWFkLmlkLmNsaWVudCwgKCkgPT4gZ2V0U3RhdGUoc3RvcmUsIHN0YWNrSGVhZC5pZC5jbGllbnQpKTtcbiAgICBjb25zdCBvZmZzZXQgPSBzdGFja0hlYWQuaWQuY2xvY2sgPCBsb2NhbENsb2NrID8gbG9jYWxDbG9jayAtIHN0YWNrSGVhZC5pZC5jbG9jayA6IDA7XG4gICAgaWYgKHN0YWNrSGVhZC5pZC5jbG9jayArIG9mZnNldCAhPT0gbG9jYWxDbG9jaykge1xuICAgICAgLy8gQSBwcmV2aW91cyBtZXNzYWdlIGZyb20gdGhpcyBjbGllbnQgaXMgbWlzc2luZ1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHN0cnVjdFJlZiB3aXRoIGEgc21hbGxlciBjbG9jayBhbmQgc3dpdGNoIHRoZW1cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge3sgcmVmczogQXJyYXk8R0N8SXRlbT4sIGk6IG51bWJlciB9fVxuICAgICAgICovXG4gICAgICBjb25zdCBzdHJ1Y3RSZWZzID0gY2xpZW50c1N0cnVjdFJlZnMuZ2V0KHN0YWNrSGVhZC5pZC5jbGllbnQpIHx8IHsgcmVmczogW10sIGk6IDAgfTtcbiAgICAgIGlmIChzdHJ1Y3RSZWZzLnJlZnMubGVuZ3RoICE9PSBzdHJ1Y3RSZWZzLmkpIHtcbiAgICAgICAgY29uc3QgciA9IHN0cnVjdFJlZnMucmVmc1tzdHJ1Y3RSZWZzLmldO1xuICAgICAgICBpZiAoci5pZC5jbG9jayA8IHN0YWNrSGVhZC5pZC5jbG9jaykge1xuICAgICAgICAgIC8vIHB1dCByZWYgd2l0aCBzbWFsbGVyIGNsb2NrIG9uIHN0YWNrIGluc3RlYWQgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgc3RydWN0UmVmcy5yZWZzW3N0cnVjdFJlZnMuaV0gPSBzdGFja0hlYWQ7XG4gICAgICAgICAgc3RhY2tIZWFkID0gcjtcbiAgICAgICAgICAvLyBzb3J0IHRoZSBzZXQgYmVjYXVzZSB0aGlzIGFwcHJvYWNoIG1pZ2h0IGJyaW5nIHRoZSBsaXN0IG91dCBvZiBvcmRlclxuICAgICAgICAgIHN0cnVjdFJlZnMucmVmcyA9IHN0cnVjdFJlZnMucmVmcy5zbGljZShzdHJ1Y3RSZWZzLmkpLnNvcnQoKHIxLCByMikgPT4gcjEuaWQuY2xvY2sgLSByMi5pZC5jbG9jayk7XG4gICAgICAgICAgc3RydWN0UmVmcy5pID0gMDtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB3YWl0IHVudGlsIG1pc3Npbmcgc3RydWN0IGlzIGF2YWlsYWJsZVxuICAgICAgc3RhY2sucHVzaChzdGFja0hlYWQpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IG1pc3NpbmcgPSBzdGFja0hlYWQuZ2V0TWlzc2luZyh0cmFuc2FjdGlvbiwgc3RvcmUpO1xuICAgIGlmIChtaXNzaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAob2Zmc2V0ID09PSAwIHx8IG9mZnNldCA8IHN0YWNrSGVhZC5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2tIZWFkLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgc3RhdGUuc2V0KHN0YWNrSGVhZC5pZC5jbGllbnQsIHN0YWNrSGVhZC5pZC5jbG9jayArIHN0YWNrSGVhZC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgLy8gaXRlcmF0ZSB0byBuZXh0IHN0YWNrSGVhZFxuICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoc3RhY2sucG9wKCkpO1xuICAgICAgfSBlbHNlIGlmIChjdXJTdHJ1Y3RzVGFyZ2V0ICE9PSBudWxsICYmIGN1clN0cnVjdHNUYXJnZXQuaSA8IGN1clN0cnVjdHNUYXJnZXQucmVmcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoY3VyU3RydWN0c1RhcmdldC5yZWZzW2N1clN0cnVjdHNUYXJnZXQuaSsrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJTdHJ1Y3RzVGFyZ2V0ID0gZ2V0TmV4dFN0cnVjdFRhcmdldCgpO1xuICAgICAgICBpZiAoY3VyU3RydWN0c1RhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHdlIGFyZSBkb25lIVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoY3VyU3RydWN0c1RhcmdldC5yZWZzW2N1clN0cnVjdHNUYXJnZXQuaSsrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0IHRoZSBzdHJ1Y3QgcmVhZGVyIHRoYXQgaGFzIHRoZSBtaXNzaW5nIHN0cnVjdFxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7eyByZWZzOiBBcnJheTxHQ3xJdGVtPiwgaTogbnVtYmVyIH19XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHN0cnVjdFJlZnMgPSBjbGllbnRzU3RydWN0UmVmcy5nZXQobWlzc2luZykgfHwgeyByZWZzOiBbXSwgaTogMCB9O1xuICAgICAgaWYgKHN0cnVjdFJlZnMucmVmcy5sZW5ndGggPT09IHN0cnVjdFJlZnMuaSkge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBtZXNzYWdlIGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciB1cGRhdGUgbWVzc2FnZS5cbiAgICAgICAgc3RhY2sucHVzaChzdGFja0hlYWQpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHN0YWNrLnB1c2goc3RhY2tIZWFkKTtcbiAgICAgIHN0YWNrSGVhZCA9IHN0cnVjdFJlZnMucmVmc1tzdHJ1Y3RSZWZzLmkrK107XG4gICAgfVxuICB9XG4gIHN0b3JlLnBlbmRpbmdDbGllbnRzU3RydWN0UmVmcy5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHRyeVJlc3VtZVBlbmRpbmdEZWxldGVSZWFkZXJzID0gKHRyYW5zYWN0aW9uLCBzdG9yZSkgPT4ge1xuICBjb25zdCBwZW5kaW5nUmVhZGVycyA9IHN0b3JlLnBlbmRpbmdEZWxldGVSZWFkZXJzO1xuICBzdG9yZS5wZW5kaW5nRGVsZXRlUmVhZGVycyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmdSZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVhZEFuZEFwcGx5RGVsZXRlU2V0KHBlbmRpbmdSZWFkZXJzW2ldLCB0cmFuc2FjdGlvbiwgc3RvcmUpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uID0gKGVuY29kZXIsIHRyYW5zYWN0aW9uKSA9PiB3cml0ZUNsaWVudHNTdHJ1Y3RzKGVuY29kZXIsIHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsIEFycmF5PEdDfEl0ZW0+Pn0gY2xpZW50c1N0cnVjdHNSZWZzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBtZXJnZVJlYWRTdHJ1Y3RzSW50b1BlbmRpbmdSZWFkcyA9IChzdG9yZSwgY2xpZW50c1N0cnVjdHNSZWZzKSA9PiB7XG4gIGNvbnN0IHBlbmRpbmdDbGllbnRzU3RydWN0UmVmcyA9IHN0b3JlLnBlbmRpbmdDbGllbnRzU3RydWN0UmVmcztcbiAgY2xpZW50c1N0cnVjdHNSZWZzLmZvckVhY2goKHN0cnVjdFJlZnMsIGNsaWVudCkgPT4ge1xuICAgIGNvbnN0IHBlbmRpbmdTdHJ1Y3RSZWZzID0gcGVuZGluZ0NsaWVudHNTdHJ1Y3RSZWZzLmdldChjbGllbnQpO1xuICAgIGlmIChwZW5kaW5nU3RydWN0UmVmcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwZW5kaW5nQ2xpZW50c1N0cnVjdFJlZnMuc2V0KGNsaWVudCwgeyByZWZzOiBzdHJ1Y3RSZWZzLCBpOiAwIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtZXJnZSBpbnRvIGV4aXN0aW5nIHN0cnVjdFJlZnNcbiAgICAgIGNvbnN0IG1lcmdlZCA9IHBlbmRpbmdTdHJ1Y3RSZWZzLmkgPiAwID8gcGVuZGluZ1N0cnVjdFJlZnMucmVmcy5zbGljZShwZW5kaW5nU3RydWN0UmVmcy5pKSA6IHBlbmRpbmdTdHJ1Y3RSZWZzLnJlZnM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cnVjdFJlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVyZ2VkLnB1c2goc3RydWN0UmVmc1tpXSk7XG4gICAgICB9XG4gICAgICBwZW5kaW5nU3RydWN0UmVmcy5pID0gMDtcbiAgICAgIHBlbmRpbmdTdHJ1Y3RSZWZzLnJlZnMgPSBtZXJnZWQuc29ydCgocjEsIHIyKSA9PiByMS5pZC5jbG9jayAtIHIyLmlkLmNsb2NrKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge01hcDxudW1iZXIse3JlZnM6QXJyYXk8R0N8SXRlbT4saTpudW1iZXJ9Pn0gcGVuZGluZ0NsaWVudHNTdHJ1Y3RSZWZzXG4gKi9cbmNvbnN0IGNsZWFudXBQZW5kaW5nU3RydWN0cyA9IHBlbmRpbmdDbGllbnRzU3RydWN0UmVmcyA9PiB7XG4gIC8vIGNsZWFudXAgcGVuZGluZ0NsaWVudHNTdHJ1Y3RzIGlmIG5vdCBmdWxseSBmaW5pc2hlZFxuICBwZW5kaW5nQ2xpZW50c1N0cnVjdFJlZnMuZm9yRWFjaCgocmVmcywgY2xpZW50KSA9PiB7XG4gICAgaWYgKHJlZnMuaSA9PT0gcmVmcy5yZWZzLmxlbmd0aCkge1xuICAgICAgcGVuZGluZ0NsaWVudHNTdHJ1Y3RSZWZzLmRlbGV0ZShjbGllbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZzLnJlZnMuc3BsaWNlKDAsIHJlZnMuaSk7XG4gICAgICByZWZzLmkgPSAwO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlYWQgdGhlIG5leHQgSXRlbSBpbiBhIERlY29kZXIgYW5kIGZpbGwgdGhpcyBJdGVtIHdpdGggdGhlIHJlYWQgZGF0YS5cbiAqXG4gKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGRhdGEgaXMgcmVjZWl2ZWQgZnJvbSBhIHJlbW90ZSBwZWVyLlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFN0cnVjdHMgPSAoZGVjb2RlciwgdHJhbnNhY3Rpb24sIHN0b3JlKSA9PiB7XG4gIGNvbnN0IGNsaWVudHNTdHJ1Y3RSZWZzID0gbmV3IE1hcCgpO1xuICAvLyBsZXQgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICByZWFkQ2xpZW50c1N0cnVjdFJlZnMoZGVjb2RlciwgY2xpZW50c1N0cnVjdFJlZnMsIHRyYW5zYWN0aW9uLmRvYyk7XG4gIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlYWQgc3RydWN0czogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgbWVyZ2VSZWFkU3RydWN0c0ludG9QZW5kaW5nUmVhZHMoc3RvcmUsIGNsaWVudHNTdHJ1Y3RSZWZzKTtcbiAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gbWVyZ2U6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gIHJlc3VtZVN0cnVjdEludGVncmF0aW9uKHRyYW5zYWN0aW9uLCBzdG9yZSk7XG4gIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIGludGVncmF0ZTogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgY2xlYW51cFBlbmRpbmdTdHJ1Y3RzKHN0b3JlLnBlbmRpbmdDbGllbnRzU3RydWN0UmVmcyk7XG4gIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIGNsZWFudXA6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gIHRyeVJlc3VtZVBlbmRpbmdEZWxldGVSZWFkZXJzKHRyYW5zYWN0aW9uLCBzdG9yZSk7XG4gIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlc3VtZSBkZWxldGUgcmVhZGVyczogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbn07XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgYSBkb2N1bWVudCB1cGRhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGBhcHBseVVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gZGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVEZWNvZGVyfSBbc3RydWN0RGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFVwZGF0ZVYyID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBzdHJ1Y3REZWNvZGVyID0gbmV3IFVwZGF0ZURlY29kZXJWMihkZWNvZGVyKSkgPT5cbiAgdHJhbnNhY3QoeWRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgIHJlYWRTdHJ1Y3RzKHN0cnVjdERlY29kZXIsIHRyYW5zYWN0aW9uLCB5ZG9jLnN0b3JlKTtcbiAgICByZWFkQW5kQXBwbHlEZWxldGVTZXQoc3RydWN0RGVjb2RlciwgdHJhbnNhY3Rpb24sIHlkb2Muc3RvcmUpO1xuICB9LCB0cmFuc2FjdGlvbk9yaWdpbiwgZmFsc2UpO1xuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IGEgZG9jdW1lbnQgdXBkYXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgYXBwbHlVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIGRlY29kZXIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRVcGRhdGUgPSAoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHJlYWRVcGRhdGVWMihkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbiwgbmV3IERlZmF1bHRVcGRhdGVEZWNvZGVyKGRlY29kZXIpKTtcblxuLyoqXG4gKiBBcHBseSBhIGRvY3VtZW50IHVwZGF0ZSBjcmVhdGVkIGJ5LCBmb3IgZXhhbXBsZSwgYHkub24oJ3VwZGF0ZScsIHVwZGF0ZSA9PiAuLilgIG9yIGB1cGRhdGUgPSBlbmNvZGVTdGF0ZUFzVXBkYXRlKClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgcmVhZFVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gVWludDhBcnJheSBpbnN0ZWFkIG9mIGEgRGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gW1lEZWNvZGVyXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhcHBseVVwZGF0ZVYyID0gKHlkb2MsIHVwZGF0ZSwgdHJhbnNhY3Rpb25PcmlnaW4sIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKHVwZGF0ZSk7XG4gIHJlYWRVcGRhdGVWMihkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbiwgbmV3IFlEZWNvZGVyKGRlY29kZXIpKTtcbn07XG5cbi8qKlxuICogQXBwbHkgYSBkb2N1bWVudCB1cGRhdGUgY3JlYXRlZCBieSwgZm9yIGV4YW1wbGUsIGB5Lm9uKCd1cGRhdGUnLCB1cGRhdGUgPT4gLi4pYCBvciBgdXBkYXRlID0gZW5jb2RlU3RhdGVBc1VwZGF0ZSgpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYHJlYWRVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBhIERlY29kZXIuXG4gKlxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYXBwbHlVcGRhdGUgPSAoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4gYXBwbHlVcGRhdGVWMih5ZG9jLCB1cGRhdGUsIHRyYW5zYWN0aW9uT3JpZ2luLCBEZWZhdWx0VXBkYXRlRGVjb2Rlcik7XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZS4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVWZWN0b3JgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZUVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBbdGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVTdGF0ZUFzVXBkYXRlID0gKGVuY29kZXIsIGRvYywgdGFyZ2V0U3RhdGVWZWN0b3IgPSBuZXcgTWFwKCkpID0+IHtcbiAgd3JpdGVDbGllbnRzU3RydWN0cyhlbmNvZGVyLCBkb2Muc3RvcmUsIHRhcmdldFN0YXRlVmVjdG9yKTtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlKGRvYy5zdG9yZSkpO1xufTtcblxuLyoqXG4gKiBXcml0ZSBhbGwgdGhlIGRvY3VtZW50IGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlIHRoYXQgY2FuIGJlIGFwcGxpZWQgb24gdGhlIHJlbW90ZSBkb2N1bWVudC4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogVXNlIGB3cml0ZVN0YXRlQXNVcGRhdGVgIGluc3RlYWQgaWYgeW91IGFyZSB3b3JraW5nIHdpdGggbGliMC9lbmNvZGluZy5qcyNFbmNvZGVyXG4gKlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBbZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yXSBUaGUgc3RhdGUgb2YgdGhlIHRhcmdldCB0aGF0IHJlY2VpdmVzIHRoZSB1cGRhdGUuIExlYXZlIGVtcHR5IHRvIHdyaXRlIGFsbCBrbm93biBzdHJ1Y3RzXG4gKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRW5jb2Rlcn0gW2VuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIgPSAoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IsIGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCkpID0+IHtcbiAgY29uc3QgdGFyZ2V0U3RhdGVWZWN0b3IgPSBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IgPT0gbnVsbCA/IG5ldyBNYXAoKSA6IGRlY29kZVN0YXRlVmVjdG9yKGVuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcik7XG4gIHdyaXRlU3RhdGVBc1VwZGF0ZShlbmNvZGVyLCBkb2MsIHRhcmdldFN0YXRlVmVjdG9yKTtcbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIHRoZSByZW1vdGUgZG9jdW1lbnQuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIFVzZSBgd3JpdGVTdGF0ZUFzVXBkYXRlYCBpbnN0ZWFkIGlmIHlvdSBhcmUgd29ya2luZyB3aXRoIGxpYjAvZW5jb2RpbmcuanMjRW5jb2RlclxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVBc1VwZGF0ZSA9IChkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvcikgPT4gZW5jb2RlU3RhdGVBc1VwZGF0ZVYyKGRvYywgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yLCBuZXcgRGVmYXVsdFVwZGF0ZUVuY29kZXIoKSk7XG5cbi8qKlxuICogUmVhZCBzdGF0ZSB2ZWN0b3IgZnJvbSBEZWNvZGVyIGFuZCByZXR1cm4gYXMgTWFwXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdERTRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRTdGF0ZVZlY3RvciA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBzcyA9IG5ldyBNYXAoKTtcbiAgY29uc3Qgc3NMZW5ndGggPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50ID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgY2xvY2sgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBzcy5zZXQoY2xpZW50LCBjbG9jayk7XG4gIH1cbiAgcmV0dXJuIHNzXG59O1xuXG4vKipcbiAqIFJlYWQgZGVjb2RlZFN0YXRlIGFuZCByZXR1cm4gU3RhdGUgYXMgTWFwLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGVjb2RlZFN0YXRlXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59IE1hcHMgYGNsaWVudGAgdG8gdGhlIG51bWJlciBuZXh0IGV4cGVjdGVkIGBjbG9ja2AgZnJvbSB0aGF0IGNsaWVudC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZGVjb2RlU3RhdGVWZWN0b3JWMiA9IGRlY29kZWRTdGF0ZSA9PiByZWFkU3RhdGVWZWN0b3IobmV3IERTRGVjb2RlclYyKGNyZWF0ZURlY29kZXIoZGVjb2RlZFN0YXRlKSkpO1xuXG4vKipcbiAqIFJlYWQgZGVjb2RlZFN0YXRlIGFuZCByZXR1cm4gU3RhdGUgYXMgTWFwLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGVjb2RlZFN0YXRlXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59IE1hcHMgYGNsaWVudGAgdG8gdGhlIG51bWJlciBuZXh0IGV4cGVjdGVkIGBjbG9ja2AgZnJvbSB0aGF0IGNsaWVudC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZGVjb2RlU3RhdGVWZWN0b3IgPSBkZWNvZGVkU3RhdGUgPT4gcmVhZFN0YXRlVmVjdG9yKG5ldyBEZWZhdWx0RFNEZWNvZGVyKGNyZWF0ZURlY29kZXIoZGVjb2RlZFN0YXRlKSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3REU0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzdlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RhdGVWZWN0b3IgPSAoZW5jb2Rlciwgc3YpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHN2LnNpemUpO1xuICBzdi5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsaWVudCk7IC8vIEB0b2RvIHVzZSBhIHNwZWNpYWwgY2xpZW50IGRlY29kZXIgdGhhdCBpcyBiYXNlZCBvbiBtYXBwaW5nXG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsb2NrKTtcbiAgfSk7XG4gIHJldHVybiBlbmNvZGVyXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3REU0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVEb2N1bWVudFN0YXRlVmVjdG9yID0gKGVuY29kZXIsIGRvYykgPT4gd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpKTtcblxuLyoqXG4gKiBFbmNvZGUgU3RhdGUgYXMgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge0Fic3RyYWN0RFNFbmNvZGVyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yVjIgPSAoZG9jLCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYyKCkpID0+IHtcbiAgd3JpdGVEb2N1bWVudFN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYyk7XG4gIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG59O1xuXG4vKipcbiAqIEVuY29kZSBTdGF0ZSBhcyBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yID0gZG9jID0+IGVuY29kZVN0YXRlVmVjdG9yVjIoZG9jLCBuZXcgRGVmYXVsdERTRW5jb2RlcigpKTtcblxuLyoqXG4gKiBHZW5lcmFsIGV2ZW50IGhhbmRsZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsIEFSRzFcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKEFSRzAsIEFSRzEpOnZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMubCA9IFtdO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHJldHVybnMge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlRXZlbnRIYW5kbGVyID0gKCkgPT4gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgd2hlblxuICoge0BsaW5rIEV2ZW50SGFuZGxlciNjYWxsRXZlbnRMaXN0ZW5lcnN9IGlzIGNhbGxlZC5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQVJHMCxBUkcxKTp2b2lkfSBmIFRoZSBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIgPSAoZXZlbnRIYW5kbGVyLCBmKSA9PlxuICBldmVudEhhbmRsZXIubC5wdXNoKGYpO1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFSRzAsQVJHMSk6dm9pZH0gZiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IHdhcyBhZGRlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgIHtAbGluayBFdmVudEhhbmRsZXIjYWRkRXZlbnRMaXN0ZW5lcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT4ge1xuICBjb25zdCBsID0gZXZlbnRIYW5kbGVyLmw7XG4gIGNvbnN0IGxlbiA9IGwubGVuZ3RoO1xuICBldmVudEhhbmRsZXIubCA9IGwuZmlsdGVyKGcgPT4gZiAhPT0gZyk7XG4gIGlmIChsZW4gPT09IGV2ZW50SGFuZGxlci5sLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t5anNdIFRyaWVkIHRvIHJlbW92ZSBldmVudCBoYW5kbGVyIHRoYXQgZG9lc25cXCd0IGV4aXN0LicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYWxsIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgdmlhXG4gKiB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9LlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtBUkcwfSBhcmcwXG4gKiBAcGFyYW0ge0FSRzF9IGFyZzFcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMgPSAoZXZlbnRIYW5kbGVyLCBhcmcwLCBhcmcxKSA9PlxuICBjYWxsQWxsKGV2ZW50SGFuZGxlci5sLCBbYXJnMCwgYXJnMV0pO1xuXG5jbGFzcyBJRCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50IGNsaWVudCBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY2xpZW50LCBjbG9jaykge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBpZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgLyoqXG4gICAgICogdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lEIHwgbnVsbH0gYVxuICogQHBhcmFtIHtJRCB8IG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNvbXBhcmVJRHMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAoYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuY2xpZW50ID09PSBiLmNsaWVudCAmJiBhLmNsb2NrID09PSBiLmNsb2NrKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUlEID0gKGNsaWVudCwgY2xvY2spID0+IG5ldyBJRChjbGllbnQsIGNsb2NrKTtcblxuLyoqXG4gKiBUaGUgdG9wIHR5cGVzIGFyZSBtYXBwZWQgZnJvbSB5LnNoYXJlLmdldChrZXluYW1lKSA9PiB0eXBlLlxuICogYHR5cGVgIGRvZXMgbm90IHN0b3JlIGFueSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYGtleW5hbWVgLlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgY29ycmVjdCBga2V5bmFtZWAgZm9yIGB0eXBlYCBhbmQgdGhyb3dzIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kUm9vdFR5cGVLZXkgPSB0eXBlID0+IHtcbiAgLy8gQHRzLWlnbm9yZSBfeSBtdXN0IGJlIGRlZmluZWQsIG90aGVyd2lzZSB1bmV4cGVjdGVkIGNhc2VcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdHlwZS5kb2Muc2hhcmUuZW50cmllcygpKSB7XG4gICAgaWYgKHZhbHVlID09PSB0eXBlKSB7XG4gICAgICByZXR1cm4ga2V5XG4gICAgfVxuICB9XG4gIHRocm93IHVuZXhwZWN0ZWRDYXNlKClcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYHBhcmVudGAgaXMgYSBwYXJlbnQgb2YgYGNoaWxkYC5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBjaGlsZFxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBgcGFyZW50YCBpcyBhIHBhcmVudCBvZiBgY2hpbGRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgY2hpbGQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQucGFyZW50KS5faXRlbTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8qKlxuICogQ29udmVuaWVudCBoZWxwZXIgdG8gbG9nIHR5cGUgaW5mb3JtYXRpb24uXG4gKlxuICogRG8gbm90IHVzZSBpbiBwcm9kdWN0aXZlIHN5c3RlbXMgYXMgdGhlIG91dHB1dCBjYW4gYmUgaW1tZW5zZSFcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKi9cbmNvbnN0IGxvZ1R5cGUgPSB0eXBlID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuKSB7XG4gICAgcmVzLnB1c2gobik7XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgY29uc29sZS5sb2coJ0NoaWxkcmVuOiAnLCByZXMpO1xuICBjb25zb2xlLmxvZygnQ2hpbGRyZW4gY29udGVudDogJywgcmVzLmZpbHRlcihtID0+ICFtLmRlbGV0ZWQpLm1hcChtID0+IG0uY29udGVudCkpO1xufTtcblxuY2xhc3MgUGVybWFuZW50VXNlckRhdGEge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKiBAcGFyYW0ge1lNYXA8YW55Pn0gW3N0b3JlVHlwZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MsIHN0b3JlVHlwZSA9IGRvYy5nZXRNYXAoJ3VzZXJzJykpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxEZWxldGVTZXQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGRzcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnl1c2VycyA9IHN0b3JlVHlwZTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAvKipcbiAgICAgKiBNYXBzIGZyb20gY2xpZW50aWQgdG8gdXNlckRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRzcyA9IGRzcztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1lNYXA8YW55Pn0gdXNlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyRGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBjb25zdCBpbml0VXNlciA9ICh1c2VyLCB1c2VyRGVzY3JpcHRpb24pID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1lBcnJheTxVaW50OEFycmF5Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZHMgPSB1c2VyLmdldCgnZHMnKTtcbiAgICAgIGNvbnN0IGlkcyA9IHVzZXIuZ2V0KCdpZHMnKTtcbiAgICAgIGNvbnN0IGFkZENsaWVudElkID0gLyoqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZCAqLyBjbGllbnRpZCA9PiB0aGlzLmNsaWVudHMuc2V0KGNsaWVudGlkLCB1c2VyRGVzY3JpcHRpb24pO1xuICAgICAgZHMub2JzZXJ2ZSgvKiogQHBhcmFtIHtZQXJyYXlFdmVudDxhbnk+fSBldmVudCAqLyBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LmNoYW5nZXMuYWRkZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpLmZvckVhY2goZW5jb2RlZERzID0+IHtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkRHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgIHRoaXMuZHNzLnNldCh1c2VyRGVzY3JpcHRpb24sIG1lcmdlRGVsZXRlU2V0cyhbdGhpcy5kc3MuZ2V0KHVzZXJEZXNjcmlwdGlvbikgfHwgY3JlYXRlRGVsZXRlU2V0KCksIHJlYWREZWxldGVTZXQobmV3IERTRGVjb2RlclYxKGNyZWF0ZURlY29kZXIoZW5jb2RlZERzKSkpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kc3Muc2V0KHVzZXJEZXNjcmlwdGlvbiwgbWVyZ2VEZWxldGVTZXRzKGRzLm1hcChlbmNvZGVkRHMgPT4gcmVhZERlbGV0ZVNldChuZXcgRFNEZWNvZGVyVjEoY3JlYXRlRGVjb2RlcihlbmNvZGVkRHMpKSkpKSk7XG4gICAgICBpZHMub2JzZXJ2ZSgvKiogQHBhcmFtIHtZQXJyYXlFdmVudDxhbnk+fSBldmVudCAqLyBldmVudCA9PlxuICAgICAgICBldmVudC5jaGFuZ2VzLmFkZGVkLmZvckVhY2goaXRlbSA9PiBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpLmZvckVhY2goYWRkQ2xpZW50SWQpKVxuICAgICAgKTtcbiAgICAgIGlkcy5mb3JFYWNoKGFkZENsaWVudElkKTtcbiAgICB9O1xuICAgIC8vIG9ic2VydmUgdXNlcnNcbiAgICBzdG9yZVR5cGUub2JzZXJ2ZShldmVudCA9PiB7XG4gICAgICBldmVudC5rZXlzQ2hhbmdlZC5mb3JFYWNoKHVzZXJEZXNjcmlwdGlvbiA9PlxuICAgICAgICBpbml0VXNlcihzdG9yZVR5cGUuZ2V0KHVzZXJEZXNjcmlwdGlvbiksIHVzZXJEZXNjcmlwdGlvbilcbiAgICAgICk7XG4gICAgfSk7XG4gICAgLy8gYWRkIGludGlhbCBkYXRhXG4gICAgc3RvcmVUeXBlLmZvckVhY2goaW5pdFVzZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudGlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyRGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25mXVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYW5zYWN0aW9uLCBEZWxldGVTZXQpOmJvb2xlYW59IFtjb25mLmZpbHRlcl1cbiAgICovXG4gIHNldFVzZXJNYXBwaW5nIChkb2MsIGNsaWVudGlkLCB1c2VyRGVzY3JpcHRpb24sIHsgZmlsdGVyID0gKCkgPT4gdHJ1ZSB9ID0ge30pIHtcbiAgICBjb25zdCB1c2VycyA9IHRoaXMueXVzZXJzO1xuICAgIGxldCB1c2VyID0gdXNlcnMuZ2V0KHVzZXJEZXNjcmlwdGlvbik7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB1c2VyID0gbmV3IFlNYXAoKTtcbiAgICAgIHVzZXIuc2V0KCdpZHMnLCBuZXcgWUFycmF5KCkpO1xuICAgICAgdXNlci5zZXQoJ2RzJywgbmV3IFlBcnJheSgpKTtcbiAgICAgIHVzZXJzLnNldCh1c2VyRGVzY3JpcHRpb24sIHVzZXIpO1xuICAgIH1cbiAgICB1c2VyLmdldCgnaWRzJykucHVzaChbY2xpZW50aWRdKTtcbiAgICB1c2Vycy5vYnNlcnZlKGV2ZW50ID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB1c2VyT3ZlcndyaXRlID0gdXNlcnMuZ2V0KHVzZXJEZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICh1c2VyT3ZlcndyaXRlICE9PSB1c2VyKSB7XG4gICAgICAgICAgLy8gdXNlciB3YXMgb3ZlcndyaXR0ZW4sIHBvcnQgYWxsIGRhdGEgb3ZlciB0byB0aGUgbmV4dCB1c2VyIG9iamVjdFxuICAgICAgICAgIC8vIEB0b2RvIEV4cGVyaW1lbnQgd2l0aCBZLlNldHMgaGVyZVxuICAgICAgICAgIHVzZXIgPSB1c2VyT3ZlcndyaXRlO1xuICAgICAgICAgIC8vIEB0b2RvIGl0ZXJhdGUgb3ZlciBvbGQgdHlwZVxuICAgICAgICAgIHRoaXMuY2xpZW50cy5mb3JFYWNoKChfdXNlckRlc2NyaXB0aW9uLCBjbGllbnRpZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXJEZXNjcmlwdGlvbiA9PT0gX3VzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICB1c2VyLmdldCgnaWRzJykucHVzaChbY2xpZW50aWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYxKCk7XG4gICAgICAgICAgY29uc3QgZHMgPSB0aGlzLmRzcy5nZXQodXNlckRlc2NyaXB0aW9uKTtcbiAgICAgICAgICBpZiAoZHMpIHtcbiAgICAgICAgICAgIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKTtcbiAgICAgICAgICAgIHVzZXIuZ2V0KCdkcycpLnB1c2goW2VuY29kZXIudG9VaW50OEFycmF5KCldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0pO1xuICAgIGRvYy5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIC8qKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAqLyB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeWRzID0gdXNlci5nZXQoJ2RzJyk7XG4gICAgICAgIGNvbnN0IGRzID0gdHJhbnNhY3Rpb24uZGVsZXRlU2V0O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24ubG9jYWwgJiYgZHMuY2xpZW50cy5zaXplID4gMCAmJiBmaWx0ZXIodHJhbnNhY3Rpb24sIGRzKSkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjEoKTtcbiAgICAgICAgICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcyk7XG4gICAgICAgICAgeWRzLnB1c2goW2VuY29kZXIudG9VaW50OEFycmF5KCldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudGlkXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGdldFVzZXJCeUNsaWVudElkIChjbGllbnRpZCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudHMuZ2V0KGNsaWVudGlkKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHJldHVybiB7c3RyaW5nIHwgbnVsbH1cbiAgICovXG4gIGdldFVzZXJCeURlbGV0ZWRJZCAoaWQpIHtcbiAgICBmb3IgKGNvbnN0IFt1c2VyRGVzY3JpcHRpb24sIGRzXSBvZiB0aGlzLmRzcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChpc0RlbGV0ZWQoZHMsIGlkKSkge1xuICAgICAgICByZXR1cm4gdXNlckRlc2NyaXB0aW9uXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBBIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGJhc2VkIG9uIHRoZSBZanMgbW9kZWwgYW5kIGlzIG5vdCBhZmZlY3RlZCBieSBkb2N1bWVudCBjaGFuZ2VzLlxuICogRS5nLiBJZiB5b3UgcGxhY2UgYSByZWxhdGl2ZSBwb3NpdGlvbiBiZWZvcmUgYSBjZXJ0YWluIGNoYXJhY3RlciwgaXQgd2lsbCBhbHdheXMgcG9pbnQgdG8gdGhpcyBjaGFyYWN0ZXIuXG4gKiBJZiB5b3UgcGxhY2UgYSByZWxhdGl2ZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIGEgdHlwZSwgaXQgd2lsbCBhbHdheXMgcG9pbnQgdG8gdGhlIGVuZCBvZiB0aGUgdHlwZS5cbiAqXG4gKiBBIG51bWVyaWMgcG9zaXRpb24gaXMgb2Z0ZW4gdW5zdWl0ZWQgZm9yIHVzZXIgc2VsZWN0aW9ucywgYmVjYXVzZSBpdCBkb2VzIG5vdCBjaGFuZ2Ugd2hlbiBjb250ZW50IGlzIGluc2VydGVkXG4gKiBiZWZvcmUgb3IgYWZ0ZXIuXG4gKlxuICogYGBgSW5zZXJ0KDAsICd4JykoJ2F8YmMnKSA9ICd4YXxiYydgYGAgV2hlcmUgfCBpcyB0aGUgcmVsYXRpdmUgcG9zaXRpb24uXG4gKlxuICogT25lIG9mIHRoZSBwcm9wZXJ0aWVzIG11c3QgYmUgZGVmaW5lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBDdXJyZW50IGN1cnNvciBwb3NpdGlvbiBpcyBhdCBwb3NpdGlvbiAxMFxuICogICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21JbmRleCh5VGV4dCwgMTApXG4gKiAgIC8vIG1vZGlmeSB5VGV4dFxuICogICB5VGV4dC5pbnNlcnQoMCwgJ2FiYycpXG4gKiAgIHlUZXh0LmRlbGV0ZSgzLCAxMClcbiAqICAgLy8gQ29tcHV0ZSB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gKiAgIGNvbnN0IGFic29sdXRlUG9zaXRpb24gPSBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oeSwgcmVsYXRpdmVQb3NpdGlvbilcbiAqICAgYWJzb2x1dGVQb3NpdGlvbi50eXBlID09PSB5VGV4dCAvLyA9PiB0cnVlXG4gKiAgIGNvbnNvbGUubG9nKCdjdXJzb3IgbG9jYXRpb24gaXMgJyArIGFic29sdXRlUG9zaXRpb24uaW5kZXgpIC8vID0+IGN1cnNvciBsb2NhdGlvbiBpcyAzXG4gKlxuICovXG5jbGFzcyBSZWxhdGl2ZVBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR8bnVsbH0gdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB0bmFtZVxuICAgKiBAcGFyYW0ge0lEfG51bGx9IGl0ZW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFzc29jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgdG5hbWUsIGl0ZW0sIGFzc29jID0gMCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJRHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMudG5hbWUgPSB0bmFtZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgLyoqXG4gICAgICogQSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkIHRvIGEgc3BlY2lmaWMgY2hhcmFjdGVyLiBCeSBkZWZhdWx0XG4gICAgICogYXNzb2MgPj0gMCwgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNoYXJhY3RlclxuICAgICAqIGFmdGVyIHRoZSBtZWFudCBwb3NpdGlvbi5cbiAgICAgKiBJLmUuIHBvc2l0aW9uIDEgaW4gJ2FiJyBpcyBhc3NvY2lhdGVkIHRvIGNoYXJhY3RlciAnYicuXG4gICAgICpcbiAgICAgKiBJZiBhc3NvYyA8IDAsIHRoZW4gdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNhaGFyYWN0ZXJcbiAgICAgKiBiZWZvcmUgdGhlIG1lYW50IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFzc29jID0gYXNzb2M7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0ganNvblxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OID0ganNvbiA9PiBuZXcgUmVsYXRpdmVQb3NpdGlvbihqc29uLnR5cGUgPT0gbnVsbCA/IG51bGwgOiBjcmVhdGVJRChqc29uLnR5cGUuY2xpZW50LCBqc29uLnR5cGUuY2xvY2spLCBqc29uLnRuYW1lIHx8IG51bGwsIGpzb24uaXRlbSA9PSBudWxsID8gbnVsbCA6IGNyZWF0ZUlEKGpzb24uaXRlbS5jbGllbnQsIGpzb24uaXRlbS5jbG9jaykpO1xuXG5jbGFzcyBBYnNvbHV0ZVBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgaW5kZXgsIGFzc29jID0gMCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuYXNzb2MgPSBhc3NvYztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbiA9ICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSA9PiBuZXcgQWJzb2x1dGVQb3NpdGlvbih0eXBlLCBpbmRleCwgYXNzb2MpO1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7SUR8bnVsbH0gaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiA9ICh0eXBlLCBpdGVtLCBhc3NvYykgPT4ge1xuICBsZXQgdHlwZWlkID0gbnVsbDtcbiAgbGV0IHRuYW1lID0gbnVsbDtcbiAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICB0bmFtZSA9IGZpbmRSb290VHlwZUtleSh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlaWQgPSBjcmVhdGVJRCh0eXBlLl9pdGVtLmlkLmNsaWVudCwgdHlwZS5faXRlbS5pZC5jbG9jayk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWxhdGl2ZVBvc2l0aW9uKHR5cGVpZCwgdG5hbWUsIGl0ZW0sIGFzc29jKVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWxhdGl2ZVBvc2l0aW9uIGJhc2VkIG9uIGEgYWJzb2x1dGUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZSBUaGUgYmFzZSB0eXBlIChlLmcuIFlUZXh0IG9yIFlBcnJheSkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGFic29sdXRlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4ID0gKHR5cGUsIGluZGV4LCBhc3NvYyA9IDApID0+IHtcbiAgbGV0IHQgPSB0eXBlLl9zdGFydDtcbiAgaWYgKGFzc29jIDwgMCkge1xuICAgIC8vIGFzc29jaWF0ZWQgdG8gdGhlIGxlZnQgY2hhcmFjdGVyIG9yIHRoZSBiZWdpbm5pbmcgb2YgYSB0eXBlLCBpbmNyZW1lbnQgaW5kZXggaWYgcG9zc2libGUuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBudWxsLCBhc3NvYylcbiAgICB9XG4gICAgaW5kZXgtLTtcbiAgfVxuICB3aGlsZSAodCAhPT0gbnVsbCkge1xuICAgIGlmICghdC5kZWxldGVkICYmIHQuY291bnRhYmxlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPiBpbmRleCkge1xuICAgICAgICAvLyBjYXNlIDE6IGZvdW5kIHBvc2l0aW9uIHNvbWV3aGVyZSBpbiB0aGUgbGlua2VkIGxpc3RcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgY3JlYXRlSUQodC5pZC5jbGllbnQsIHQuaWQuY2xvY2sgKyBpbmRleCksIGFzc29jKVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gdC5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh0LnJpZ2h0ID09PSBudWxsICYmIGFzc29jIDwgMCkge1xuICAgICAgLy8gbGVmdC1hc3NvY2lhdGVkIHBvc2l0aW9uLCByZXR1cm4gbGFzdCBhdmFpbGFibGUgaWRcbiAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIHQubGFzdElkLCBhc3NvYylcbiAgICB9XG4gICAgdCA9IHQucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgbnVsbCwgYXNzb2MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHJldHVybiB7QWJzb2x1dGVQb3NpdGlvbnxudWxsfVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24gPSAocnBvcywgZG9jKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICBjb25zdCByaWdodElEID0gcnBvcy5pdGVtO1xuICBjb25zdCB0eXBlSUQgPSBycG9zLnR5cGU7XG4gIGNvbnN0IHRuYW1lID0gcnBvcy50bmFtZTtcbiAgY29uc3QgYXNzb2MgPSBycG9zLmFzc29jO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCBpbmRleCA9IDA7XG4gIGlmIChyaWdodElEICE9PSBudWxsKSB7XG4gICAgaWYgKGdldFN0YXRlKHN0b3JlLCByaWdodElELmNsaWVudCkgPD0gcmlnaHRJRC5jbG9jaykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgY29uc3QgcmVzID0gZm9sbG93UmVkb25lKHN0b3JlLCByaWdodElEKTtcbiAgICBjb25zdCByaWdodCA9IHJlcy5pdGVtO1xuICAgIGlmICghKHJpZ2h0IGluc3RhbmNlb2YgSXRlbSkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KTtcbiAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgICBpbmRleCA9IChyaWdodC5kZWxldGVkIHx8ICFyaWdodC5jb3VudGFibGUpID8gMCA6IChyZXMuZGlmZiArIChhc3NvYyA+PSAwID8gMCA6IDEpKTsgLy8gYWRqdXN0IHBvc2l0aW9uIGJhc2VkIG9uIGxlZnQgYXNzb2NpYXRpb24gaWYgbmVjZXNzYXJ5XG4gICAgICBsZXQgbiA9IHJpZ2h0LmxlZnQ7XG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgICAgIGluZGV4ICs9IG4ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuLmxlZnQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0bmFtZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IGRvYy5nZXQodG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZUlEICE9PSBudWxsKSB7XG4gICAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIHR5cGVJRC5jbGllbnQpIDw9IHR5cGVJRC5jbG9jaykge1xuICAgICAgICAvLyB0eXBlIGRvZXMgbm90IGV4aXN0IHlldFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY29uc3QgeyBpdGVtIH0gPSBmb2xsb3dSZWRvbmUoc3RvcmUsIHR5cGVJRCk7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgaXRlbS5jb250ZW50IGluc3RhbmNlb2YgQ29udGVudFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGl0ZW0uY29udGVudC50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RydWN0IGlzIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgaWYgKGFzc29jID49IDApIHtcbiAgICAgIGluZGV4ID0gdHlwZS5fbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uKHR5cGUsIGluZGV4LCBycG9zLmFzc29jKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb258bnVsbH0gYVxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyA9IChhLCBiKSA9PiBhID09PSBiIHx8IChcbiAgYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEudG5hbWUgPT09IGIudG5hbWUgJiYgY29tcGFyZUlEcyhhLml0ZW0sIGIuaXRlbSkgJiYgY29tcGFyZUlEcyhhLnR5cGUsIGIudHlwZSkgJiYgYS5hc3NvYyA9PT0gYi5hc3NvY1xuKTtcblxuY2xhc3MgU25hcHNob3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gICAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzdiBzdGF0ZSBtYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkcywgc3YpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RGVsZXRlU2V0fVxuICAgICAqL1xuICAgIHRoaXMuZHMgPSBkcztcbiAgICAvKipcbiAgICAgKiBTdGF0ZSBNYXBcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuc3YgPSBzdjtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXAxXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwMlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxTbmFwc2hvdHMgPSAoc25hcDEsIHNuYXAyKSA9PiB7XG4gIGNvbnN0IGRzMSA9IHNuYXAxLmRzLmNsaWVudHM7XG4gIGNvbnN0IGRzMiA9IHNuYXAyLmRzLmNsaWVudHM7XG4gIGNvbnN0IHN2MSA9IHNuYXAxLnN2O1xuICBjb25zdCBzdjIgPSBzbmFwMi5zdjtcbiAgaWYgKHN2MS5zaXplICE9PSBzdjIuc2l6ZSB8fCBkczEuc2l6ZSAhPT0gZHMyLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdjEuZW50cmllcygpKSB7XG4gICAgaWYgKHN2Mi5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRzaXRlbXMxXSBvZiBkczEuZW50cmllcygpKSB7XG4gICAgY29uc3QgZHNpdGVtczIgPSBkczIuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgaWYgKGRzaXRlbXMxLmxlbmd0aCAhPT0gZHNpdGVtczIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkc2l0ZW1zMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZHNpdGVtMSA9IGRzaXRlbXMxW2ldO1xuICAgICAgY29uc3QgZHNpdGVtMiA9IGRzaXRlbXMyW2ldO1xuICAgICAgaWYgKGRzaXRlbTEuY2xvY2sgIT09IGRzaXRlbTIuY2xvY2sgfHwgZHNpdGVtMS5sZW4gIT09IGRzaXRlbTIubGVuKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtBYnN0cmFjdERTRW5jb2Rlcn0gW2VuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVTbmFwc2hvdFYyID0gKHNuYXBzaG90LCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYyKCkpID0+IHtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2Rlciwgc25hcHNob3QuZHMpO1xuICB3cml0ZVN0YXRlVmVjdG9yKGVuY29kZXIsIHNuYXBzaG90LnN2KTtcbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVNuYXBzaG90ID0gc25hcHNob3QgPT4gZW5jb2RlU25hcHNob3RWMihzbmFwc2hvdCwgbmV3IERlZmF1bHREU0VuY29kZXIoKSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEBwYXJhbSB7QWJzdHJhY3REU0RlY29kZXJ9IFtkZWNvZGVyXVxuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IGRlY29kZVNuYXBzaG90VjIgPSAoYnVmLCBkZWNvZGVyID0gbmV3IERTRGVjb2RlclYyKGNyZWF0ZURlY29kZXIoYnVmKSkpID0+IHtcbiAgcmV0dXJuIG5ldyBTbmFwc2hvdChyZWFkRGVsZXRlU2V0KGRlY29kZXIpLCByZWFkU3RhdGVWZWN0b3IoZGVjb2RlcikpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuY29uc3QgZGVjb2RlU25hcHNob3QgPSBidWYgPT4gZGVjb2RlU25hcHNob3RWMihidWYsIG5ldyBEU0RlY29kZXJWMShjcmVhdGVEZWNvZGVyKGJ1ZikpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzbVxuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IGNyZWF0ZVNuYXBzaG90ID0gKGRzLCBzbSkgPT4gbmV3IFNuYXBzaG90KGRzLCBzbSk7XG5cbmNvbnN0IGVtcHR5U25hcHNob3QgPSBjcmVhdGVTbmFwc2hvdChjcmVhdGVEZWxldGVTZXQoKSwgbmV3IE1hcCgpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuY29uc3Qgc25hcHNob3QgPSBkb2MgPT4gY3JlYXRlU25hcHNob3QoY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlKGRvYy5zdG9yZSksIGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtTbmFwc2hvdHx1bmRlZmluZWR9IHNuYXBzaG90XG4gKlxuICogQHByb3RlY3RlZFxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGlzVmlzaWJsZSA9IChpdGVtLCBzbmFwc2hvdCkgPT4gc25hcHNob3QgPT09IHVuZGVmaW5lZCA/ICFpdGVtLmRlbGV0ZWQgOiAoXG4gIHNuYXBzaG90LnN2LmhhcyhpdGVtLmlkLmNsaWVudCkgJiYgKHNuYXBzaG90LnN2LmdldChpdGVtLmlkLmNsaWVudCkgfHwgMCkgPiBpdGVtLmlkLmNsb2NrICYmICFpc0RlbGV0ZWQoc25hcHNob3QuZHMsIGl0ZW0uaWQpXG4pO1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICovXG5jb25zdCBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBtZXRhID0gc2V0SWZVbmRlZmluZWQodHJhbnNhY3Rpb24ubWV0YSwgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cywgY3JlYXRlKTtcbiAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5kb2Muc3RvcmU7XG4gIC8vIGNoZWNrIGlmIHdlIGFscmVhZHkgc3BsaXQgZm9yIHRoaXMgc25hcHNob3RcbiAgaWYgKCFtZXRhLmhhcyhzbmFwc2hvdCkpIHtcbiAgICBzbmFwc2hvdC5zdi5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY2xpZW50LCBjbG9jaykpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc25hcHNob3QuZHMsIGl0ZW0gPT4ge30pO1xuICAgIG1ldGEuYWRkKHNuYXBzaG90KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY30gb3JpZ2luRG9jXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEb2N9IFtuZXdEb2NdIE9wdGlvbmFsbHksIHlvdSBtYXkgZGVmaW5lIHRoZSBZanMgZG9jdW1lbnQgdGhhdCByZWNlaXZlcyB0aGUgZGF0YSBmcm9tIG9yaWdpbkRvY1xuICogQHJldHVybiB7RG9jfVxuICovXG5jb25zdCBjcmVhdGVEb2NGcm9tU25hcHNob3QgPSAob3JpZ2luRG9jLCBzbmFwc2hvdCwgbmV3RG9jID0gbmV3IERvYygpKSA9PiB7XG4gIGlmIChvcmlnaW5Eb2MuZ2MpIHtcbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyeSB0byByZXN0b3JlIGEgR0MtZWQgZG9jdW1lbnQsIGJlY2F1c2Ugc29tZSBvZiB0aGUgcmVzdG9yZWQgaXRlbXMgbWlnaHQgaGF2ZSB0aGVpciBjb250ZW50IGRlbGV0ZWRcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29yaWdpbkRvYyBtdXN0IG5vdCBiZSBnYXJiYWdlIGNvbGxlY3RlZCcpXG4gIH1cbiAgY29uc3QgeyBzdiwgZHMgfSA9IHNuYXBzaG90O1xuXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gIG9yaWdpbkRvYy50cmFuc2FjdCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIHN2LmZvckVhY2goY2xvY2sgPT4ge1xuICAgICAgaWYgKGNsb2NrID4gMCkge1xuICAgICAgICBzaXplKys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHNpemUpO1xuICAgIC8vIHNwbGl0dGluZyB0aGUgc3RydWN0cyBiZWZvcmUgd3JpdGluZyB0aGVtIHRvIHRoZSBlbmNvZGVyXG4gICAgZm9yIChjb25zdCBbY2xpZW50LCBjbG9ja10gb2Ygc3YpIHtcbiAgICAgIGlmIChjbG9jayA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUob3JpZ2luRG9jLnN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJ1Y3RzID0gb3JpZ2luRG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgICBjb25zdCBsYXN0U3RydWN0SW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayAtIDEpO1xuICAgICAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBsYXN0U3RydWN0SW5kZXggKyAxKTtcbiAgICAgIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KTtcbiAgICAgIC8vIGZpcnN0IGNsb2NrIHdyaXR0ZW4gaXMgMFxuICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdFN0cnVjdEluZGV4OyBpKyspIHtcbiAgICAgICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICB9KTtcblxuICBhcHBseVVwZGF0ZVYyKG5ld0RvYywgZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgJ3NuYXBzaG90Jyk7XG4gIHJldHVybiBuZXdEb2Ncbn07XG5cbmNsYXNzIFN0cnVjdFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLEFycmF5PEdDfEl0ZW0+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogU3RvcmUgaW5jb21wbGV0ZWQgc3RydWN0IHJlYWRzIGhlcmVcbiAgICAgKiBgaWAgZGVub3RlcyB0byB0aGUgbmV4dCByZWFkIG9wZXJhdGlvblxuICAgICAqIFdlIGNvdWxkIHNoaWZ0IHRoZSBhcnJheSBvZiByZWZzIGluc3RlYWQsIGJ1dCBzaGlmdCBpcyBpbmNyZWRpYmxlXG4gICAgICogc2xvdyBpbiBDaHJvbWUgZm9yIGFycmF5cyB3aXRoIG1vcmUgdGhhbiAxMDBrIGVsZW1lbnRzXG4gICAgICogQHNlZSB0cnlSZXN1bWVQZW5kaW5nU3RydWN0UmVmc1xuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLHtpOm51bWJlcixyZWZzOkFycmF5PEdDfEl0ZW0+fT59XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nQ2xpZW50c1N0cnVjdFJlZnMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogU3RhY2sgb2YgcGVuZGluZyBzdHJ1Y3RzIHdhaXRpbmcgZm9yIHN0cnVjdCBkZXBlbmRlbmNpZXNcbiAgICAgKiBNYXhpbXVtIGxlbmd0aCBvZiBzdGFjayBpcyBzdHJ1Y3RSZWFkZXJzLnNpemVcbiAgICAgKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nU3RhY2sgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RFNEZWNvZGVyVjI+fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ0RlbGV0ZVJlYWRlcnMgPSBbXTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc3RhdGVzIGFzIGEgTWFwPGNsaWVudCxjbG9jaz4uXG4gKiBOb3RlIHRoYXQgY2xvY2sgcmVmZXJzIHRvIHRoZSBuZXh0IGV4cGVjdGVkIGNsb2NrIGlkLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59XG4gKlxuICogQHB1YmxpY1xuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFN0YXRlVmVjdG9yID0gc3RvcmUgPT4ge1xuICBjb25zdCBzbSA9IG5ldyBNYXAoKTtcbiAgc3RvcmUuY2xpZW50cy5mb3JFYWNoKChzdHJ1Y3RzLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gICAgc20uc2V0KGNsaWVudCwgc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCk7XG4gIH0pO1xuICByZXR1cm4gc21cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqXG4gKiBAcHVibGljXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0U3RhdGUgPSAoc3RvcmUsIGNsaWVudCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KTtcbiAgaWYgKHN0cnVjdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgY29uc3QgbGFzdFN0cnVjdCA9IHN0cnVjdHNbc3RydWN0cy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGxhc3RTdHJ1Y3QuaWQuY2xvY2sgKyBsYXN0U3RydWN0Lmxlbmd0aFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtHQ3xJdGVtfSBzdHJ1Y3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFkZFN0cnVjdCA9IChzdG9yZSwgc3RydWN0KSA9PiB7XG4gIGxldCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoc3RydWN0LmlkLmNsaWVudCk7XG4gIGlmIChzdHJ1Y3RzID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJ1Y3RzID0gW107XG4gICAgc3RvcmUuY2xpZW50cy5zZXQoc3RydWN0LmlkLmNsaWVudCwgc3RydWN0cyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGFzdFN0cnVjdCA9IHN0cnVjdHNbc3RydWN0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdFN0cnVjdC5pZC5jbG9jayArIGxhc3RTdHJ1Y3QubGVuZ3RoICE9PSBzdHJ1Y3QuaWQuY2xvY2spIHtcbiAgICAgIHRocm93IHVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gIH1cbiAgc3RydWN0cy5wdXNoKHN0cnVjdCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmRJbmRleFNTID0gKHN0cnVjdHMsIGNsb2NrKSA9PiB7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gc3RydWN0cy5sZW5ndGggLSAxO1xuICBsZXQgbWlkID0gc3RydWN0c1tyaWdodF07XG4gIGxldCBtaWRjbG9jayA9IG1pZC5pZC5jbG9jaztcbiAgaWYgKG1pZGNsb2NrID09PSBjbG9jaykge1xuICAgIHJldHVybiByaWdodFxuICB9XG4gIC8vIEB0b2RvIGRvZXMgaXQgZXZlbiBtYWtlIHNlbnNlIHRvIHBpdm90IHRoZSBzZWFyY2g/XG4gIC8vIElmIGEgZ29vZCBzcGxpdCBtaXNzZXMsIGl0IG1pZ2h0IGFjdHVhbGx5IGluY3JlYXNlIHRoZSB0aW1lIHRvIGZpbmQgdGhlIGNvcnJlY3QgaXRlbS5cbiAgLy8gQ3VycmVudGx5LCB0aGUgb25seSBhZHZhbnRhZ2UgaXMgdGhhdCBzZWFyY2ggd2l0aCBwaXZvdGluZyBtaWdodCBmaW5kIHRoZSBpdGVtIG9uIHRoZSBmaXJzdCB0cnkuXG4gIGxldCBtaWRpbmRleCA9IGZsb29yKChjbG9jayAvIChtaWRjbG9jayArIG1pZC5sZW5ndGggLSAxKSkgKiByaWdodCk7IC8vIHBpdm90aW5nIHRoZSBzZWFyY2hcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBtaWQgPSBzdHJ1Y3RzW21pZGluZGV4XTtcbiAgICBtaWRjbG9jayA9IG1pZC5pZC5jbG9jaztcbiAgICBpZiAobWlkY2xvY2sgPD0gY2xvY2spIHtcbiAgICAgIGlmIChjbG9jayA8IG1pZGNsb2NrICsgbWlkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWlkaW5kZXhcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBtaWRpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0ID0gbWlkaW5kZXggLSAxO1xuICAgIH1cbiAgICBtaWRpbmRleCA9IGZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG4gIH1cbiAgLy8gQWx3YXlzIGNoZWNrIHN0YXRlIGJlZm9yZSBsb29raW5nIGZvciBhIHN0cnVjdCBpbiBTdHJ1Y3RTdG9yZVxuICAvLyBUaGVyZWZvcmUgdGhlIGNhc2Ugb2Ygbm90IGZpbmRpbmcgYSBzdHJ1Y3QgaXMgdW5leHBlY3RlZFxuICB0aHJvdyB1bmV4cGVjdGVkQ2FzZSgpXG59O1xuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtHQ3xJdGVtfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZCA9IChzdG9yZSwgaWQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn1cbiAgICovXG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGlkLmNsaWVudCk7XG4gIHJldHVybiBzdHJ1Y3RzW2ZpbmRJbmRleFNTKHN0cnVjdHMsIGlkLmNsb2NrKV1cbn07XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0SXRlbSA9IC8qKiBAdHlwZSB7ZnVuY3Rpb24oU3RydWN0U3RvcmUsSUQpOkl0ZW19ICovIChmaW5kKTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxJdGVtfEdDPn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKi9cbmNvbnN0IGZpbmRJbmRleENsZWFuU3RhcnQgPSAodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spO1xuICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4XTtcbiAgaWYgKHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrICYmIHN0cnVjdCBpbnN0YW5jZW9mIEl0ZW0pIHtcbiAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCArIDEsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBjbG9jayAtIHN0cnVjdC5pZC5jbG9jaykpO1xuICAgIHJldHVybiBpbmRleCArIDFcbiAgfVxuICByZXR1cm4gaW5kZXhcbn07XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRJdGVtQ2xlYW5TdGFydCA9ICh0cmFuc2FjdGlvbiwgaWQpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8SXRlbT59ICovICh0cmFuc2FjdGlvbi5kb2Muc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KSk7XG4gIHJldHVybiBzdHJ1Y3RzW2ZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGlkLmNsb2NrKV1cbn07XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtJdGVtfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0SXRlbUNsZWFuRW5kID0gKHRyYW5zYWN0aW9uLCBzdG9yZSwgaWQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxJdGVtPn1cbiAgICovXG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGlkLmNsaWVudCk7XG4gIGNvbnN0IGluZGV4ID0gZmluZEluZGV4U1Moc3RydWN0cywgaWQuY2xvY2spO1xuICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4XTtcbiAgaWYgKGlkLmNsb2NrICE9PSBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoIC0gMSAmJiBzdHJ1Y3QuY29uc3RydWN0b3IgIT09IEdDKSB7XG4gICAgc3RydWN0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgaWQuY2xvY2sgLSBzdHJ1Y3QuaWQuY2xvY2sgKyAxKSk7XG4gIH1cbiAgcmV0dXJuIHN0cnVjdFxufTtcblxuLyoqXG4gKiBSZXBsYWNlIGBpdGVtYCB3aXRoIGBuZXdpdGVtYCBpbiBzdG9yZVxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7R0N8SXRlbX0gc3RydWN0XG4gKiBAcGFyYW0ge0dDfEl0ZW19IG5ld1N0cnVjdFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVwbGFjZVN0cnVjdCA9IChzdG9yZSwgc3RydWN0LCBuZXdTdHJ1Y3QpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChzdHJ1Y3QuaWQuY2xpZW50KSk7XG4gIHN0cnVjdHNbZmluZEluZGV4U1Moc3RydWN0cywgc3RydWN0LmlkLmNsb2NrKV0gPSBuZXdTdHJ1Y3Q7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhIHJhbmdlIG9mIHN0cnVjdHNcbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxJdGVtfEdDPn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrU3RhcnQgSW5jbHVzaXZlIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEdDfEl0ZW0pOnZvaWR9IGZcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXRlcmF0ZVN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrU3RhcnQsIGxlbiwgZikgPT4ge1xuICBpZiAobGVuID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgY2xvY2tFbmQgPSBjbG9ja1N0YXJ0ICsgbGVuO1xuICBsZXQgaW5kZXggPSBmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja1N0YXJ0KTtcbiAgbGV0IHN0cnVjdDtcbiAgZG8ge1xuICAgIHN0cnVjdCA9IHN0cnVjdHNbaW5kZXgrK107XG4gICAgaWYgKGNsb2NrRW5kIDwgc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCkge1xuICAgICAgZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tFbmQpO1xuICAgIH1cbiAgICBmKHN0cnVjdCk7XG4gIH0gd2hpbGUgKGluZGV4IDwgc3RydWN0cy5sZW5ndGggJiYgc3RydWN0c1tpbmRleF0uaWQuY2xvY2sgPCBjbG9ja0VuZClcbn07XG5cbi8qKlxuICogQSB0cmFuc2FjdGlvbiBpcyBjcmVhdGVkIGZvciBldmVyeSBjaGFuZ2Ugb24gdGhlIFlqcyBtb2RlbC4gSXQgaXMgcG9zc2libGVcbiAqIHRvIGJ1bmRsZSBjaGFuZ2VzIG9uIHRoZSBZanMgbW9kZWwgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb24gdG9cbiAqIG1pbmltaXplIHRoZSBudW1iZXIgb24gbWVzc2FnZXMgc2VudCBhbmQgdGhlIG51bWJlciBvZiBvYnNlcnZlciBjYWxscy5cbiAqIElmIHBvc3NpYmxlIHRoZSB1c2VyIG9mIHRoaXMgbGlicmFyeSBzaG91bGQgYnVuZGxlIGFzIG1hbnkgY2hhbmdlcyBhc1xuICogcG9zc2libGUuIEhlcmUgaXMgYW4gZXhhbXBsZSB0byBpbGx1c3RyYXRlIHRoZSBhZHZhbnRhZ2VzIG9mIGJ1bmRsaW5nOlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtYXAgPSB5LmRlZmluZSgnbWFwJywgWU1hcClcbiAqIC8vIExvZyBjb250ZW50IHdoZW4gY2hhbmdlIGlzIHRyaWdnZXJlZFxuICogbWFwLm9ic2VydmUoKCkgPT4ge1xuICogICBjb25zb2xlLmxvZygnY2hhbmdlIHRyaWdnZXJlZCcpXG4gKiB9KVxuICogLy8gRWFjaCBjaGFuZ2Ugb24gdGhlIG1hcCB0eXBlIHRyaWdnZXJzIGEgbG9nIG1lc3NhZ2U6XG4gKiBtYXAuc2V0KCdhJywgMCkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqIG1hcC5zZXQoJ2InLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICogLy8gV2hlbiBwdXQgaW4gYSB0cmFuc2FjdGlvbiwgaXQgd2lsbCB0cmlnZ2VyIHRoZSBsb2cgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uOlxuICogeS50cmFuc2FjdCgoKSA9PiB7XG4gKiAgIG1hcC5zZXQoJ2EnLCAxKVxuICogICBtYXAuc2V0KCdiJywgMSlcbiAqIH0pIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICogQHBhcmFtIHtib29sZWFufSBsb2NhbFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYywgb3JpZ2luLCBsb2NhbCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBZanMgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0RvY31cbiAgICAgKi9cbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgdGhlIHNldCBvZiBkZWxldGVkIGl0ZW1zIGJ5IGlkc1xuICAgICAqIEB0eXBlIHtEZWxldGVTZXR9XG4gICAgICovXG4gICAgdGhpcy5kZWxldGVTZXQgPSBuZXcgRGVsZXRlU2V0KCk7XG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIHN0YXRlIGJlZm9yZSB0aGUgdHJhbnNhY3Rpb24gc3RhcnRlZC5cbiAgICAgKiBAdHlwZSB7TWFwPE51bWJlcixOdW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYmVmb3JlU3RhdGUgPSBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpO1xuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBzdGF0ZSBhZnRlciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHR5cGUge01hcDxOdW1iZXIsTnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmFmdGVyU3RhdGUgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQWxsIHR5cGVzIHRoYXQgd2VyZSBkaXJlY3RseSBtb2RpZmllZCAocHJvcGVydHkgYWRkZWQgb3IgY2hpbGRcbiAgICAgKiBpbnNlcnRlZC9kZWxldGVkKS4gTmV3IHR5cGVzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhpcyBTZXQuXG4gICAgICogTWFwcyBmcm9tIHR5cGUgdG8gcGFyZW50U3VicyAoYGl0ZW0ucGFyZW50U3ViID0gbnVsbGAgZm9yIFlBcnJheSlcbiAgICAgKiBAdHlwZSB7TWFwPEFic3RyYWN0VHlwZTxZRXZlbnQ+LFNldDxTdHJpbmd8bnVsbD4+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlZCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGV2ZW50cyBmb3IgdGhlIHR5cGVzIHRoYXQgb2JzZXJ2ZSBhbHNvIGNoaWxkIGVsZW1lbnRzLlxuICAgICAqIEl0IGlzIG1haW5seSB1c2VkIGJ5IGBvYnNlcnZlRGVlcGAuXG4gICAgICogQHR5cGUge01hcDxBYnN0cmFjdFR5cGU8WUV2ZW50PixBcnJheTxZRXZlbnQ+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZWRQYXJlbnRUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QWJzdHJhY3RTdHJ1Y3Q+fVxuICAgICAqL1xuICAgIHRoaXMuX21lcmdlU3RydWN0cyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gICAgLyoqXG4gICAgICogU3RvcmVzIG1ldGEgaW5mb3JtYXRpb24gb24gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHR5cGUge01hcDxhbnksYW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGNoYW5nZSBvcmlnaW5hdGVzIGZyb20gdGhpcyBkb2MuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NBZGRlZCA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzUmVtb3ZlZCA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzTG9hZGVkID0gbmV3IFNldCgpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZUVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGRhdGEgd2FzIHdyaXR0ZW4uXG4gKi9cbmNvbnN0IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbiA9IChlbmNvZGVyLCB0cmFuc2FjdGlvbikgPT4ge1xuICBpZiAodHJhbnNhY3Rpb24uZGVsZXRlU2V0LmNsaWVudHMuc2l6ZSA9PT0gMCAmJiAhYW55KHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUsIChjbG9jaywgY2xpZW50KSA9PiB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSAhPT0gY2xvY2spKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCk7XG4gIHdyaXRlU3RydWN0c0Zyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbik7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIElmIGB0eXBlLnBhcmVudGAgd2FzIGFkZGVkIGluIGN1cnJlbnQgdHJhbnNhY3Rpb24sIGB0eXBlYCB0ZWNobmljYWxseVxuICogZGlkIG5vdCBjaGFuZ2UsIGl0IHdhcyBqdXN0IGFkZGVkIGFuZCB3ZSBzaG91bGQgbm90IGZpcmUgZXZlbnRzIGZvciBgdHlwZWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPFlFdmVudD59IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHBhcmVudFN1YlxuICovXG5jb25zdCBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24sIHR5cGUsIHBhcmVudFN1YikgPT4ge1xuICBjb25zdCBpdGVtID0gdHlwZS5faXRlbTtcbiAgaWYgKGl0ZW0gPT09IG51bGwgfHwgKGl0ZW0uaWQuY2xvY2sgPCAodHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGl0ZW0uaWQuY2xpZW50KSB8fCAwKSAmJiAhaXRlbS5kZWxldGVkKSkge1xuICAgIHNldElmVW5kZWZpbmVkKHRyYW5zYWN0aW9uLmNoYW5nZWQsIHR5cGUsIGNyZWF0ZSkuYWRkKHBhcmVudFN1Yik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxBYnN0cmFjdFN0cnVjdD59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAqL1xuY29uc3QgdHJ5VG9NZXJnZVdpdGhMZWZ0ID0gKHN0cnVjdHMsIHBvcykgPT4ge1xuICBjb25zdCBsZWZ0ID0gc3RydWN0c1twb3MgLSAxXTtcbiAgY29uc3QgcmlnaHQgPSBzdHJ1Y3RzW3Bvc107XG4gIGlmIChsZWZ0LmRlbGV0ZWQgPT09IHJpZ2h0LmRlbGV0ZWQgJiYgbGVmdC5jb25zdHJ1Y3RvciA9PT0gcmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICBpZiAobGVmdC5tZXJnZVdpdGgocmlnaHQpKSB7XG4gICAgICBzdHJ1Y3RzLnNwbGljZShwb3MsIDEpO1xuICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgSXRlbSAmJiByaWdodC5wYXJlbnRTdWIgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0LnBhcmVudCkuX21hcC5nZXQocmlnaHQucGFyZW50U3ViKSA9PT0gcmlnaHQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0LnBhcmVudCkuX21hcC5zZXQocmlnaHQucGFyZW50U3ViLCAvKiogQHR5cGUge0l0ZW19ICovIChsZWZ0KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSXRlbSk6Ym9vbGVhbn0gZ2NGaWx0ZXJcbiAqL1xuY29uc3QgdHJ5R2NEZWxldGVTZXQgPSAoZHMsIHN0b3JlLCBnY0ZpbHRlcikgPT4ge1xuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRlbGV0ZUl0ZW1zXSBvZiBkcy5jbGllbnRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSk7XG4gICAgZm9yIChsZXQgZGkgPSBkZWxldGVJdGVtcy5sZW5ndGggLSAxOyBkaSA+PSAwOyBkaS0tKSB7XG4gICAgICBjb25zdCBkZWxldGVJdGVtID0gZGVsZXRlSXRlbXNbZGldO1xuICAgICAgY29uc3QgZW5kRGVsZXRlSXRlbUNsb2NrID0gZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuO1xuICAgICAgZm9yIChcbiAgICAgICAgbGV0IHNpID0gZmluZEluZGV4U1Moc3RydWN0cywgZGVsZXRlSXRlbS5jbG9jayksIHN0cnVjdCA9IHN0cnVjdHNbc2ldO1xuICAgICAgICBzaSA8IHN0cnVjdHMubGVuZ3RoICYmIHN0cnVjdC5pZC5jbG9jayA8IGVuZERlbGV0ZUl0ZW1DbG9jaztcbiAgICAgICAgc3RydWN0ID0gc3RydWN0c1srK3NpXVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbc2ldO1xuICAgICAgICBpZiAoZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuIDw9IHN0cnVjdC5pZC5jbG9jaykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cnVjdCBpbnN0YW5jZW9mIEl0ZW0gJiYgc3RydWN0LmRlbGV0ZWQgJiYgIXN0cnVjdC5rZWVwICYmIGdjRmlsdGVyKHN0cnVjdCkpIHtcbiAgICAgICAgICBzdHJ1Y3QuZ2Moc3RvcmUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKi9cbmNvbnN0IHRyeU1lcmdlRGVsZXRlU2V0ID0gKGRzLCBzdG9yZSkgPT4ge1xuICAvLyB0cnkgdG8gbWVyZ2UgZGVsZXRlZCAvIGdjJ2QgaXRlbXNcbiAgLy8gbWVyZ2UgZnJvbSByaWdodCB0byBsZWZ0IGZvciBiZXR0ZXIgZWZmaWNpZWN5IGFuZCBzbyB3ZSBkb24ndCBtaXNzIGFueSBtZXJnZSB0YXJnZXRzXG4gIGRzLmNsaWVudHMuZm9yRWFjaCgoZGVsZXRlSXRlbXMsIGNsaWVudCkgPT4ge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSk7XG4gICAgZm9yIChsZXQgZGkgPSBkZWxldGVJdGVtcy5sZW5ndGggLSAxOyBkaSA+PSAwOyBkaS0tKSB7XG4gICAgICBjb25zdCBkZWxldGVJdGVtID0gZGVsZXRlSXRlbXNbZGldO1xuICAgICAgLy8gc3RhcnQgd2l0aCBtZXJnaW5nIHRoZSBpdGVtIG5leHQgdG8gdGhlIGxhc3QgZGVsZXRlZCBpdGVtXG4gICAgICBjb25zdCBtb3N0UmlnaHRJbmRleFRvQ2hlY2sgPSBtaW4oc3RydWN0cy5sZW5ndGggLSAxLCAxICsgZmluZEluZGV4U1Moc3RydWN0cywgZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuIC0gMSkpO1xuICAgICAgZm9yIChcbiAgICAgICAgbGV0IHNpID0gbW9zdFJpZ2h0SW5kZXhUb0NoZWNrLCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgc2kgPiAwICYmIHN0cnVjdC5pZC5jbG9jayA+PSBkZWxldGVJdGVtLmNsb2NrO1xuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzWy0tc2ldXG4gICAgICApIHtcbiAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0KHN0cnVjdHMsIHNpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IGdjRmlsdGVyXG4gKi9cbmNvbnN0IHRyeUdjID0gKGRzLCBzdG9yZSwgZ2NGaWx0ZXIpID0+IHtcbiAgdHJ5R2NEZWxldGVTZXQoZHMsIHN0b3JlLCBnY0ZpbHRlcik7XG4gIHRyeU1lcmdlRGVsZXRlU2V0KGRzLCBzdG9yZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb24+fSB0cmFuc2FjdGlvbkNsZWFudXBzXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICovXG5jb25zdCBjbGVhbnVwVHJhbnNhY3Rpb25zID0gKHRyYW5zYWN0aW9uQ2xlYW51cHMsIGkpID0+IHtcbiAgaWYgKGkgPCB0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25DbGVhbnVwc1tpXTtcbiAgICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gICAgY29uc3QgZHMgPSB0cmFuc2FjdGlvbi5kZWxldGVTZXQ7XG4gICAgY29uc3QgbWVyZ2VTdHJ1Y3RzID0gdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cztcbiAgICB0cnkge1xuICAgICAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KGRzKTtcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUgPSBnZXRTdGF0ZVZlY3Rvcih0cmFuc2FjdGlvbi5kb2Muc3RvcmUpO1xuICAgICAgZG9jLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICBkb2MuZW1pdCgnYmVmb3JlT2JzZXJ2ZXJDYWxscycsIFt0cmFuc2FjdGlvbiwgZG9jXSk7XG4gICAgICAvKipcbiAgICAgICAqIEFuIGFycmF5IG9mIGV2ZW50IGNhbGxiYWNrcy5cbiAgICAgICAqXG4gICAgICAgKiBFYWNoIGNhbGxiYWNrIGlzIGNhbGxlZCBldmVuIGlmIHRoZSBvdGhlciBvbmVzIHRocm93IGVycm9ycy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oKTp2b2lkPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZnMgPSBbXTtcbiAgICAgIC8vIG9ic2VydmUgZXZlbnRzIG9uIGNoYW5nZWQgdHlwZXNcbiAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZm9yRWFjaCgoc3VicywgaXRlbXR5cGUpID0+XG4gICAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtdHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhaXRlbXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgaXRlbXR5cGUuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgc3Vicyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAvLyBkZWVwIG9ic2VydmUgZXZlbnRzXG4gICAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5mb3JFYWNoKChldmVudHMsIHR5cGUpID0+XG4gICAgICAgICAgZnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRoaW5rIGFib3V0IHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZSB1c2VyIHRyYW5zZm9ybXMgdGhlXG4gICAgICAgICAgICAvLyBZLkRvYyBpbiB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZXZlbnQgPT5cbiAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5faXRlbSA9PT0gbnVsbCB8fCAhZXZlbnQudGFyZ2V0Ll9pdGVtLmRlbGV0ZWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBldmVudHNcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gdHlwZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gc29ydCBldmVudHMgYnkgcGF0aCBsZW5ndGggc28gdGhhdCB0b3AtbGV2ZWwgZXZlbnRzIGFyZSBmaXJlZCBmaXJzdC5cbiAgICAgICAgICAgICAgZXZlbnRzXG4gICAgICAgICAgICAgICAgLnNvcnQoKGV2ZW50MSwgZXZlbnQyKSA9PiBldmVudDEucGF0aC5sZW5ndGggLSBldmVudDIucGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciBldmVudHMubGVuZ3RoXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2Uga25vdyBpdCBoYXMgYXQgbGVhc3Qgb25lIGVsZW1lbnRcbiAgICAgICAgICAgICAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyh0eXBlLl9kRUgsIGV2ZW50cywgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZzLnB1c2goKCkgPT4gZG9jLmVtaXQoJ2FmdGVyVHJhbnNhY3Rpb24nLCBbdHJhbnNhY3Rpb24sIGRvY10pKTtcbiAgICAgIH0pO1xuICAgICAgY2FsbEFsbChmcywgW10pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZXBsYWNlIGRlbGV0ZWQgaXRlbXMgd2l0aCBJdGVtRGVsZXRlZCAvIEdDLlxuICAgICAgLy8gVGhpcyBpcyB3aGVyZSBjb250ZW50IGlzIGFjdHVhbGx5IHJlbW92ZSBmcm9tIHRoZSBZanMgRG9jLlxuICAgICAgaWYgKGRvYy5nYykge1xuICAgICAgICB0cnlHY0RlbGV0ZVNldChkcywgc3RvcmUsIGRvYy5nY0ZpbHRlcik7XG4gICAgICB9XG4gICAgICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpO1xuXG4gICAgICAvLyBvbiBhbGwgYWZmZWN0ZWQgc3RvcmUuY2xpZW50cyBwcm9wcywgdHJ5IHRvIG1lcmdlXG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICAgICAgY29uc3QgYmVmb3JlQ2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBpZiAoYmVmb3JlQ2xvY2sgIT09IGNsb2NrKSB7XG4gICAgICAgICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKTtcbiAgICAgICAgICAvLyB3ZSBpdGVyYXRlIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBjYW4gc2FmZWx5IHJlbW92ZSBlbnRyaWVzXG4gICAgICAgICAgY29uc3QgZmlyc3RDaGFuZ2VQb3MgPSBtYXgoZmluZEluZGV4U1Moc3RydWN0cywgYmVmb3JlQ2xvY2spLCAxKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RydWN0cy5sZW5ndGggLSAxOyBpID49IGZpcnN0Q2hhbmdlUG9zOyBpLS0pIHtcbiAgICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdChzdHJ1Y3RzLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gdHJ5IHRvIG1lcmdlIG1lcmdlU3RydWN0c1xuICAgICAgLy8gQHRvZG86IGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gdHJhbnNmb3JtIG1lcmdlU3RydWN0cyB0byBhIERTLCBzb3J0IGl0LCBhbmQgbWVyZ2UgZnJvbSByaWdodCB0byBsZWZ0XG4gICAgICAvLyAgICAgICAgYnV0IGF0IHRoZSBtb21lbnQgRFMgZG9lcyBub3QgaGFuZGxlIGR1cGxpY2F0ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVyZ2VTdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbWVyZ2VTdHJ1Y3RzW2ldLmlkO1xuICAgICAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgICAgICBjb25zdCByZXBsYWNlZFN0cnVjdFBvcyA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKTtcbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zICsgMSA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0KHN0cnVjdHMsIHJlcGxhY2VkU3RydWN0UG9zICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zID4gMCkge1xuICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdChzdHJ1Y3RzLCByZXBsYWNlZFN0cnVjdFBvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5nZXQoZG9jLmNsaWVudElEKSAhPT0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGRvYy5jbGllbnRJRCkpIHtcbiAgICAgICAgZG9jLmNsaWVudElEID0gZ2VuZXJhdGVOZXdDbGllbnRJZCgpO1xuICAgICAgICBwcmludChPUkFOR0UsIEJPTEQsICdbeWpzXSAnLCBVTkJPTEQsIFJFRCwgJ0NoYW5nZWQgdGhlIGNsaWVudC1pZCBiZWNhdXNlIGFub3RoZXIgY2xpZW50IHNlZW1zIHRvIGJlIHVzaW5nIGl0LicpO1xuICAgICAgfVxuICAgICAgLy8gQHRvZG8gTWVyZ2UgYWxsIHRoZSB0cmFuc2FjdGlvbnMgaW50byBvbmUgYW5kIHByb3ZpZGUgc2VuZCB0aGUgZGF0YSBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZVxuICAgICAgZG9jLmVtaXQoJ2FmdGVyVHJhbnNhY3Rpb25DbGVhbnVwJywgW3RyYW5zYWN0aW9uLCBkb2NdKTtcbiAgICAgIGlmIChkb2MuX29ic2VydmVycy5oYXMoJ3VwZGF0ZScpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRGVmYXVsdFVwZGF0ZUVuY29kZXIoKTtcbiAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmIChoYXNDb250ZW50KSB7XG4gICAgICAgICAgZG9jLmVtaXQoJ3VwZGF0ZScsIFtlbmNvZGVyLnRvVWludDhBcnJheSgpLCB0cmFuc2FjdGlvbi5vcmlnaW4sIGRvYywgdHJhbnNhY3Rpb25dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRvYy5fb2JzZXJ2ZXJzLmhhcygndXBkYXRlVjInKSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpO1xuICAgICAgICBjb25zdCBoYXNDb250ZW50ID0gd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uKGVuY29kZXIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICBkb2MuZW1pdCgndXBkYXRlVjInLCBbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgdHJhbnNhY3Rpb24ub3JpZ2luLCBkb2MsIHRyYW5zYWN0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5mb3JFYWNoKHN1YmRvYyA9PiBkb2Muc3ViZG9jcy5hZGQoc3ViZG9jKSk7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzUmVtb3ZlZC5mb3JFYWNoKHN1YmRvYyA9PiBkb2Muc3ViZG9jcy5kZWxldGUoc3ViZG9jKSk7XG5cbiAgICAgIGRvYy5lbWl0KCdzdWJkb2NzJywgW3sgbG9hZGVkOiB0cmFuc2FjdGlvbi5zdWJkb2NzTG9hZGVkLCBhZGRlZDogdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLCByZW1vdmVkOiB0cmFuc2FjdGlvbi5zdWJkb2NzUmVtb3ZlZCB9XSk7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzUmVtb3ZlZC5mb3JFYWNoKHN1YmRvYyA9PiBzdWJkb2MuZGVzdHJveSgpKTtcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoIDw9IGkgKyAxKSB7XG4gICAgICAgIGRvYy5fdHJhbnNhY3Rpb25DbGVhbnVwcyA9IFtdO1xuICAgICAgICBkb2MuZW1pdCgnYWZ0ZXJBbGxUcmFuc2FjdGlvbnMnLCBbZG9jLCB0cmFuc2FjdGlvbkNsZWFudXBzXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhbnVwVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uQ2xlYW51cHMsIGkgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBgeS50cmFuc2FjdCgoKT0+ey4ufSlgXG4gKlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbik6dm9pZH0gZlxuICogQHBhcmFtIHthbnl9IFtvcmlnaW49dHJ1ZV1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHJhbnNhY3QgPSAoZG9jLCBmLCBvcmlnaW4gPSBudWxsLCBsb2NhbCA9IHRydWUpID0+IHtcbiAgY29uc3QgdHJhbnNhY3Rpb25DbGVhbnVwcyA9IGRvYy5fdHJhbnNhY3Rpb25DbGVhbnVwcztcbiAgbGV0IGluaXRpYWxDYWxsID0gZmFsc2U7XG4gIGlmIChkb2MuX3RyYW5zYWN0aW9uID09PSBudWxsKSB7XG4gICAgaW5pdGlhbENhbGwgPSB0cnVlO1xuICAgIGRvYy5fdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oZG9jLCBvcmlnaW4sIGxvY2FsKTtcbiAgICB0cmFuc2FjdGlvbkNsZWFudXBzLnB1c2goZG9jLl90cmFuc2FjdGlvbik7XG4gICAgaWYgKHRyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBkb2MuZW1pdCgnYmVmb3JlQWxsVHJhbnNhY3Rpb25zJywgW2RvY10pO1xuICAgIH1cbiAgICBkb2MuZW1pdCgnYmVmb3JlVHJhbnNhY3Rpb24nLCBbZG9jLl90cmFuc2FjdGlvbiwgZG9jXSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBmKGRvYy5fdHJhbnNhY3Rpb24pO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChpbml0aWFsQ2FsbCAmJiB0cmFuc2FjdGlvbkNsZWFudXBzWzBdID09PSBkb2MuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAvLyBUaGUgZmlyc3QgdHJhbnNhY3Rpb24gZW5kZWQsIG5vdyBwcm9jZXNzIG9ic2VydmVyIGNhbGxzLlxuICAgICAgLy8gT2JzZXJ2ZXIgY2FsbCBtYXkgY3JlYXRlIG5ldyB0cmFuc2FjdGlvbnMgZm9yIHdoaWNoIHdlIG5lZWQgdG8gY2FsbCB0aGUgb2JzZXJ2ZXJzIGFuZCBkbyBjbGVhbnVwLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBuZXN0IHRoZXNlIGNhbGxzLCBzbyB3ZSBleGVjdXRlIHRoZXNlIGNhbGxzIG9uZSBhZnRlclxuICAgICAgLy8gYW5vdGhlci5cbiAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBlbnN1cmUgdGhhdCBhbGwgY2xlYW51cHMgYXJlIGNhbGxlZCwgZXZlbiBpZiB0aGVcbiAgICAgIC8vIG9ic2VydmVzIHRocm93IGVycm9ycy5cbiAgICAgIC8vIFRoaXMgZmlsZSBpcyBmdWxsIG9mIGhhY2t5IHRyeSB7fSBmaW5hbGx5IHt9IGJsb2NrcyB0byBlbnN1cmUgdGhhdCBhblxuICAgICAgLy8gZXZlbnQgY2FuIHRocm93IGVycm9ycyBhbmQgYWxzbyB0aGF0IHRoZSBjbGVhbnVwIGlzIGNhbGxlZC5cbiAgICAgIGNsZWFudXBUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25DbGVhbnVwcywgMCk7XG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBTdGFja0l0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gICAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBiZWZvcmVTdGF0ZVxuICAgKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gYWZ0ZXJTdGF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRzLCBiZWZvcmVTdGF0ZSwgYWZ0ZXJTdGF0ZSkge1xuICAgIHRoaXMuZHMgPSBkcztcbiAgICB0aGlzLmJlZm9yZVN0YXRlID0gYmVmb3JlU3RhdGU7XG4gICAgdGhpcy5hZnRlclN0YXRlID0gYWZ0ZXJTdGF0ZTtcbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyB0byBzYXZlIGFuZCByZXN0b3JlIG1ldGFkYXRhIGxpa2Ugc2VsZWN0aW9uIHJhbmdlXG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVbmRvTWFuYWdlcn0gdW5kb01hbmFnZXJcbiAqIEBwYXJhbSB7QXJyYXk8U3RhY2tJdGVtPn0gc3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge1N0YWNrSXRlbT99XG4gKi9cbmNvbnN0IHBvcFN0YWNrSXRlbSA9ICh1bmRvTWFuYWdlciwgc3RhY2ssIGV2ZW50VHlwZSkgPT4ge1xuICAvKipcbiAgICogV2hldGhlciBhIGNoYW5nZSBoYXBwZW5lZFxuICAgKiBAdHlwZSB7U3RhY2tJdGVtP31cbiAgICovXG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBjb25zdCBkb2MgPSB1bmRvTWFuYWdlci5kb2M7XG4gIGNvbnN0IHNjb3BlID0gdW5kb01hbmFnZXIuc2NvcGU7XG4gIHRyYW5zYWN0KGRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwICYmIHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gICAgICBjb25zdCBzdGFja0l0ZW0gPSAvKiogQHR5cGUge1N0YWNrSXRlbX0gKi8gKHN0YWNrLnBvcCgpKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1NldDxJdGVtPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgaXRlbXNUb1JlZG8gPSBuZXcgU2V0KCk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTxJdGVtPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgaXRlbXNUb0RlbGV0ZSA9IFtdO1xuICAgICAgbGV0IHBlcmZvcm1lZENoYW5nZSA9IGZhbHNlO1xuICAgICAgc3RhY2tJdGVtLmFmdGVyU3RhdGUuZm9yRWFjaCgoZW5kQ2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENsb2NrID0gc3RhY2tJdGVtLmJlZm9yZVN0YXRlLmdldChjbGllbnQpIHx8IDA7XG4gICAgICAgIGNvbnN0IGxlbiA9IGVuZENsb2NrIC0gc3RhcnRDbG9jaztcbiAgICAgICAgLy8gQHRvZG8gaXRlcmF0ZVN0cnVjdHMgc2hvdWxkIG5vdCBuZWVkIHRoZSBzdHJ1Y3RzIHBhcmFtZXRlclxuICAgICAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgICAgICBpZiAoc3RhcnRDbG9jayAhPT0gZW5kQ2xvY2spIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgc3RydWN0cyBkb24ndCBvdmVybGFwIHdpdGggdGhlIHJhbmdlIG9mIGNyZWF0ZWQgb3BlcmF0aW9ucyBbc3RhY2tJdGVtLnN0YXJ0LCBzdGFja0l0ZW0uc3RhcnQgKyBzdGFja0l0ZW0uZW5kKVxuICAgICAgICAgIC8vIHRoaXMgbXVzdCBiZSBleGVjdXRlZCBiZWZvcmUgZGVsZXRlZCBzdHJ1Y3RzIGFyZSBpdGVyYXRlZC5cbiAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY2xpZW50LCBzdGFydENsb2NrKSk7XG4gICAgICAgICAgaWYgKGVuZENsb2NrIDwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY2xpZW50LCBlbmRDbG9jaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RydWN0cywgc3RhcnRDbG9jaywgbGVuLCBzdHJ1Y3QgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cnVjdCBpbnN0YW5jZW9mIEl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKHN0cnVjdC5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBpdGVtLCBkaWZmIH0gPSBmb2xsb3dSZWRvbmUoc3RvcmUsIHN0cnVjdC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBpdGVtID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGl0ZW0uaWQuY2xpZW50LCBpdGVtLmlkLmNsb2NrICsgZGlmZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5sZW5ndGggPiBsZW4pIHtcbiAgICAgICAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChpdGVtLmlkLmNsaWVudCwgZW5kQ2xvY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RydWN0ID0gaXRlbTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkICYmIHNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIC8qKiBAdHlwZSB7SXRlbX0gKi8gKHN0cnVjdCkpKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zVG9EZWxldGUucHVzaChzdHJ1Y3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdGFja0l0ZW0uZHMsIHN0cnVjdCA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gc3RydWN0LmlkO1xuICAgICAgICBjb25zdCBjbG9jayA9IGlkLmNsb2NrO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBpZC5jbGllbnQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2xvY2sgPSBzdGFja0l0ZW0uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMDtcbiAgICAgICAgY29uc3QgZW5kQ2xvY2sgPSBzdGFja0l0ZW0uYWZ0ZXJTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RydWN0IGluc3RhbmNlb2YgSXRlbSAmJlxuICAgICAgICAgIHNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIHN0cnVjdCkpICYmXG4gICAgICAgICAgLy8gTmV2ZXIgcmVkbyBzdHJ1Y3RzIGluIFtzdGFja0l0ZW0uc3RhcnQsIHN0YWNrSXRlbS5zdGFydCArIHN0YWNrSXRlbS5lbmQpIGJlY2F1c2UgdGhleSB3ZXJlIGNyZWF0ZWQgYW5kIGRlbGV0ZWQgaW4gdGhlIHNhbWUgY2FwdHVyZSBpbnRlcnZhbC5cbiAgICAgICAgICAhKGNsb2NrID49IHN0YXJ0Q2xvY2sgJiYgY2xvY2sgPCBlbmRDbG9jaylcbiAgICAgICAgKSB7XG4gICAgICAgICAgaXRlbXNUb1JlZG8uYWRkKHN0cnVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlbXNUb1JlZG8uZm9yRWFjaChzdHJ1Y3QgPT4ge1xuICAgICAgICBwZXJmb3JtZWRDaGFuZ2UgPSByZWRvSXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpdGVtc1RvUmVkbykgIT09IG51bGwgfHwgcGVyZm9ybWVkQ2hhbmdlO1xuICAgICAgfSk7XG4gICAgICAvLyBXZSB3YW50IHRvIGRlbGV0ZSBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgY2hpbGRyZW4gYXJlIGRlbGV0ZWQgYmVmb3JlXG4gICAgICAvLyBwYXJlbnRzLCBzbyB3ZSBoYXZlIG1vcmUgaW5mb3JtYXRpb24gYXZhaWxhYmxlIHdoZW4gaXRlbXMgYXJlIGZpbHRlcmVkLlxuICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zVG9EZWxldGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zVG9EZWxldGVbaV07XG4gICAgICAgIGlmICh1bmRvTWFuYWdlci5kZWxldGVGaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgcGVyZm9ybWVkQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ID0gc3RhY2tJdGVtO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goKHN1YlByb3BzLCB0eXBlKSA9PiB7XG4gICAgICAvLyBkZXN0cm95IHNlYXJjaCBtYXJrZXIgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoc3ViUHJvcHMuaGFzKG51bGwpICYmIHR5cGUuX3NlYXJjaE1hcmtlcikge1xuICAgICAgICB0eXBlLl9zZWFyY2hNYXJrZXIubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgdW5kb01hbmFnZXIpO1xuICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICB1bmRvTWFuYWdlci5lbWl0KCdzdGFjay1pdGVtLXBvcHBlZCcsIFt7IHN0YWNrSXRlbTogcmVzdWx0LCB0eXBlOiBldmVudFR5cGUgfSwgdW5kb01hbmFnZXJdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVuZG9NYW5hZ2VyT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtVbmRvTWFuYWdlck9wdGlvbnMuY2FwdHVyZVRpbWVvdXQ9NTAwXVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbVW5kb01hbmFnZXJPcHRpb25zLmRlbGV0ZUZpbHRlcj0oKT0+dHJ1ZV0gU29tZXRpbWVzXG4gKiBpdCBpcyBuZWNlc3NhcnkgdG8gZmlsdGVyIHdoYW4gYW4gVW5kby9SZWRvIG9wZXJhdGlvbiBjYW4gZGVsZXRlLiBJZiB0aGlzXG4gKiBmaWx0ZXIgcmV0dXJucyBmYWxzZSwgdGhlIHR5cGUvaXRlbSB3b24ndCBiZSBkZWxldGVkIGV2ZW4gaXQgaXMgaW4gdGhlXG4gKiB1bmRvL3JlZG8gc2NvcGUuXG4gKiBAcHJvcGVydHkge1NldDxhbnk+fSBbVW5kb01hbmFnZXJPcHRpb25zLnRyYWNrZWRPcmlnaW5zPW5ldyBTZXQoW251bGxdKV1cbiAqL1xuXG4vKipcbiAqIEZpcmVzICdzdGFjay1pdGVtLWFkZGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgYWRkZWQgdG8gZWl0aGVyIHRoZSB1bmRvLSBvclxuICogdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgc3RvcmUgYWRkaXRpb25hbCBzdGFjayBpbmZvcm1hdGlvbiB2aWEgdGhlXG4gKiBtZXRhZGF0YSBwcm9wZXJ0eSBvbiBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgIChpdCBpcyBhIGBNYXBgIG9mIG1ldGFkYXRhIHByb3BlcnRpZXMpLlxuICogRmlyZXMgJ3N0YWNrLWl0ZW0tcG9wcGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgcG9wcGVkIGZyb20gZWl0aGVyIHRoZVxuICogdW5kby0gb3IgdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgcmVzdG9yZSB0aGUgc2F2ZWQgc3RhY2sgaW5mb3JtYXRpb24gZnJvbSBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPCdzdGFjay1pdGVtLWFkZGVkJ3wnc3RhY2staXRlbS1wb3BwZWQnPn1cbiAqL1xuY2xhc3MgVW5kb01hbmFnZXIgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT58QXJyYXk8QWJzdHJhY3RUeXBlPGFueT4+fSB0eXBlU2NvcGUgQWNjZXB0cyBlaXRoZXIgYSBzaW5nbGUgdHlwZSwgb3IgYW4gYXJyYXkgb2YgdHlwZXNcbiAgICogQHBhcmFtIHtVbmRvTWFuYWdlck9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlU2NvcGUsIHsgY2FwdHVyZVRpbWVvdXQgPSA1MDAsIGRlbGV0ZUZpbHRlciA9ICgpID0+IHRydWUsIHRyYWNrZWRPcmlnaW5zID0gbmV3IFNldChbbnVsbF0pIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zY29wZSA9IHR5cGVTY29wZSBpbnN0YW5jZW9mIEFycmF5ID8gdHlwZVNjb3BlIDogW3R5cGVTY29wZV07XG4gICAgdGhpcy5kZWxldGVGaWx0ZXIgPSBkZWxldGVGaWx0ZXI7XG4gICAgdHJhY2tlZE9yaWdpbnMuYWRkKHRoaXMpO1xuICAgIHRoaXMudHJhY2tlZE9yaWdpbnMgPSB0cmFja2VkT3JpZ2lucztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3RhY2tJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuZG9TdGFjayA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdGFja0l0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMucmVkb1N0YWNrID0gW107XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSB1bmRvaW5nIChjYWxsaW5nIFVuZG9NYW5hZ2VyLnVuZG8pXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVuZG9pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJlZG9pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRvYyA9IC8qKiBAdHlwZSB7RG9jfSAqLyAodGhpcy5zY29wZVswXS5kb2MpO1xuICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gICAgdGhpcy5kb2Mub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCAvKiogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gKi8gdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgLy8gT25seSB0cmFjayBjZXJ0YWluIHRyYW5zYWN0aW9uc1xuICAgICAgaWYgKCF0aGlzLnNjb3BlLnNvbWUodHlwZSA9PiB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuaGFzKHR5cGUpKSB8fCAoIXRoaXMudHJhY2tlZE9yaWdpbnMuaGFzKHRyYW5zYWN0aW9uLm9yaWdpbikgJiYgKCF0cmFuc2FjdGlvbi5vcmlnaW4gfHwgIXRoaXMudHJhY2tlZE9yaWdpbnMuaGFzKHRyYW5zYWN0aW9uLm9yaWdpbi5jb25zdHJ1Y3RvcikpKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHVuZG9pbmcgPSB0aGlzLnVuZG9pbmc7XG4gICAgICBjb25zdCByZWRvaW5nID0gdGhpcy5yZWRvaW5nO1xuICAgICAgY29uc3Qgc3RhY2sgPSB1bmRvaW5nID8gdGhpcy5yZWRvU3RhY2sgOiB0aGlzLnVuZG9TdGFjaztcbiAgICAgIGlmICh1bmRvaW5nKSB7XG4gICAgICAgIHRoaXMuc3RvcENhcHR1cmluZygpOyAvLyBuZXh0IHVuZG8gc2hvdWxkIG5vdCBiZSBhcHBlbmRlZCB0byBsYXN0IHN0YWNrIGl0ZW1cbiAgICAgIH0gZWxzZSBpZiAoIXJlZG9pbmcpIHtcbiAgICAgICAgLy8gbmVpdGhlciB1bmRvaW5nIG5vciByZWRvaW5nOiBkZWxldGUgcmVkb1N0YWNrXG4gICAgICAgIHRoaXMucmVkb1N0YWNrID0gW107XG4gICAgICB9XG4gICAgICBjb25zdCBiZWZvcmVTdGF0ZSA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlO1xuICAgICAgY29uc3QgYWZ0ZXJTdGF0ZSA9IHRyYW5zYWN0aW9uLmFmdGVyU3RhdGU7XG4gICAgICBjb25zdCBub3cgPSBnZXRVbml4VGltZSgpO1xuICAgICAgaWYgKG5vdyAtIHRoaXMubGFzdENoYW5nZSA8IGNhcHR1cmVUaW1lb3V0ICYmIHN0YWNrLmxlbmd0aCA+IDAgJiYgIXVuZG9pbmcgJiYgIXJlZG9pbmcpIHtcbiAgICAgICAgLy8gYXBwZW5kIGNoYW5nZSB0byBsYXN0IHN0YWNrIG9wXG4gICAgICAgIGNvbnN0IGxhc3RPcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBsYXN0T3AuZHMgPSBtZXJnZURlbGV0ZVNldHMoW2xhc3RPcC5kcywgdHJhbnNhY3Rpb24uZGVsZXRlU2V0XSk7XG4gICAgICAgIGxhc3RPcC5hZnRlclN0YXRlID0gYWZ0ZXJTdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBzdGFjayBvcFxuICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0l0ZW0odHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBiZWZvcmVTdGF0ZSwgYWZ0ZXJTdGF0ZSkpO1xuICAgICAgfVxuICAgICAgaWYgKCF1bmRvaW5nICYmICFyZWRvaW5nKSB7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZSA9IG5vdztcbiAgICAgIH1cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGRlbGV0ZWQgc3RydWN0cyBhcmUgbm90IGdjJ2RcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZGVsZXRlU2V0LCAvKiogQHBhcmFtIHtJdGVtfEdDfSBpdGVtICovIGl0ZW0gPT4ge1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgdGhpcy5zY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCBpdGVtKSkpIHtcbiAgICAgICAgICBrZWVwSXRlbShpdGVtLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoJ3N0YWNrLWl0ZW0tYWRkZWQnLCBbeyBzdGFja0l0ZW06IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLCBvcmlnaW46IHRyYW5zYWN0aW9uLm9yaWdpbiwgdHlwZTogdW5kb2luZyA/ICdyZWRvJyA6ICd1bmRvJyB9LCB0aGlzXSk7XG4gICAgfSk7XG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5kb2MudHJhbnNhY3QodHJhbnNhY3Rpb24gPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1N0YWNrSXRlbX0gc3RhY2tJdGVtXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGNsZWFySXRlbSA9IHN0YWNrSXRlbSA9PiB7XG4gICAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmRzLCBpdGVtID0+IHtcbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgdGhpcy5zY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCBpdGVtKSkpIHtcbiAgICAgICAgICAgIGtlZXBJdGVtKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMudW5kb1N0YWNrLmZvckVhY2goY2xlYXJJdGVtKTtcbiAgICAgIHRoaXMucmVkb1N0YWNrLmZvckVhY2goY2xlYXJJdGVtKTtcbiAgICB9KTtcbiAgICB0aGlzLnVuZG9TdGFjayA9IFtdO1xuICAgIHRoaXMucmVkb1N0YWNrID0gW107XG4gIH1cblxuICAvKipcbiAgICogVW5kb01hbmFnZXIgbWVyZ2VzIFVuZG8tU3RhY2tJdGVtIGlmIHRoZXkgYXJlIGNyZWF0ZWQgd2l0aGluIHRpbWUtZ2FwXG4gICAqIHNtYWxsZXIgdGhhbiBgb3B0aW9ucy5jYXB0dXJlVGltZW91dGAuIENhbGwgYHVtLnN0b3BDYXB0dXJpbmcoKWAgc28gdGhhdCB0aGUgbmV4dFxuICAgKiBTdGFja0l0ZW0gd29uJ3QgYmUgbWVyZ2VkLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgLy8gd2l0aG91dCBzdG9wQ2FwdHVyaW5nXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2EnKVxuICAgKiAgICAgeXRleHQuaW5zZXJ0KDEsICdiJylcbiAgICogICAgIHVtLnVuZG8oKVxuICAgKiAgICAgeXRleHQudG9TdHJpbmcoKSAvLyA9PiAnJyAobm90ZSB0aGF0ICdhYicgd2FzIHJlbW92ZWQpXG4gICAqICAgICAvLyB3aXRoIHN0b3BDYXB0dXJpbmdcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYScpXG4gICAqICAgICB1bS5zdG9wQ2FwdHVyaW5nKClcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYicpXG4gICAqICAgICB1bS51bmRvKClcbiAgICogICAgIHl0ZXh0LnRvU3RyaW5nKCkgLy8gPT4gJ2EnIChub3RlIHRoYXQgb25seSAnYicgd2FzIHJlbW92ZWQpXG4gICAqXG4gICAqL1xuICBzdG9wQ2FwdHVyaW5nICgpIHtcbiAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuZG8gbGFzdCBjaGFuZ2VzIG9uIHR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0YWNrSXRlbT99IFJldHVybnMgU3RhY2tJdGVtIGlmIGEgY2hhbmdlIHdhcyBhcHBsaWVkXG4gICAqL1xuICB1bmRvICgpIHtcbiAgICB0aGlzLnVuZG9pbmcgPSB0cnVlO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IHBvcFN0YWNrSXRlbSh0aGlzLCB0aGlzLnVuZG9TdGFjaywgJ3VuZG8nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy51bmRvaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWRvIGxhc3QgdW5kbyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1N0YWNrSXRlbT99IFJldHVybnMgU3RhY2tJdGVtIGlmIGEgY2hhbmdlIHdhcyBhcHBsaWVkXG4gICAqL1xuICByZWRvICgpIHtcbiAgICB0aGlzLnJlZG9pbmcgPSB0cnVlO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IHBvcFN0YWNrSXRlbSh0aGlzLCB0aGlzLnJlZG9TdGFjaywgJ3JlZG8nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5yZWRvaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG4vKipcbiAqIFlFdmVudCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVHlwZS5cbiAqL1xuY2xhc3MgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHRhcmdldCBUaGUgY2hhbmdlZCB0eXBlLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhcmdldCwgdHJhbnNhY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvbiB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkIG9uLlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCB0YXJnZXQgb24gd2hpY2ggdGhlIG9ic2VydmUgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge1RyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fY2hhbmdlcyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHBhdGggZnJvbSBgeWAgdG8gdGhlIGNoYW5nZWQgdHlwZS5cbiAgICpcbiAgICogQHRvZG8gdjE0IHNob3VsZCBzdGFuZGFyZGl6ZSBvbiBwYXRoOiBBcnJheTx7cGFyZW50LCBpbmRleH0+IGJlY2F1c2UgdGhhdCBpcyBlYXNpZXIgdG8gd29yayB3aXRoLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnR5IGhvbGRzOlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGxldCB0eXBlID0geVxuICAgKiAgIGV2ZW50LnBhdGguZm9yRWFjaChkaXIgPT4ge1xuICAgKiAgICAgdHlwZSA9IHR5cGUuZ2V0KGRpcilcbiAgICogICB9KVxuICAgKiAgIHR5cGUgPT09IGV2ZW50LnRhcmdldCAvLyA9PiB0cnVlXG4gICAqL1xuICBnZXQgcGF0aCAoKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBfaXRlbSBpcyBkZWZpbmVkIGJlY2F1c2UgdGFyZ2V0IGlzIGludGVncmF0ZWRcbiAgICByZXR1cm4gZ2V0UGF0aFRvKHRoaXMuY3VycmVudFRhcmdldCwgdGhpcy50YXJnZXQpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzdHJ1Y3QgaXMgZGVsZXRlZCBieSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBJbiBjb250cmFzdCB0byBjaGFuZ2UuZGVsZXRlZCwgdGhpcyBtZXRob2QgYWxzbyByZXR1cm5zIHRydWUgaWYgdGhlIHN0cnVjdCB3YXMgYWRkZWQgYW5kIHRoZW4gZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0cnVjdH0gc3RydWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBkZWxldGVzIChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gaXNEZWxldGVkKHRoaXMudHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBzdHJ1Y3QuaWQpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzdHJ1Y3QgaXMgYWRkZWQgYnkgdGhpcyBldmVudC5cbiAgICpcbiAgICogSW4gY29udHJhc3QgdG8gY2hhbmdlLmRlbGV0ZWQsIHRoaXMgbWV0aG9kIGFsc28gcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJ1Y3Qgd2FzIGFkZGVkIGFuZCB0aGVuIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTdHJ1Y3R9IHN0cnVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYWRkcyAoc3RydWN0KSB7XG4gICAgcmV0dXJuIHN0cnVjdC5pZC5jbG9jayA+PSAodGhpcy50cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoc3RydWN0LmlkLmNsaWVudCkgfHwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt7YWRkZWQ6U2V0PEl0ZW0+LGRlbGV0ZWQ6U2V0PEl0ZW0+LGtleXM6TWFwPHN0cmluZyx7YWN0aW9uOidhZGQnfCd1cGRhdGUnfCdkZWxldGUnLG9sZFZhbHVlOmFueX0+LGRlbHRhOkFycmF5PHtpbnNlcnQ6QXJyYXk8YW55Pn18e2RlbGV0ZTpudW1iZXJ9fHtyZXRhaW46bnVtYmVyfT59fVxuICAgKi9cbiAgZ2V0IGNoYW5nZXMgKCkge1xuICAgIGxldCBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlcztcbiAgICBpZiAoY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICBjb25zdCBhZGRlZCA9IGNyZWF0ZSgpO1xuICAgICAgY29uc3QgZGVsZXRlZCA9IGNyZWF0ZSgpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydDpBcnJheTxhbnk+fXx7ZGVsZXRlOm51bWJlcn18e3JldGFpbjpudW1iZXJ9Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge01hcDxzdHJpbmcseyBhY3Rpb246ICdhZGQnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJywgb2xkVmFsdWU6IGFueX0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBrZXlzID0gbmV3IE1hcCgpO1xuICAgICAgY2hhbmdlcyA9IHtcbiAgICAgICAgYWRkZWQsIGRlbGV0ZWQsIGRlbHRhLCBrZXlzXG4gICAgICB9O1xuICAgICAgY29uc3QgY2hhbmdlZCA9IC8qKiBAdHlwZSBTZXQ8c3RyaW5nfG51bGw+ICovICh0aGlzLnRyYW5zYWN0aW9uLmNoYW5nZWQuZ2V0KHRhcmdldCkpO1xuICAgICAgaWYgKGNoYW5nZWQuaGFzKG51bGwpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGxhc3RPcCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhY2tPcCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAobGFzdE9wKSB7XG4gICAgICAgICAgICBkZWx0YS5wdXNoKGxhc3RPcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpdGVtID0gdGFyZ2V0Ll9zdGFydDsgaXRlbSAhPT0gbnVsbDsgaXRlbSA9IGl0ZW0ucmlnaHQpIHtcbiAgICAgICAgICBpZiAoaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pICYmICF0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AuZGVsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IGRlbGV0ZTogMCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5kZWxldGUgKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIGRlbGV0ZWQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfSAvLyBlbHNlIG5vcFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLmluc2VydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKCk7XG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyBpbnNlcnQ6IFtdIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLmluc2VydCA9IGxhc3RPcC5pbnNlcnQuY29uY2F0KGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICBhZGRlZC5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5yZXRhaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpO1xuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgcmV0YWluOiAwIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLnJldGFpbiArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RPcCAhPT0gbnVsbCAmJiBsYXN0T3AucmV0YWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hhbmdlZC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAodGFyZ2V0Ll9tYXAuZ2V0KGtleSkpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHsnZGVsZXRlJyB8ICdhZGQnIHwgJ3VwZGF0ZSd9XG4gICAgICAgICAgICovXG4gICAgICAgICAgbGV0IGFjdGlvbjtcbiAgICAgICAgICBsZXQgb2xkVmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBpdGVtLmxlZnQ7XG4gICAgICAgICAgICB3aGlsZSAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmFkZHMocHJldikpIHtcbiAgICAgICAgICAgICAgcHJldiA9IHByZXYubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwgJiYgdGhpcy5kZWxldGVzKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBsYXN0KHByZXYuY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmRlbGV0ZXMocHJldikpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAndXBkYXRlJztcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGxhc3QocHJldi5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ2FkZCc7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgb2xkVmFsdWUgPSBsYXN0KC8qKiBAdHlwZSB7SXRlbX0gKi8gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gLy8gbm9wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleXMuc2V0KGtleSwgeyBhY3Rpb24sIG9sZFZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2NoYW5nZXMgPSBjaGFuZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjaGFuZ2VzKVxuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgcGF0aCBmcm9tIHRoaXMgdHlwZSB0byB0aGUgc3BlY2lmaWVkIHRhcmdldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBgY2hpbGRgIHNob3VsZCBiZSBhY2Nlc3NpYmxlIHZpYSBgdHlwZS5nZXQocGF0aFswXSkuZ2V0KHBhdGhbMV0pLi5gXG4gKiAgIGNvbnN0IHBhdGggPSB0eXBlLmdldFBhdGhUbyhjaGlsZClcbiAqICAgLy8gYXNzdW1pbmcgYHR5cGUgaW5zdGFuY2VvZiBZQXJyYXlgXG4gKiAgIGNvbnNvbGUubG9nKHBhdGgpIC8vIG1pZ2h0IGxvb2sgbGlrZSA9PiBbMiwgJ2tleTEnXVxuICogICBjaGlsZCA9PT0gdHlwZS5nZXQocGF0aFswXSkuZ2V0KHBhdGhbMV0pXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBjaGlsZCB0YXJnZXRcbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZ3xudW1iZXI+fSBQYXRoIHRvIHRoZSB0YXJnZXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFBhdGhUbyA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKGNoaWxkLl9pdGVtICE9PSBudWxsICYmIGNoaWxkICE9PSBwYXJlbnQpIHtcbiAgICBpZiAoY2hpbGQuX2l0ZW0ucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbWFwLWlzaFxuICAgICAgcGF0aC51bnNoaWZ0KGNoaWxkLl9pdGVtLnBhcmVudFN1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhcmVudCBpcyBhcnJheS1pc2hcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGxldCBjID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLl9pdGVtLnBhcmVudCkuX3N0YXJ0O1xuICAgICAgd2hpbGUgKGMgIT09IGNoaWxkLl9pdGVtICYmIGMgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFjLmRlbGV0ZWQpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgYyA9IGMucmlnaHQ7XG4gICAgICB9XG4gICAgICBwYXRoLnVuc2hpZnQoaSk7XG4gICAgfVxuICAgIGNoaWxkID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLl9pdGVtLnBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIHBhdGhcbn07XG5cbmNvbnN0IG1heFNlYXJjaE1hcmtlciA9IDgwO1xuXG4vKipcbiAqIEEgdW5pcXVlIHRpbWVzdGFtcCB0aGF0IGlkZW50aWZpZXMgZWFjaCBtYXJrZXIuXG4gKlxuICogVGltZSBpcyByZWxhdGl2ZSwuLiB0aGlzIGlzIG1vcmUgbGlrZSBhbiBldmVyLWluY3JlYXNpbmcgY2xvY2suXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xubGV0IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCA9IDA7XG5cbmNsYXNzIEFycmF5U2VhcmNoTWFya2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SXRlbX0gcFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIGNvbnN0cnVjdG9yIChwLCBpbmRleCkge1xuICAgIHAubWFya2VyID0gdHJ1ZTtcbiAgICB0aGlzLnAgPSBwO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCsrO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheVNlYXJjaE1hcmtlcn0gbWFya2VyXG4gKi9cbmNvbnN0IHJlZnJlc2hNYXJrZXJUaW1lc3RhbXAgPSBtYXJrZXIgPT4geyBtYXJrZXIudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKys7IH07XG5cbi8qKlxuICogVGhpcyBpcyByYXRoZXIgY29tcGxleCBzbyB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBvbmx5IHRoaW5nIHRoYXQgc2hvdWxkIG92ZXJ3cml0ZSBhIG1hcmtlclxuICpcbiAqIEBwYXJhbSB7QXJyYXlTZWFyY2hNYXJrZXJ9IG1hcmtlclxuICogQHBhcmFtIHtJdGVtfSBwXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuY29uc3Qgb3ZlcndyaXRlTWFya2VyID0gKG1hcmtlciwgcCwgaW5kZXgpID0+IHtcbiAgbWFya2VyLnAubWFya2VyID0gZmFsc2U7XG4gIG1hcmtlci5wID0gcDtcbiAgcC5tYXJrZXIgPSB0cnVlO1xuICBtYXJrZXIuaW5kZXggPSBpbmRleDtcbiAgbWFya2VyLnRpbWVzdGFtcCA9IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCsrO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn0gc2VhcmNoTWFya2VyXG4gKiBAcGFyYW0ge0l0ZW19IHBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5jb25zdCBtYXJrUG9zaXRpb24gPSAoc2VhcmNoTWFya2VyLCBwLCBpbmRleCkgPT4ge1xuICBpZiAoc2VhcmNoTWFya2VyLmxlbmd0aCA+PSBtYXhTZWFyY2hNYXJrZXIpIHtcbiAgICAvLyBvdmVycmlkZSBvbGRlc3QgbWFya2VyICh3ZSBkb24ndCB3YW50IHRvIGNyZWF0ZSBtb3JlIG9iamVjdHMpXG4gICAgY29uc3QgbWFya2VyID0gc2VhcmNoTWFya2VyLnJlZHVjZSgoYSwgYikgPT4gYS50aW1lc3RhbXAgPCBiLnRpbWVzdGFtcCA/IGEgOiBiKTtcbiAgICBvdmVyd3JpdGVNYXJrZXIobWFya2VyLCBwLCBpbmRleCk7XG4gICAgcmV0dXJuIG1hcmtlclxuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBuZXcgbWFya2VyXG4gICAgY29uc3QgcG0gPSBuZXcgQXJyYXlTZWFyY2hNYXJrZXIocCwgaW5kZXgpO1xuICAgIHNlYXJjaE1hcmtlci5wdXNoKHBtKTtcbiAgICByZXR1cm4gcG1cbiAgfVxufTtcblxuLyoqXG4gKiBTZWFyY2ggbWFya2VyIGhlbHAgdXMgdG8gZmluZCBwb3NpdGlvbnMgaW4gdGhlIGFzc29jaWF0aXZlIGFycmF5IGZhc3Rlci5cbiAqXG4gKiBUaGV5IHNwZWVkIHVwIHRoZSBwcm9jZXNzIG9mIGZpbmRpbmcgYSBwb3NpdGlvbiB3aXRob3V0IG11Y2ggYm9va2tlZXBpbmcuXG4gKlxuICogQSBtYXhpbXVtIG9mIGBtYXhTZWFyY2hNYXJrZXJgIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbHdheXMgcmV0dXJucyBhIHJlZnJlc2hlZCBtYXJrZXIgKHVwZGF0ZWQgdGltZXN0YW1wKVxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHlhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IGZpbmRNYXJrZXIgPSAoeWFycmF5LCBpbmRleCkgPT4ge1xuICBpZiAoeWFycmF5Ll9zdGFydCA9PT0gbnVsbCB8fCBpbmRleCA9PT0gMCB8fCB5YXJyYXkuX3NlYXJjaE1hcmtlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgY29uc3QgbWFya2VyID0geWFycmF5Ll9zZWFyY2hNYXJrZXIubGVuZ3RoID09PSAwID8gbnVsbCA6IHlhcnJheS5fc2VhcmNoTWFya2VyLnJlZHVjZSgoYSwgYikgPT4gYWJzKGluZGV4IC0gYS5pbmRleCkgPCBhYnMoaW5kZXggLSBiLmluZGV4KSA/IGEgOiBiKTtcbiAgbGV0IHAgPSB5YXJyYXkuX3N0YXJ0O1xuICBsZXQgcGluZGV4ID0gMDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIHAgPSBtYXJrZXIucDtcbiAgICBwaW5kZXggPSBtYXJrZXIuaW5kZXg7XG4gICAgcmVmcmVzaE1hcmtlclRpbWVzdGFtcChtYXJrZXIpOyAvLyB3ZSB1c2VkIGl0LCB3ZSBtaWdodCBuZWVkIHRvIHVzZSBpdCBhZ2FpblxuICB9XG4gIC8vIGl0ZXJhdGUgdG8gcmlnaHQgaWYgcG9zc2libGVcbiAgd2hpbGUgKHAucmlnaHQgIT09IG51bGwgJiYgcGluZGV4IDwgaW5kZXgpIHtcbiAgICBpZiAoIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgcGluZGV4ICsgcC5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBpbmRleCArPSBwLmxlbmd0aDtcbiAgICB9XG4gICAgcCA9IHAucmlnaHQ7XG4gIH1cbiAgLy8gaXRlcmF0ZSB0byBsZWZ0IGlmIG5lY2Vzc2FyeSAobWlnaHQgYmUgdGhhdCBwaW5kZXggPiBpbmRleClcbiAgd2hpbGUgKHAubGVmdCAhPT0gbnVsbCAmJiBwaW5kZXggPiBpbmRleCkge1xuICAgIHAgPSBwLmxlZnQ7XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIHBpbmRleCAtPSBwLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBwIGNhbid0IGJlIG1lcmdlZCB3aXRoIGxlZnQsIGJlY2F1c2UgdGhhdCB3b3VsZCBzY3JldyB1cCBldmVyeXRoaW5nXG4gIC8vIGluIHRoYXQgY2FzIGp1c3QgcmV0dXJuIHdoYXQgd2UgaGF2ZSAoaXQgaXMgbW9zdCBsaWtlbHkgdGhlIGJlc3QgbWFya2VyIGFueXdheSlcbiAgLy8gaXRlcmF0ZSB0byBsZWZ0IHVudGlsIHAgY2FuJ3QgYmUgbWVyZ2VkIHdpdGggbGVmdFxuICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsICYmIHAubGVmdC5pZC5jbGllbnQgPT09IHAuaWQuY2xpZW50ICYmIHAubGVmdC5pZC5jbG9jayArIHAubGVmdC5sZW5ndGggPT09IHAuaWQuY2xvY2spIHtcbiAgICBwID0gcC5sZWZ0O1xuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBwaW5kZXggLT0gcC5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgLy8gQHRvZG8gcmVtb3ZlIVxuICAvLyBhc3N1cmUgcG9zaXRpb25cbiAgLy8ge1xuICAvLyAgIGxldCBzdGFydCA9IHlhcnJheS5fc3RhcnRcbiAgLy8gICBsZXQgcG9zID0gMFxuICAvLyAgIHdoaWxlIChzdGFydCAhPT0gcCkge1xuICAvLyAgICAgaWYgKCFzdGFydC5kZWxldGVkICYmIHN0YXJ0LmNvdW50YWJsZSkge1xuICAvLyAgICAgICBwb3MgKz0gc3RhcnQubGVuZ3RoXG4gIC8vICAgICB9XG4gIC8vICAgICBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHN0YXJ0LnJpZ2h0KVxuICAvLyAgIH1cbiAgLy8gICBpZiAocG9zICE9PSBwaW5kZXgpIHtcbiAgLy8gICAgIGRlYnVnZ2VyXG4gIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvdGNoYSBwb3NpdGlvbiBmYWlsIScpXG4gIC8vICAgfVxuICAvLyB9XG4gIC8vIGlmIChtYXJrZXIpIHtcbiAgLy8gICBpZiAod2luZG93Lmxlbmd0aGVzID09IG51bGwpIHtcbiAgLy8gICAgIHdpbmRvdy5sZW5ndGhlcyA9IFtdXG4gIC8vICAgICB3aW5kb3cuZ2V0TGVuZ3RoZXMgPSAoKSA9PiB3aW5kb3cubGVuZ3RoZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gIC8vICAgfVxuICAvLyAgIHdpbmRvdy5sZW5ndGhlcy5wdXNoKG1hcmtlci5pbmRleCAtIHBpbmRleClcbiAgLy8gICBjb25zb2xlLmxvZygnZGlzdGFuY2UnLCBtYXJrZXIuaW5kZXggLSBwaW5kZXgsICdsZW4nLCBwICYmIHAucGFyZW50Lmxlbmd0aClcbiAgLy8gfVxuICBpZiAobWFya2VyICE9PSBudWxsICYmIGFicyhtYXJrZXIuaW5kZXggLSBwaW5kZXgpIDwgLyoqIEB0eXBlIHtZVGV4dHxZQXJyYXk8YW55Pn0gKi8gKHAucGFyZW50KS5sZW5ndGggLyBtYXhTZWFyY2hNYXJrZXIpIHtcbiAgICAvLyBhZGp1c3QgZXhpc3RpbmcgbWFya2VyXG4gICAgb3ZlcndyaXRlTWFya2VyKG1hcmtlciwgcCwgcGluZGV4KTtcbiAgICByZXR1cm4gbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIG5ldyBtYXJrZXJcbiAgICByZXR1cm4gbWFya1Bvc2l0aW9uKHlhcnJheS5fc2VhcmNoTWFya2VyLCBwLCBwaW5kZXgpXG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIG1hcmtlcnMgd2hlbiBhIGNoYW5nZSBoYXBwZW5lZC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGRvaW5nIGEgZGVsZXRpb24hXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59IHNlYXJjaE1hcmtlclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIElmIGluc2VydGlvbiwgbGVuIGlzIHBvc2l0aXZlLiBJZiBkZWxldGlvbiwgbGVuIGlzIG5lZ2F0aXZlLlxuICovXG5jb25zdCB1cGRhdGVNYXJrZXJDaGFuZ2VzID0gKHNlYXJjaE1hcmtlciwgaW5kZXgsIGxlbikgPT4ge1xuICBmb3IgKGxldCBpID0gc2VhcmNoTWFya2VyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgbSA9IHNlYXJjaE1hcmtlcltpXTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgcCA9IG0ucDtcbiAgICAgIHAubWFya2VyID0gZmFsc2U7XG4gICAgICAvLyBJZGVhbGx5IHdlIGp1c3Qgd2FudCB0byBkbyBhIHNpbXBsZSBwb3NpdGlvbiBjb21wYXJpc29uLCBidXQgdGhpcyB3aWxsIG9ubHkgd29yayBpZlxuICAgICAgLy8gc2VhcmNoIG1hcmtlcnMgZG9uJ3QgcG9pbnQgdG8gZGVsZXRlZCBpdGVtcyBmb3IgZm9ybWF0cy5cbiAgICAgIC8vIEl0ZXJhdGUgbWFya2VyIHRvIHByZXYgdW5kZWxldGVkIGNvdW50YWJsZSBwb3NpdGlvbiBzbyB3ZSBrbm93IHdoYXQgdG8gZG8gd2hlbiB1cGRhdGluZyBhIHBvc2l0aW9uXG4gICAgICB3aGlsZSAocCAmJiAocC5kZWxldGVkIHx8ICFwLmNvdW50YWJsZSkpIHtcbiAgICAgICAgcCA9IHAubGVmdDtcbiAgICAgICAgaWYgKHAgJiYgIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgICAgIC8vIGFkanVzdCBwb3NpdGlvbi4gdGhlIGxvb3Agc2hvdWxkIGJyZWFrIG5vd1xuICAgICAgICAgIG0uaW5kZXggLT0gcC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwID09PSBudWxsIHx8IHAubWFya2VyID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBzZWFyY2ggbWFya2VyIGlmIHVwZGF0ZWQgcG9zaXRpb24gaXMgbnVsbCBvciBpZiBwb3NpdGlvbiBpcyBhbHJlYWR5IG1hcmtlZFxuICAgICAgICBzZWFyY2hNYXJrZXIuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbS5wID0gcDtcbiAgICAgIHAubWFya2VyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgbS5pbmRleCB8fCAobGVuID4gMCAmJiBpbmRleCA9PT0gbS5pbmRleCkpIHsgLy8gYSBzaW1wbGUgaW5kZXggPD0gbS5pbmRleCBjaGVjayB3b3VsZCBhY3R1YWxseSBzdWZmaWNlXG4gICAgICBtLmluZGV4ID0gbWF4KGluZGV4LCBtLmluZGV4ICsgbGVuKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWNjdW11bGF0ZSBhbGwgKGxpc3QpIGNoaWxkcmVuIG9mIGEgdHlwZSBhbmQgcmV0dXJuIHRoZW0gYXMgYW4gQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdFxuICogQHJldHVybiB7QXJyYXk8SXRlbT59XG4gKi9cbmNvbnN0IGdldFR5cGVDaGlsZHJlbiA9IHQgPT4ge1xuICBsZXQgcyA9IHQuX3N0YXJ0O1xuICBjb25zdCBhcnIgPSBbXTtcbiAgd2hpbGUgKHMpIHtcbiAgICBhcnIucHVzaChzKTtcbiAgICBzID0gcy5yaWdodDtcbiAgfVxuICByZXR1cm4gYXJyXG59O1xuXG4vKipcbiAqIENhbGwgZXZlbnQgbGlzdGVuZXJzIHdpdGggYW4gZXZlbnQuIFRoaXMgd2lsbCBhbHNvIGFkZCBhbiBldmVudCB0byBhbGxcbiAqIHBhcmVudHMgKGZvciBgLm9ic2VydmVEZWVwYCBoYW5kbGVycykuXG4gKlxuICogQHRlbXBsYXRlIEV2ZW50VHlwZVxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn0gdHlwZVxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RXZlbnRUeXBlfSBldmVudFxuICovXG5jb25zdCBjYWxsVHlwZU9ic2VydmVycyA9ICh0eXBlLCB0cmFuc2FjdGlvbiwgZXZlbnQpID0+IHtcbiAgY29uc3QgY2hhbmdlZFR5cGUgPSB0eXBlO1xuICBjb25zdCBjaGFuZ2VkUGFyZW50VHlwZXMgPSB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXM7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNldElmVW5kZWZpbmVkKGNoYW5nZWRQYXJlbnRUeXBlcywgdHlwZSwgKCkgPT4gW10pLnB1c2goZXZlbnQpO1xuICAgIGlmICh0eXBlLl9pdGVtID09PSBudWxsKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICB0eXBlID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHR5cGUuX2l0ZW0ucGFyZW50KTtcbiAgfVxuICBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzKGNoYW5nZWRUeXBlLl9lSCwgZXZlbnQsIHRyYW5zYWN0aW9uKTtcbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIEV2ZW50VHlwZVxuICogQWJzdHJhY3QgWWpzIFR5cGUgY2xhc3NcbiAqL1xuY2xhc3MgQWJzdHJhY3RUeXBlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5faXRlbSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsSXRlbT59XG4gICAgICovXG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEb2N8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRvYyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyc1xuICAgICAqIEB0eXBlIHtFdmVudEhhbmRsZXI8RXZlbnRUeXBlLFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9lSCA9IGNyZWF0ZUV2ZW50SGFuZGxlcigpO1xuICAgIC8qKlxuICAgICAqIERlZXAgZXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAdHlwZSB7RXZlbnRIYW5kbGVyPEFycmF5PFlFdmVudD4sVHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX2RFSCA9IGNyZWF0ZUV2ZW50SGFuZGxlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPGFueT58bnVsbH1cbiAgICovXG4gIGdldCBwYXJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtID8gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMuX2l0ZW0ucGFyZW50KSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW18bnVsbH0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHRoaXMuZG9jID0geTtcbiAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICB0aHJvdyBtZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICB0aHJvdyBtZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRW5jb2Rlcn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7IH1cblxuICAvKipcbiAgICogVGhlIGZpcnN0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBfZmlyc3QgKCkge1xuICAgIGxldCBuID0gdGhpcy5fc3RhcnQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlFdmVudCBhbmQgY2FsbHMgYWxsIHR5cGUgb2JzZXJ2ZXJzLlxuICAgKiBNdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbi5sb2NhbCAmJiB0aGlzLl9zZWFyY2hNYXJrZXIpIHtcbiAgICAgIHRoaXMuX3NlYXJjaE1hcmtlci5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGFsbCBldmVudHMgdGhhdCBhcmUgY3JlYXRlZCBvbiB0aGlzIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnRUeXBlLCBUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgb2JzZXJ2ZSAoZikge1xuICAgIGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2VILCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGFsbCBldmVudHMgdGhhdCBhcmUgY3JlYXRlZCBieSB0aGlzIHR5cGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxZRXZlbnQ+LFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICBvYnNlcnZlRGVlcCAoZikge1xuICAgIGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2RFSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhbiBvYnNlcnZlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudFR5cGUsVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIHVub2JzZXJ2ZSAoZikge1xuICAgIHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2VILCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGFuIG9ic2VydmVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PFlFdmVudD4sVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIHVub2JzZXJ2ZURlZXAgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9kRUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICB0b0pTT04gKCkge31cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFNsaWNlID0gKHR5cGUsIHN0YXJ0LCBlbmQpID0+IHtcbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdHlwZS5fbGVuZ3RoICsgc3RhcnQ7XG4gIH1cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSB0eXBlLl9sZW5ndGggKyBlbmQ7XG4gIH1cbiAgbGV0IGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBjb25zdCBjcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobiAhPT0gbnVsbCAmJiBsZW4gPiAwKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgaWYgKGMubGVuZ3RoIDw9IHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0IC09IGMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgYy5sZW5ndGggJiYgbGVuID4gMDsgaSsrKSB7XG4gICAgICAgICAgY3MucHVzaChjW2ldKTtcbiAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIHJldHVybiBjc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RUb0FycmF5ID0gdHlwZSA9PiB7XG4gIGNvbnN0IGNzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzLnB1c2goY1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIHJldHVybiBjc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0VG9BcnJheVNuYXBzaG90ID0gKHR5cGUsIHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGNzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmIGlzVmlzaWJsZShuLCBzbmFwc2hvdCkpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzLnB1c2goY1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIHJldHVybiBjc1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gb3ZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxudW1iZXIsYW55KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RGb3JFYWNoID0gKHR5cGUsIGYpID0+IHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZihjW2ldLCBpbmRleCsrLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIEMsUlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihDLG51bWJlcixBYnN0cmFjdFR5cGU8YW55Pik6Un0gZlxuICogQHJldHVybiB7QXJyYXk8Uj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdE1hcCA9ICh0eXBlLCBmKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICB0eXBlTGlzdEZvckVhY2godHlwZSwgKGMsIGkpID0+IHtcbiAgICByZXN1bHQucHVzaChmKGMsIGksIHR5cGUpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RDcmVhdGVJdGVyYXRvciA9IHR5cGUgPT4ge1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PGFueT58bnVsbH1cbiAgICovXG4gIGxldCBjdXJyZW50Q29udGVudCA9IG51bGw7XG4gIGxldCBjdXJyZW50Q29udGVudEluZGV4ID0gMDtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgLy8gZmluZCBzb21lIGNvbnRlbnRcbiAgICAgIGlmIChjdXJyZW50Q29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSByZWFjaGVkIHRoZSBlbmQsIG5vIG5lZWQgdG8gY2hlY2sgY3VycmVudENvbnRlbnQsIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZm91bmQgbiwgc28gd2UgY2FuIHNldCBjdXJyZW50Q29udGVudFxuICAgICAgICBjdXJyZW50Q29udGVudCA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICAgIGN1cnJlbnRDb250ZW50SW5kZXggPSAwO1xuICAgICAgICBuID0gbi5yaWdodDsgLy8gd2UgdXNlZCB0aGUgY29udGVudCBvZiBuLCBub3cgaXRlcmF0ZSB0byBuZXh0XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnRDb250ZW50W2N1cnJlbnRDb250ZW50SW5kZXgrK107XG4gICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGVtcHR5IGN1cnJlbnRDb250ZW50XG4gICAgICBpZiAoY3VycmVudENvbnRlbnQubGVuZ3RoIDw9IGN1cnJlbnRDb250ZW50SW5kZXgpIHtcbiAgICAgICAgY3VycmVudENvbnRlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7YW55fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RHZXQgPSAodHlwZSwgaW5kZXgpID0+IHtcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcih0eXBlLCBpbmRleCk7XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBuID0gbWFya2VyLnA7XG4gICAgaW5kZXggLT0gbWFya2VyLmluZGV4O1xuICB9XG4gIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbi5jb250ZW50LmdldENvbnRlbnQoKVtpbmRleF1cbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW0/fSByZWZlcmVuY2VJdGVtXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fGJvb2xlYW58bnVtYmVyfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIHJlZmVyZW5jZUl0ZW0sIGNvbnRlbnQpID0+IHtcbiAgbGV0IGxlZnQgPSByZWZlcmVuY2VJdGVtO1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgY29uc3QgcmlnaHQgPSByZWZlcmVuY2VJdGVtID09PSBudWxsID8gcGFyZW50Ll9zdGFydCA6IHJlZmVyZW5jZUl0ZW0ucmlnaHQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8T2JqZWN0fEFycmF5PGFueT58bnVtYmVyPn1cbiAgICovXG4gIGxldCBqc29uQ29udGVudCA9IFtdO1xuICBjb25zdCBwYWNrSnNvbkNvbnRlbnQgPSAoKSA9PiB7XG4gICAgaWYgKGpzb25Db250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEFueShqc29uQ29udGVudCkpO1xuICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAganNvbkNvbnRlbnQgPSBbXTtcbiAgICB9XG4gIH07XG4gIGNvbnRlbnQuZm9yRWFjaChjID0+IHtcbiAgICBzd2l0Y2ggKGMuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICBjYXNlIEFycmF5OlxuICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgIGpzb25Db250ZW50LnB1c2goYyk7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYWNrSnNvbkNvbnRlbnQoKTtcbiAgICAgICAgc3dpdGNoIChjLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRCaW5hcnkobmV3IFVpbnQ4QXJyYXkoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAoYykpKSk7XG4gICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgRG9jOlxuICAgICAgICAgICAgbGVmdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50RG9jKC8qKiBAdHlwZSB7RG9jfSAqLyAoYykpKTtcbiAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudFR5cGUoYykpO1xuICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGVudCB0eXBlIGluIGluc2VydCBvcGVyYXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9KTtcbiAgcGFja0pzb25Db250ZW50KCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxudW1iZXJ8c3RyaW5nfFVpbnQ4QXJyYXk+fSBjb250ZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEluc2VydEdlbmVyaWNzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4LCBjb250ZW50KSA9PiB7XG4gIGlmIChpbmRleCA9PT0gMCkge1xuICAgIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgaW5kZXgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlcih0cmFuc2FjdGlvbiwgcGFyZW50LCBudWxsLCBjb250ZW50KVxuICB9XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KTtcbiAgbGV0IG4gPSBwYXJlbnQuX3N0YXJ0O1xuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgbiA9IG1hcmtlci5wO1xuICAgIGluZGV4IC09IG1hcmtlci5pbmRleDtcbiAgICAvLyB3ZSBuZWVkIHRvIGl0ZXJhdGUgb25lIHRvIHRoZSBsZWZ0IHNvIHRoYXQgdGhlIGFsZ29yaXRobSB3b3Jrc1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgLy8gQHRvZG8gcmVmYWN0b3IgdGhpcyBhcyBpdCBhY3R1YWxseSBkb2Vzbid0IGNvbnNpZGVyIGZvcm1hdHNcbiAgICAgIG4gPSBuLnByZXY7IC8vIGltcG9ydGFudCEgZ2V0IHRoZSBsZWZ0IHVuZGVsZXRlZCBpdGVtIHNvIHRoYXQgd2UgY2FuIGFjdHVhbGx5IGRlY3JlYXNlIGluZGV4XG4gICAgICBpbmRleCArPSAobiAmJiBuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSA/IG4ubGVuZ3RoIDogMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8PSBuLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGluc2VydCBpbi1iZXR3ZWVuXG4gICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIHN0YXJ0SW5kZXgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG4sIGNvbnRlbnQpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3REZWxldGUgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgsIGxlbmd0aCkgPT4ge1xuICBpZiAobGVuZ3RoID09PSAwKSB7IHJldHVybiB9XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGg7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCk7XG4gIGxldCBuID0gcGFyZW50Ll9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gIH1cbiAgLy8gY29tcHV0ZSB0aGUgZmlyc3QgaXRlbSB0byBiZSBkZWxldGVkXG4gIGZvciAoOyBuICE9PSBudWxsICYmIGluZGV4ID4gMDsgbiA9IG4ucmlnaHQpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICAvLyBkZWxldGUgYWxsIGl0ZW1zIHVudGlsIGRvbmVcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgbiAhPT0gbnVsbCkge1xuICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBuLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICBsZW5ndGggLT0gbi5sZW5ndGg7XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgY3JlYXRlJDEoJ2FycmF5IGxlbmd0aCBleGNlZWRlZCcpXG4gIH1cbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgc3RhcnRJbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoIC8qIGluIGNhc2Ugd2UgcmVtb3ZlIHRoZSBhYm92ZSBleGNlcHRpb24gKi8pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBEZWxldGUgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IGMgPSBwYXJlbnQuX21hcC5nZXQoa2V5KTtcbiAgaWYgKGMgIT09IHVuZGVmaW5lZCkge1xuICAgIGMuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pn0gdmFsdWVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBTZXQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwga2V5LCB2YWx1ZSkgPT4ge1xuICBjb25zdCBsZWZ0ID0gcGFyZW50Ll9tYXAuZ2V0KGtleSkgfHwgbnVsbDtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgY29udGVudCA9IG5ldyBDb250ZW50QW55KFt2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICBjYXNlIEFycmF5OlxuICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEFueShbdmFsdWVdKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgY29udGVudCA9IG5ldyBDb250ZW50QmluYXJ5KC8qKiBAdHlwZSB7VWludDhBcnJheX0gKi8gKHZhbHVlKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIERvYzpcbiAgICAgICAgY29udGVudCA9IG5ldyBDb250ZW50RG9jKC8qKiBAdHlwZSB7RG9jfSAqLyAodmFsdWUpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSkge1xuICAgICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudFR5cGUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIG51bGwsIG51bGwsIHBhcmVudCwga2V5LCBjb250ZW50KS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwR2V0ID0gKHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IHZhbCA9IHBhcmVudC5fbWFwLmdldChrZXkpO1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgIXZhbC5kZWxldGVkID8gdmFsLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZhbC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsT2JqZWN0PHN0cmluZyxhbnk+fG51bWJlcnxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZD59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwR2V0QWxsID0gKHBhcmVudCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICovXG4gIGNvbnN0IHJlcyA9IHt9O1xuICBwYXJlbnQuX21hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKCF2YWx1ZS5kZWxldGVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbHVlLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZhbHVlLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEhhcyA9IChwYXJlbnQsIGtleSkgPT4ge1xuICBjb25zdCB2YWwgPSBwYXJlbnQuX21hcC5nZXQoa2V5KTtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkICYmICF2YWwuZGVsZXRlZFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT58dW5kZWZpbmVkfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEdldFNuYXBzaG90ID0gKHBhcmVudCwga2V5LCBzbmFwc2hvdCkgPT4ge1xuICBsZXQgdiA9IHBhcmVudC5fbWFwLmdldChrZXkpIHx8IG51bGw7XG4gIHdoaWxlICh2ICE9PSBudWxsICYmICghc25hcHNob3Quc3YuaGFzKHYuaWQuY2xpZW50KSB8fCB2LmlkLmNsb2NrID49IChzbmFwc2hvdC5zdi5nZXQodi5pZC5jbGllbnQpIHx8IDApKSkge1xuICAgIHYgPSB2LmxlZnQ7XG4gIH1cbiAgcmV0dXJuIHYgIT09IG51bGwgJiYgaXNWaXNpYmxlKHYsIHNuYXBzaG90KSA/IHYuY29udGVudC5nZXRDb250ZW50KClbdi5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsSXRlbT59IG1hcFxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxBcnJheTxhbnk+Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZU1hcEl0ZXJhdG9yID0gbWFwID0+IGl0ZXJhdG9yRmlsdGVyKG1hcC5lbnRyaWVzKCksIC8qKiBAcGFyYW0ge2FueX0gZW50cnkgKi8gZW50cnkgPT4gIWVudHJ5WzFdLmRlbGV0ZWQpO1xuXG4vKipcbiAqIEBtb2R1bGUgWUFycmF5XG4gKi9cblxuLyoqXG4gKiBFdmVudCB0aGF0IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlBcnJheVxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgWUFycmF5RXZlbnQgZXh0ZW5kcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtZQXJyYXk8VD59IHlhcnJheSBUaGUgY2hhbmdlZCB0eXBlXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yICh5YXJyYXksIHRyYW5zYWN0aW9uKSB7XG4gICAgc3VwZXIoeWFycmF5LCB0cmFuc2FjdGlvbik7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEEgc2hhcmVkIEFycmF5IGltcGxlbWVudGF0aW9uLlxuICogQHRlbXBsYXRlIFRcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZQXJyYXlFdmVudDxUPj5cbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxUPn1cbiAqL1xuY2xhc3MgWUFycmF5IGV4dGVuZHMgQWJzdHJhY3RUeXBlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT4/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59XG4gICAgICovXG4gICAgdGhpcy5fc2VhcmNoTWFya2VyID0gW107XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IFlBcnJheSBjb250YWluaW5nIHRoZSBzcGVjaWZpZWQgaXRlbXMuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGl0ZW1zXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICovXG4gIHN0YXRpYyBmcm9tIChpdGVtcykge1xuICAgIGNvbnN0IGEgPSBuZXcgWUFycmF5KCk7XG4gICAgYS5wdXNoKGl0ZW1zKTtcbiAgICByZXR1cm4gYVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSk7XG4gICAgdGhpcy5pbnNlcnQoMCwgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkpO1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWUFycmF5KClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFlBcnJheSgpO1xuICAgIGFyci5pbnNlcnQoMCwgdGhpcy50b0FycmF5KCkubWFwKGVsID0+XG4gICAgICBlbCBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IGVsLmNsb25lKCkgOiBlbFxuICAgICkpO1xuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVsaW1Db250ZW50ID09PSBudWxsID8gdGhpcy5fbGVuZ3RoIDogdGhpcy5fcHJlbGltQ29udGVudC5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlBcnJheUV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIHN1cGVyLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpO1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWUFycmF5RXZlbnQodGhpcywgdHJhbnNhY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBJbXBvcnRhbnQ6IFRoaXMgZnVuY3Rpb24gZXhwZWN0cyBhbiBhcnJheSBvZiBjb250ZW50LiBOb3QganVzdCBhIGNvbnRlbnRcbiAgICogb2JqZWN0LiBUaGUgcmVhc29uIGZvciB0aGlzIFwid2VpcmRuZXNzXCIgaXMgdGhhdCBpbnNlcnRpbmcgc2V2ZXJhbCBlbGVtZW50c1xuICAgKiBpcyB2ZXJ5IGVmZmljaWVudCB3aGVuIGl0IGlzIGRvbmUgYXMgYSBzaW5nbGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeWFycmF5Lmluc2VydCgwLCBbJ2EnXSlcbiAgICogIC8vIEluc2VydCBudW1iZXJzIDEsIDIgYXQgcG9zaXRpb24gMVxuICAgKiAgeWFycmF5Lmluc2VydCgxLCBbMSwgMl0pXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IGNvbnRlbnQgYXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGNvbnRlbnQgVGhlIGFycmF5IG9mIGNvbnRlbnRcbiAgICovXG4gIGluc2VydCAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3ModHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCBjb250ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zcGxpY2UoaW5kZXgsIDAsIC4uLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBhcHBlbmQuXG4gICAqL1xuICBwdXNoIChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQodGhpcy5sZW5ndGgsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gcHJlcHBlbmQuXG4gICAqL1xuICB1bnNoaWZ0IChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQoMCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCA9IDEpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0RGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zcGxpY2UoaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGktdGggZWxlbWVudCBmcm9tIGEgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybiBmcm9tIHRoZSBZQXJyYXlcbiAgICogQHJldHVybiB7VH1cbiAgICovXG4gIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RHZXQodGhpcywgaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0VG9BcnJheSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7QXJyYXk8VD59XG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0eXBlTGlzdFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChjID0+IGMgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBjLnRvSlNPTigpIDogYylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEFycmF5IHdpdGggdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnlcbiAgICogZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHRlbXBsYXRlIFQsTVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsbnVtYmVyLFlBcnJheTxUPik6TX0gZiBGdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGVsZW1lbnQgb2YgdGhlIG5ldyBBcnJheVxuICAgKiBAcmV0dXJuIHtBcnJheTxNPn0gQSBuZXcgYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBtYXAgKGYpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RNYXAodGhpcywgLyoqIEB0eXBlIHthbnl9ICovIChmKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gb3ZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihULG51bWJlcixZQXJyYXk8VD4pOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqL1xuICBmb3JFYWNoIChmKSB7XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0Q3JlYXRlSXRlcmF0b3IodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRW5jb2Rlcn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWUFycmF5UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZURlY29kZXJ9IGRlY29kZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZQXJyYXkgPSBkZWNvZGVyID0+IG5ldyBZQXJyYXkoKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZTWFwLlxuICovXG5jbGFzcyBZTWFwRXZlbnQgZXh0ZW5kcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtZTWFwPFQ+fSB5bWFwIFRoZSBZQXJyYXkgdGhhdCBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxhbnk+fSBzdWJzIFRoZSBrZXlzIHRoYXQgY2hhbmdlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh5bWFwLCB0cmFuc2FjdGlvbiwgc3Vicykge1xuICAgIHN1cGVyKHltYXAsIHRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLmtleXNDaGFuZ2VkID0gc3VicztcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUIG51bWJlcnxzdHJpbmd8T2JqZWN0fEFycmF5fFVpbnQ4QXJyYXlcbiAqIEEgc2hhcmVkIE1hcCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WU1hcEV2ZW50PFQ+PlxuICogQGltcGxlbWVudHMge0l0ZXJhYmxlPFQ+fVxuICovXG5jbGFzcyBZTWFwIGV4dGVuZHMgQWJzdHJhY3RUeXBlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGU8cmVhZG9ubHkgW3N0cmluZywgYW55XT49fSBlbnRyaWVzIC0gYW4gb3B0aW9uYWwgaXRlcmFibGUgdG8gaW5pdGlhbGl6ZSB0aGUgWU1hcFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVudHJpZXMpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLGFueT4/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG5cbiAgICBpZiAoZW50cmllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbmV3IE1hcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbmV3IE1hcChlbnRyaWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKVxuICAgIDsvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbDtcbiAgfVxuXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lNYXA8VD59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IFlNYXAoKTtcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IHZhbHVlLmNsb25lKCkgOiB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWU1hcEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWU1hcEV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsVD59XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLFQ+fVxuICAgICAqL1xuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIHRoaXMuX21hcC5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGNvbnN0IHYgPSBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpW2l0ZW0ubGVuZ3RoIC0gMV07XG4gICAgICAgIG1hcFtrZXldID0gdiBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IHYudG9KU09OKCkgOiB2O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBZTWFwIChjb3VudCBvZiBrZXkvdmFsdWUgcGFpcnMpXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gWy4uLmNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCldLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgWU1hcCBUeXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPHN0cmluZz59XG4gICAqL1xuICBrZXlzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKSwgLyoqIEBwYXJhbSB7YW55fSB2ICovIHYgPT4gdlswXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgWU1hcCBUeXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gICAqL1xuICB2YWx1ZXMgKCkge1xuICAgIHJldHVybiBpdGVyYXRvck1hcChjcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiB2WzFdLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZbMV0ubGVuZ3RoIC0gMV0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJdGVyYXRvciBvZiBba2V5LCB2YWx1ZV0gcGFpcnNcbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICAgKi9cbiAgZW50cmllcyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IFt2WzBdLCB2WzFdLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZbMV0ubGVuZ3RoIC0gMV1dKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBldmVyeSBrZXktdmFsdWUgcGFpci5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihULHN0cmluZyxZTWFwPFQ+KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKi9cbiAgZm9yRWFjaCAoZikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLFQ+fVxuICAgICAqL1xuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIHRoaXMuX21hcC5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGYoaXRlbS5jb250ZW50LmdldENvbnRlbnQoKVtpdGVtLmxlbmd0aCAtIDFdLCBrZXksIHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhpcyBZTWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgKi9cbiAgZGVsZXRlIChrZXkpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGtleSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGlzIFlNYXBcbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkXG4gICAqL1xuICBzZXQgKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhpcyBZTWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGtleSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzIChrZXkpIHtcbiAgICByZXR1cm4gdHlwZU1hcEhhcyh0aGlzLCBrZXkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZUVuY29kZXJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlNYXBSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRGVjb2Rlcn0gZGVjb2RlclxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlNYXAgPSBkZWNvZGVyID0+IG5ldyBZTWFwKCk7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBlcXVhbEF0dHJzID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgYSAmJiBiICYmIGVxdWFsRmxhdChhLCBiKSk7XG5cbmNsYXNzIEl0ZW1UZXh0TGlzdFBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSBsZWZ0XG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSByaWdodFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IGN1cnJlbnRBdHRyaWJ1dGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVmdCwgcmlnaHQsIGluZGV4LCBjdXJyZW50QXR0cmlidXRlcykge1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGVzID0gY3VycmVudEF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogT25seSBjYWxsIHRoaXMgaWYgeW91IGtub3cgdGhhdCB0aGlzLnJpZ2h0IGlzIGRlZmluZWRcbiAgICovXG4gIGZvcndhcmQgKCkge1xuICAgIGlmICh0aGlzLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICB1bmV4cGVjdGVkQ2FzZSgpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgIGlmICghdGhpcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdGhpcy5pbmRleCArPSB0aGlzLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICBpZiAoIXRoaXMucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKHRoaXMuY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKHRoaXMucmlnaHQuY29udGVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHRoaXMubGVmdCA9IHRoaXMucmlnaHQ7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMucmlnaHQucmlnaHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gcG9zXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgc3RlcHMgdG8gbW92ZSBmb3J3YXJkXG4gKiBAcmV0dXJuIHtJdGVtVGV4dExpc3RQb3NpdGlvbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmROZXh0UG9zaXRpb24gPSAodHJhbnNhY3Rpb24sIHBvcywgY291bnQpID0+IHtcbiAgd2hpbGUgKHBvcy5yaWdodCAhPT0gbnVsbCAmJiBjb3VudCA+IDApIHtcbiAgICBzd2l0Y2ggKHBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIENvbnRlbnRFbWJlZDpcbiAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgaWYgKCFwb3MucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIGlmIChjb3VudCA8IHBvcy5yaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJpZ2h0XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQocG9zLnJpZ2h0LmlkLmNsaWVudCwgcG9zLnJpZ2h0LmlkLmNsb2NrICsgY291bnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zLmluZGV4ICs9IHBvcy5yaWdodC5sZW5ndGg7XG4gICAgICAgICAgY291bnQgLT0gcG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMocG9zLmN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChwb3MucmlnaHQuY29udGVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHBvcy5sZWZ0ID0gcG9zLnJpZ2h0O1xuICAgIHBvcy5yaWdodCA9IHBvcy5yaWdodC5yaWdodDtcbiAgICAvLyBwb3MuZm9yd2FyZCgpIC0gd2UgZG9uJ3QgZm9yd2FyZCBiZWNhdXNlIHRoYXQgd291bGQgaGFsdmUgdGhlIHBlcmZvcm1hbmNlIGJlY2F1c2Ugd2UgYWxyZWFkeSBkbyB0aGUgY2hlY2tzIGFib3ZlXG4gIH1cbiAgcmV0dXJuIHBvc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZFBvc2l0aW9uID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICBjb25zdCBtYXJrZXIgPSBmaW5kTWFya2VyKHBhcmVudCwgaW5kZXgpO1xuICBpZiAobWFya2VyKSB7XG4gICAgY29uc3QgcG9zID0gbmV3IEl0ZW1UZXh0TGlzdFBvc2l0aW9uKG1hcmtlci5wLmxlZnQsIG1hcmtlci5wLCBtYXJrZXIuaW5kZXgsIGN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gZmluZE5leHRQb3NpdGlvbih0cmFuc2FjdGlvbiwgcG9zLCBpbmRleCAtIG1hcmtlci5pbmRleClcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obnVsbCwgcGFyZW50Ll9zdGFydCwgMCwgY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBmaW5kTmV4dFBvc2l0aW9uKHRyYW5zYWN0aW9uLCBwb3MsIGluZGV4KVxuICB9XG59O1xuXG4vKipcbiAqIE5lZ2F0ZSBhcHBsaWVkIGZvcm1hdHNcbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gbmVnYXRlZEF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIG5lZ2F0ZWRBdHRyaWJ1dGVzKSA9PiB7XG4gIC8vIGNoZWNrIGlmIHdlIHJlYWxseSBuZWVkIHRvIHJlbW92ZSBhdHRyaWJ1dGVzXG4gIHdoaWxlIChcbiAgICBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsICYmIChcbiAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlZCA9PT0gdHJ1ZSB8fCAoXG4gICAgICAgIGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCAmJlxuICAgICAgICBlcXVhbEF0dHJzKG5lZ2F0ZWRBdHRyaWJ1dGVzLmdldCgvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLmtleSksIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkudmFsdWUpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICBpZiAoIWN1cnJQb3MucmlnaHQuZGVsZXRlZCkge1xuICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuZGVsZXRlKC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkua2V5KTtcbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbGV0IGxlZnQgPSBjdXJyUG9zLmxlZnQ7XG4gIGNvbnN0IHJpZ2h0ID0gY3VyclBvcy5yaWdodDtcbiAgbmVnYXRlZEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50Rm9ybWF0KGtleSwgdmFsKSk7XG4gICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsKTtcbiAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChsZWZ0LmNvbnRlbnQpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBjdXJyZW50QXR0cmlidXRlc1xuICogQHBhcmFtIHtDb250ZW50Rm9ybWF0fSBmb3JtYXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzID0gKGN1cnJlbnRBdHRyaWJ1dGVzLCBmb3JtYXQpID0+IHtcbiAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBmb3JtYXQ7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzID0gKGN1cnJQb3MsIGF0dHJpYnV0ZXMpID0+IHtcbiAgLy8gZ28gcmlnaHQgd2hpbGUgYXR0cmlidXRlc1tyaWdodC5rZXldID09PSByaWdodC52YWx1ZSAob3IgcmlnaHQgaXMgZGVsZXRlZClcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoY3VyclBvcy5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCB8fCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmIGVxdWFsQXR0cnMoYXR0cmlidXRlc1soLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KSkua2V5XSB8fCBudWxsLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLnZhbHVlKSkpIDsgZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICogQHJldHVybiB7TWFwPHN0cmluZyxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGluc2VydEF0dHJpYnV0ZXMgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgLy8gaW5zZXJ0IGZvcm1hdC1zdGFydCBpdGVtc1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgdmFsID0gYXR0cmlidXRlc1trZXldO1xuICAgIGNvbnN0IGN1cnJlbnRWYWwgPSBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGw7XG4gICAgaWYgKCFlcXVhbEF0dHJzKGN1cnJlbnRWYWwsIHZhbCkpIHtcbiAgICAgIC8vIHNhdmUgbmVnYXRlZCBhdHRyaWJ1dGUgKHNldCBudWxsIGlmIGN1cnJlbnRWYWwgdW5kZWZpbmVkKVxuICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuc2V0KGtleSwgY3VycmVudFZhbCk7XG4gICAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBjdXJyUG9zO1xuICAgICAgY3VyclBvcy5yaWdodCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEZvcm1hdChrZXksIHZhbCkpO1xuICAgICAgY3VyclBvcy5yaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWdhdGVkQXR0cmlidXRlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICoqL1xuY29uc3QgaW5zZXJ0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCB0ZXh0LCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICBpZiAoYXR0cmlidXRlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IG51bGw7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcyk7XG4gIC8vIGluc2VydCBjb250ZW50XG4gIGNvbnN0IGNvbnRlbnQgPSB0ZXh0LmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyBuZXcgQ29udGVudFN0cmluZygvKiogQHR5cGUge3N0cmluZ30gKi8gKHRleHQpKSA6IG5ldyBDb250ZW50RW1iZWQodGV4dCk7XG4gIGxldCB7IGxlZnQsIHJpZ2h0LCBpbmRleCB9ID0gY3VyclBvcztcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgY29udGVudC5nZXRMZW5ndGgoKSk7XG4gIH1cbiAgcmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgY29udGVudCk7XG4gIHJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gIGN1cnJQb3MucmlnaHQgPSByaWdodDtcbiAgY3VyclBvcy5pbmRleCA9IGluZGV4O1xuICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZm9ybWF0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBsZW5ndGgsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcyk7XG4gIC8vIGl0ZXJhdGUgdW50aWwgZmlyc3Qgbm9uLWZvcm1hdCBvciBudWxsIGlzIGZvdW5kXG4gIC8vIGRlbGV0ZSBhbGwgZm9ybWF0cyB3aXRoIGF0dHJpYnV0ZXNbZm9ybWF0LmtleV0gIT0gbnVsbFxuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgaWYgKCFjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KTtcbiAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbEF0dHJzKGF0dHIsIHZhbHVlKSkge1xuICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDpcbiAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICAgIGlmIChsZW5ndGggPCBjdXJyUG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGN1cnJQb3MucmlnaHQuaWQuY2xpZW50LCBjdXJyUG9zLnJpZ2h0LmlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCAtPSBjdXJyUG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICAvLyBRdWlsbCBqdXN0IGFzc3VtZXMgdGhhdCB0aGUgZWRpdG9yIHN0YXJ0cyB3aXRoIGEgbmV3bGluZSBhbmQgdGhhdCBpdCBhbHdheXNcbiAgLy8gZW5kcyB3aXRoIGEgbmV3bGluZS4gV2Ugb25seSBpbnNlcnQgdGhhdCBuZXdsaW5lIHdoZW4gYSBuZXcgbmV3bGluZSBpc1xuICAvLyBpbnNlcnRlZCAtIGkuZSB3aGVuIGxlbmd0aCBpcyBiaWdnZXIgdGhhbiB0eXBlLmxlbmd0aFxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIGxldCBuZXdsaW5lcyA9ICcnO1xuICAgIGZvciAoOyBsZW5ndGggPiAwOyBsZW5ndGgtLSkge1xuICAgICAgbmV3bGluZXMgKz0gJ1xcbic7XG4gICAgfVxuICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBjdXJyUG9zLmxlZnQsIGN1cnJQb3MubGVmdCAmJiBjdXJyUG9zLmxlZnQubGFzdElkLCBjdXJyUG9zLnJpZ2h0LCBjdXJyUG9zLnJpZ2h0ICYmIGN1cnJQb3MucmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRTdHJpbmcobmV3bGluZXMpKTtcbiAgICBjdXJyUG9zLnJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbiAgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpO1xufTtcblxuLyoqXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgc3RyaW5nIGNvbnRlbnQgaGFzIGJlZW4gZGVsZXRlZCBpbiBvcmRlciB0b1xuICogY2xlYW4gdXAgZm9ybWF0dGluZyBJdGVtcy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtfSBzdGFydFxuICogQHBhcmFtIHtJdGVtfG51bGx9IGVuZCBleGNsdXNpdmUgZW5kLCBhdXRvbWF0aWNhbGx5IGl0ZXJhdGVzIHRvIHRoZSBuZXh0IENvbnRlbnQgSXRlbVxuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IHN0YXJ0QXR0cmlidXRlc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IGVuZEF0dHJpYnV0ZXMgVGhpcyBhdHRyaWJ1dGUgaXMgbW9kaWZpZWQhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgZm9ybWF0dGluZyBJdGVtcyBkZWxldGVkLlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjbGVhbnVwRm9ybWF0dGluZ0dhcCA9ICh0cmFuc2FjdGlvbiwgc3RhcnQsIGVuZCwgc3RhcnRBdHRyaWJ1dGVzLCBlbmRBdHRyaWJ1dGVzKSA9PiB7XG4gIHdoaWxlIChlbmQgJiYgZW5kLmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRTdHJpbmcgJiYgZW5kLmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRFbWJlZCkge1xuICAgIGlmICghZW5kLmRlbGV0ZWQgJiYgZW5kLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGVuZEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGVuZC5jb250ZW50KSk7XG4gICAgfVxuICAgIGVuZCA9IGVuZC5yaWdodDtcbiAgfVxuICBsZXQgY2xlYW51cHMgPSAwO1xuICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgIGlmICghc3RhcnQuZGVsZXRlZCkge1xuICAgICAgY29uc3QgY29udGVudCA9IHN0YXJ0LmNvbnRlbnQ7XG4gICAgICBzd2l0Y2ggKGNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjb250ZW50KTtcbiAgICAgICAgICBpZiAoKGVuZEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbCkgIT09IHZhbHVlIHx8IChzdGFydEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbCkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBFaXRoZXIgdGhpcyBmb3JtYXQgaXMgb3ZlcndyaXR0ZW4gb3IgaXQgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBhdHRyaWJ1dGUgYWxyZWFkeSBleGlzdGVkLlxuICAgICAgICAgICAgc3RhcnQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNsZWFudXBzKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovIChzdGFydC5yaWdodCk7XG4gIH1cbiAgcmV0dXJuIGNsZWFudXBzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBpdGVtXG4gKi9cbmNvbnN0IGNsZWFudXBDb250ZXh0bGVzc0Zvcm1hdHRpbmdHYXAgPSAodHJhbnNhY3Rpb24sIGl0ZW0pID0+IHtcbiAgLy8gaXRlcmF0ZSB1bnRpbCBpdGVtLnJpZ2h0IGlzIG51bGwgb3IgY29udGVudFxuICB3aGlsZSAoaXRlbSAmJiBpdGVtLnJpZ2h0ICYmIChpdGVtLnJpZ2h0LmRlbGV0ZWQgfHwgKGl0ZW0ucmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciAhPT0gQ29udGVudFN0cmluZyAmJiBpdGVtLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRFbWJlZCkpKSB7XG4gICAgaXRlbSA9IGl0ZW0ucmlnaHQ7XG4gIH1cbiAgY29uc3QgYXR0cnMgPSBuZXcgU2V0KCk7XG4gIC8vIGl0ZXJhdGUgYmFjayB1bnRpbCBhIGNvbnRlbnQgaXRlbSBpcyBmb3VuZFxuICB3aGlsZSAoaXRlbSAmJiAoaXRlbS5kZWxldGVkIHx8IChpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRTdHJpbmcgJiYgaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50RW1iZWQpKSkge1xuICAgIGlmICghaXRlbS5kZWxldGVkICYmIGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgY29uc3Qga2V5ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KS5rZXk7XG4gICAgICBpZiAoYXR0cnMuaGFzKGtleSkpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZW0gPSBpdGVtLmxlZnQ7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBleHBlcmltZW50YWwgYW5kIHN1YmplY3QgdG8gY2hhbmdlIC8gYmUgcmVtb3ZlZC5cbiAqXG4gKiBJZGVhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgZnVuY3Rpb24gYXQgYWxsLiBGb3JtYXR0aW5nIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGNsZWFuZWQgdXBcbiAqIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgZWFjaCBjaGFuZ2UuIFRoaXMgZnVuY3Rpb24gaXRlcmF0ZXMgdHdpY2Ugb3ZlciB0aGUgY29tcGxldGUgWVRleHQgdHlwZVxuICogYW5kIHJlbW92ZXMgdW5uZWNlc3NhcnkgZm9ybWF0dGluZyBhdHRyaWJ1dGVzLiBUaGlzIGlzIGFsc28gaGVscGZ1bCBmb3IgdGVzdGluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGV4cG9ydGVkIGFueW1vcmUgYXMgc29vbiBhcyB0aGVyZSBpcyBjb25maWRlbmNlIHRoYXQgdGhlIFlUZXh0IHR5cGUgd29ya3MgYXMgaW50ZW5kZWQuXG4gKlxuICogQHBhcmFtIHtZVGV4dH0gdHlwZVxuICogQHJldHVybiB7bnVtYmVyfSBIb3cgbWFueSBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIGNsZWFuZWQgdXAuXG4gKi9cbmNvbnN0IGNsZWFudXBZVGV4dEZvcm1hdHRpbmcgPSB0eXBlID0+IHtcbiAgbGV0IHJlcyA9IDA7XG4gIHRyYW5zYWN0KC8qKiBAdHlwZSB7RG9jfSAqLyAodHlwZS5kb2MpLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHN0YXJ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAodHlwZS5fc3RhcnQpO1xuICAgIGxldCBlbmQgPSB0eXBlLl9zdGFydDtcbiAgICBsZXQgc3RhcnRBdHRyaWJ1dGVzID0gY3JlYXRlJDIoKTtcbiAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IGNvcHkoc3RhcnRBdHRyaWJ1dGVzKTtcbiAgICB3aGlsZSAoZW5kKSB7XG4gICAgICBpZiAoZW5kLmRlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHN3aXRjaCAoZW5kLmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoZW5kLmNvbnRlbnQpKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICAgICAgcmVzICs9IGNsZWFudXBGb3JtYXR0aW5nR2FwKHRyYW5zYWN0aW9uLCBzdGFydCwgZW5kLCBzdGFydEF0dHJpYnV0ZXMsIGN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHN0YXJ0QXR0cmlidXRlcyA9IGNvcHkoY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbmQgPSBlbmQucmlnaHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBkZWxldGVUZXh0ID0gKHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBsZW5ndGgpID0+IHtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGg7XG4gIGNvbnN0IHN0YXJ0QXR0cnMgPSBjb3B5KGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMpO1xuICBjb25zdCBzdGFydCA9IGN1cnJQb3MucmlnaHQ7XG4gIHdoaWxlIChsZW5ndGggPiAwICYmIGN1cnJQb3MucmlnaHQgIT09IG51bGwpIHtcbiAgICBpZiAoY3VyclBvcy5yaWdodC5kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgc3dpdGNoIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgICBpZiAobGVuZ3RoIDwgY3VyclBvcy5yaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjdXJyUG9zLnJpZ2h0LmlkLmNsaWVudCwgY3VyclBvcy5yaWdodC5pZC5jbG9jayArIGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggLT0gY3VyclBvcy5yaWdodC5sZW5ndGg7XG4gICAgICAgICAgY3VyclBvcy5yaWdodC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9XG4gIGlmIChzdGFydCkge1xuICAgIGNsZWFudXBGb3JtYXR0aW5nR2FwKHRyYW5zYWN0aW9uLCBzdGFydCwgY3VyclBvcy5yaWdodCwgc3RhcnRBdHRycywgY29weShjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzKSk7XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKC8qKiBAdHlwZSB7SXRlbX0gKi8gKGN1cnJQb3MubGVmdCB8fCBjdXJyUG9zLnJpZ2h0KS5wYXJlbnQpO1xuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBjdXJyUG9zLmluZGV4LCAtc3RhcnRMZW5ndGggKyBsZW5ndGgpO1xuICB9XG4gIHJldHVybiBjdXJyUG9zXG59O1xuXG4vKipcbiAqIFRoZSBRdWlsbCBEZWx0YSBmb3JtYXQgcmVwcmVzZW50cyBjaGFuZ2VzIG9uIGEgdGV4dCBkb2N1bWVudCB3aXRoXG4gKiBmb3JtYXR0aW5nIGluZm9ybWF0aW9uLiBGb3IgbW9yIGluZm9ybWF0aW9uIHZpc2l0IHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHtcbiAqICAgICBvcHM6IFtcbiAqICAgICAgIHsgaW5zZXJ0OiAnR2FuZGFsZicsIGF0dHJpYnV0ZXM6IHsgYm9sZDogdHJ1ZSB9IH0sXG4gKiAgICAgICB7IGluc2VydDogJyB0aGUgJyB9LFxuICogICAgICAgeyBpbnNlcnQ6ICdHcmV5JywgYXR0cmlidXRlczogeyBjb2xvcjogJyNjY2NjY2MnIH0gfVxuICogICAgIF1cbiAqICAgfVxuICpcbiAqL1xuXG4vKipcbiAgKiBBdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIGFzc2lnbmVkIHRvIGEgc2VsZWN0aW9uIG9mIHRleHQuXG4gICpcbiAgKiBAZXhhbXBsZVxuICAqICAge1xuICAqICAgICBib2xkOiB0cnVlLFxuICAqICAgICBmb250LXNpemU6ICc0MHB4J1xuICAqICAgfVxuICAqXG4gICogQHR5cGVkZWYge09iamVjdH0gVGV4dEF0dHJpYnV0ZXNcbiAgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWx0YUl0ZW1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfHVuZGVmaW5lZH0gRGVsdGFJdGVtLmRlbGV0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ8dW5kZWZpbmVkfSBEZWx0YUl0ZW0ucmV0YWluXG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IERlbHRhSXRlbS5pbnNlcnRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZyxhbnk+fSBEZWx0YUl0ZW0uYXR0cmlidXRlc1xuICovXG5cbi8qKlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVGV4dCB0eXBlLlxuICovXG5jbGFzcyBZVGV4dEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVRleHR9IHl0ZXh0XG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeXRleHQsIHRyYW5zYWN0aW9uLCBzdWJzKSB7XG4gICAgc3VwZXIoeXRleHQsIHRyYW5zYWN0aW9uKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RGVsdGFJdGVtPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX2RlbHRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMua2V5c0NoYW5nZWQuYWRkKHN1Yik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgY2hhbmdlcyBpbiB0aGUgZGVsdGEgZm9ybWF0LlxuICAgKiBBIHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfSkgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG9uIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PERlbHRhSXRlbT59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCBkZWx0YSAoKSB7XG4gICAgaWYgKHRoaXMuX2RlbHRhID09PSBudWxsKSB7XG4gICAgICBjb25zdCB5ID0gLyoqIEB0eXBlIHtEb2N9ICovICh0aGlzLnRhcmdldC5kb2MpO1xuICAgICAgdGhpcy5fZGVsdGEgPSBbXTtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSAvKiogQHR5cGUge0FycmF5PERlbHRhSXRlbT59ICovICh0aGlzLl9kZWx0YSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpOyAvLyBzYXZlcyBhbGwgY3VycmVudCBhdHRyaWJ1dGVzIGZvciBpbnNlcnRcbiAgICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnRhcmdldC5fc3RhcnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nP31cbiAgICAgICAgICovXG4gICAgICAgIGxldCBhY3Rpb24gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTsgLy8gY291bnRzIGFkZGVkIG9yIHJlbW92ZWQgbmV3IGF0dHJpYnV0ZXMgZm9yIHJldGFpblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgaW5zZXJ0ID0gJyc7XG4gICAgICAgIGxldCByZXRhaW4gPSAwO1xuICAgICAgICBsZXQgZGVsZXRlTGVuID0gMDtcbiAgICAgICAgY29uc3QgYWRkT3AgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGFjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgb3A7XG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgIG9wID0geyBkZWxldGU6IGRlbGV0ZUxlbiB9O1xuICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgICAgICAgICBvcCA9IHsgaW5zZXJ0IH07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zZXJ0ID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSAncmV0YWluJzpcbiAgICAgICAgICAgICAgICBvcCA9IHsgcmV0YWluIH07XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlc1trZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWx0YS5wdXNoKG9wKTtcbiAgICAgICAgICAgIGFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAoaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2luc2VydCc7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQgPSAvKiogQHR5cGUge0NvbnRlbnRFbWJlZH0gKi8gKGl0ZW0uY29udGVudCkuZW1iZWQ7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gKz0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAncmV0YWluJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0YWluICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnaW5zZXJ0JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluc2VydCArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChpdGVtLmNvbnRlbnQpLnN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlTGVuICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdyZXRhaW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGl0ZW0uY29udGVudCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY3VyVmFsID0gY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmICghZXF1YWxBdHRycyhjdXJWYWwsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVxdWFsQXR0cnModmFsdWUsIChvbGRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyVmFsID0gY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWVxdWFsQXR0cnMoY3VyVmFsLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBjdXJWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXF1YWxBdHRycyhhdHRyLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGl0ZW0uY29udGVudCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGFkZE9wKCk7XG4gICAgICAgIHdoaWxlIChkZWx0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbGFzdE9wID0gZGVsdGFbZGVsdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3RPcC5yZXRhaW4gIT09IHVuZGVmaW5lZCAmJiBsYXN0T3AuYXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZXRhaW4gZGVsdGEncyBpZiB0aGV5IGRvbid0IGFzc2lnbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBkZWx0YS5wb3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVsdGFcbiAgfVxufVxuXG4vKipcbiAqIFR5cGUgdGhhdCByZXByZXNlbnRzIHRleHQgd2l0aCBmb3JtYXR0aW5nIGluZm9ybWF0aW9uLlxuICpcbiAqIFRoaXMgdHlwZSByZXBsYWNlcyB5LXJpY2h0ZXh0IGFzIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYWJsZSB0byBoYW5kbGVcbiAqIGJsb2NrIGZvcm1hdHMgKGZvcm1hdCBpbmZvcm1hdGlvbiBvbiBhIHBhcmFncmFwaCksIGVtYmVkcyAoY29tcGxleCBlbGVtZW50c1xuICogbGlrZSBwaWN0dXJlcyBhbmQgdmlkZW9zKSwgYW5kIHRleHQgZm9ybWF0cyAoKipib2xkKiosICppdGFsaWMqKS5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WVRleHRFdmVudD5cbiAqL1xuY2xhc3MgWVRleHQgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzdHJpbmddIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBZVGV4dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdHJpbmcpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHBlbmRpbmcgb3BlcmF0aW9ucyBvbiB0aGlzIHR5cGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oKTp2b2lkPj99XG4gICAgICovXG4gICAgdGhpcy5fcGVuZGluZyA9IHN0cmluZyAhPT0gdW5kZWZpbmVkID8gWygpID0+IHRoaXMuaW5zZXJ0KDAsIHN0cmluZyldIDogW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgY2hhcmFjdGVycyBvZiB0aGlzIHRleHQgdHlwZS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30geVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pO1xuICAgIHRyeSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLmZvckVhY2goZiA9PiBmKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmcgPSBudWxsO1xuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVRleHQoKTtcbiAgICB0ZXh0LmFwcGx5RGVsdGEodGhpcy50b0RlbHRhKCkpO1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZVGV4dEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIHN1cGVyLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IFlUZXh0RXZlbnQodGhpcywgdHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpO1xuICAgIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgICAvLyBJZiBhIHJlbW90ZSBjaGFuZ2UgaGFwcGVuZWQsIHdlIHRyeSB0byBjbGVhbnVwIHBvdGVudGlhbCBmb3JtYXR0aW5nIGR1cGxpY2F0ZXMuXG4gICAgaWYgKCF0cmFuc2FjdGlvbi5sb2NhbCkge1xuICAgICAgLy8gY2hlY2sgaWYgYW5vdGhlciBmb3JtYXR0aW5nIGl0ZW0gd2FzIGluc2VydGVkXG4gICAgICBsZXQgZm91bmRGb3JtYXR0aW5nSXRlbSA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBbY2xpZW50LCBhZnRlckNsb2NrXSBvZiB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBjbG9jayA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpIHx8IDA7XG4gICAgICAgIGlmIChhZnRlckNsb2NrID09PSBjbG9jaykge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaXRlcmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIC8qKiBAdHlwZSB7QXJyYXk8SXRlbXxHQz59ICovIChkb2Muc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSksIGNsb2NrLCBhZnRlckNsb2NrLCBpdGVtID0+IHtcbiAgICAgICAgICBpZiAoIWl0ZW0uZGVsZXRlZCAmJiAvKiogQHR5cGUge0l0ZW19ICovIChpdGVtKS5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KSB7XG4gICAgICAgICAgICBmb3VuZEZvcm1hdHRpbmdJdGVtID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZm91bmRGb3JtYXR0aW5nSXRlbSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZm91bmRGb3JtYXR0aW5nSXRlbSkge1xuICAgICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgaXRlbSA9PiB7XG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBHQyB8fCBmb3VuZEZvcm1hdHRpbmdJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZW0ucGFyZW50ID09PSB0aGlzICYmIGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgICAgICAgZm91bmRGb3JtYXR0aW5nSXRlbSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRyYW5zYWN0KGRvYywgKHQpID0+IHtcbiAgICAgICAgaWYgKGZvdW5kRm9ybWF0dGluZ0l0ZW0pIHtcbiAgICAgICAgICAvLyBJZiBhIGZvcm1hdHRpbmcgaXRlbSB3YXMgaW5zZXJ0ZWQsIHdlIHNpbXBseSBjbGVhbiB0aGUgd2hvbGUgdHlwZS5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbXB1dGUgY3VycmVudEF0dHJpYnV0ZXMgZm9yIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFueXdheS5cbiAgICAgICAgICBjbGVhbnVwWVRleHRGb3JtYXR0aW5nKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vIGZvcm1hdHRpbmcgYXR0cmlidXRlIHdhcyBpbnNlcnRlZCwgd2UgY2FuIG1ha2UgZHVlIHdpdGggY29udGV4dGxlc3NcbiAgICAgICAgICAvLyBmb3JtYXR0aW5nIGNsZWFudXBzLlxuICAgICAgICAgIC8vIENvbnRleHRsZXNzOiBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgY3VycmVudEF0dHJpYnV0ZXMgZm9yIHRoZSBhZmZlY3RlZCBwb3NpdGlvbi5cbiAgICAgICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModCwgdC5kZWxldGVTZXQsIGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBHQykge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICBjbGVhbnVwQ29udGV4dGxlc3NGb3JtYXR0aW5nR2FwKHQsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUgJiYgbi5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50U3RyaW5nKSB7XG4gICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0cjtcbiAgICAgIH1cbiAgICAgIG4gPSBuLnJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHtAbGluayBEZWx0YX0gb24gdGhpcyBzaGFyZWQgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGRlbHRhIFRoZSBjaGFuZ2VzIHRvIGFwcGx5IG9uIHRoaXMgZWxlbWVudC5cbiAgICogQHBhcmFtIHtvYmplY3R9ICBbb3B0c11cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zYW5pdGl6ZV0gU2FuaXRpemUgaW5wdXQgZGVsdGEuIFJlbW92ZXMgZW5kaW5nIG5ld2xpbmVzIGlmIHNldCB0byB0cnVlLlxuICAgKlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhcHBseURlbHRhIChkZWx0YSwgeyBzYW5pdGl6ZSA9IHRydWUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBjdXJyUG9zID0gbmV3IEl0ZW1UZXh0TGlzdFBvc2l0aW9uKG51bGwsIHRoaXMuX3N0YXJ0LCAwLCBuZXcgTWFwKCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb3AgPSBkZWx0YVtpXTtcbiAgICAgICAgICBpZiAob3AuaW5zZXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFF1aWxsIGFzc3VtZXMgdGhhdCB0aGUgY29udGVudCBzdGFydHMgd2l0aCBhbiBlbXB0eSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAvLyBZanMvWS5UZXh0IGFzc3VtZXMgdGhhdCBpdCBzdGFydHMgZW1wdHkuIFdlIGFsd2F5cyBoaWRlIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgbmV3bGluZSBhdCB0aGUgZW5kIG9mIHRoZSBjb250ZW50LlxuICAgICAgICAgICAgLy8gSWYgd2Ugb21pdCB0aGlzIHN0ZXAsIGNsaWVudHMgd2lsbCBzZWUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyBwYXJhZ3JhcGhzLCBidXQgbm90aGluZyBiYWQgd2lsbCBoYXBwZW4uXG4gICAgICAgICAgICBjb25zdCBpbnMgPSAoIXNhbml0aXplICYmIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmIGkgPT09IGRlbHRhLmxlbmd0aCAtIDEgJiYgY3VyclBvcy5yaWdodCA9PT0gbnVsbCAmJiBvcC5pbnNlcnQuc2xpY2UoLTEpID09PSAnXFxuJykgPyBvcC5pbnNlcnQuc2xpY2UoMCwgLTEpIDogb3AuaW5zZXJ0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnMgIT09ICdzdHJpbmcnIHx8IGlucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGluc2VydFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIGN1cnJQb3MsIGlucywgb3AuYXR0cmlidXRlcyB8fCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChvcC5yZXRhaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgY3VyclBvcywgb3AucmV0YWluLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wLmRlbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGVUZXh0KHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBvcC5kZWxldGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmFwcGx5RGVsdGEoZGVsdGEpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgRGVsdGEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1NuYXBzaG90fSBbc25hcHNob3RdXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtwcmV2U25hcHNob3RdXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgSUQpOmFueX0gW2NvbXB1dGVZQ2hhbmdlXVxuICAgKiBAcmV0dXJuIHthbnl9IFRoZSBEZWx0YSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRGVsdGEgKHNuYXBzaG90LCBwcmV2U25hcHNob3QsIGNvbXB1dGVZQ2hhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGV7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkb2MgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMuZG9jKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICBmdW5jdGlvbiBwYWNrU3RyICgpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYWNrIHN0ciB3aXRoIGF0dHJpYnV0ZXMgdG8gb3BzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBsZXQgYWRkQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgYWRkQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG9wID0geyBpbnNlcnQ6IHN0ciB9O1xuICAgICAgICBpZiAoYWRkQXR0cmlidXRlcykge1xuICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKG9wKTtcbiAgICAgICAgc3RyID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNuYXBzaG90cyBhcmUgbWVyZ2VkIGFnYWluIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgc28gd2UgbmVlZCB0byBrZWVwIHRoZVxuICAgIC8vIHRyYW5zYWxpdmUgdW50aWwgd2UgYXJlIGRvbmVcbiAgICB0cmFuc2FjdChkb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgIGlmIChzbmFwc2hvdCkge1xuICAgICAgICBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlNuYXBzaG90KSB7XG4gICAgICAgIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHModHJhbnNhY3Rpb24sIHByZXZTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKG4sIHNuYXBzaG90KSB8fCAocHJldlNuYXBzaG90ICE9PSB1bmRlZmluZWQgJiYgaXNWaXNpYmxlKG4sIHByZXZTbmFwc2hvdCkpKSB7XG4gICAgICAgICAgc3dpdGNoIChuLmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFN0cmluZzoge1xuICAgICAgICAgICAgICBjb25zdCBjdXIgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoJ3ljaGFuZ2UnKTtcbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ICE9PSB1bmRlZmluZWQgJiYgIWlzVmlzaWJsZShuLCBzbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyID09PSB1bmRlZmluZWQgfHwgY3VyLnVzZXIgIT09IG4uaWQuY2xpZW50IHx8IGN1ci5zdGF0ZSAhPT0gJ3JlbW92ZWQnKSB7XG4gICAgICAgICAgICAgICAgICBwYWNrU3RyKCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5zZXQoJ3ljaGFuZ2UnLCBjb21wdXRlWUNoYW5nZSA/IGNvbXB1dGVZQ2hhbmdlKCdyZW1vdmVkJywgbi5pZCkgOiB7IHR5cGU6ICdyZW1vdmVkJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlNuYXBzaG90ICE9PSB1bmRlZmluZWQgJiYgIWlzVmlzaWJsZShuLCBwcmV2U25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ciA9PT0gdW5kZWZpbmVkIHx8IGN1ci51c2VyICE9PSBuLmlkLmNsaWVudCB8fCBjdXIuc3RhdGUgIT09ICdhZGRlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ2FkZGVkJywgbi5pZCkgOiB7IHR5cGU6ICdhZGRlZCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZSgneWNoYW5nZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0cjtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQ29udGVudEVtYmVkOiB7XG4gICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBjb25zdCBvcCA9IHtcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IC8qKiBAdHlwZSB7Q29udGVudEVtYmVkfSAqLyAobi5jb250ZW50KS5lbWJlZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fSAqLyAoe30pO1xuICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICAgICAgICBpZiAoaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAobi5jb250ZW50KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgICB9XG4gICAgICBwYWNrU3RyKCk7XG4gICAgfSwgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyk7XG4gICAgcmV0dXJuIG9wc1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCB0ZXh0IGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgaW5zZXJ0aW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBpbnNlcnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gW2F0dHJpYnV0ZXNdIE9wdGlvbmFsbHkgZGVmaW5lIHNvbWUgZm9ybWF0dGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZSBpbnNlcnRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRleHQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydCAoaW5kZXgsIHRleHQsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvYztcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4KTtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBwb3MuY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodiwgaykgPT4geyBhdHRyaWJ1dGVzW2tdID0gdjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgcG9zLCB0ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5pbnNlcnQoaW5kZXgsIHRleHQsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhbiBlbWJlZCBhdCBhIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCB0aGUgZW1iZWQgYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbWJlZCBUaGUgT2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZW1iZWQuXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYmVkXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydEVtYmVkIChpbmRleCwgZW1iZWQsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIGlmIChlbWJlZC5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtYmVkIG11c3QgYmUgYW4gT2JqZWN0JylcbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgpO1xuICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIGVtYmVkLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5pbnNlcnRFbWJlZChpbmRleCwgZW1iZWQsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0ZXh0IHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgpLCBsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmRlbGV0ZShpbmRleCwgbGVuZ3RoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgcHJvcGVydGllcyB0byBhIHJhbmdlIG9mIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8uXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZvcm1hdCAoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCk7XG4gICAgICAgIGlmIChwb3MucmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBmb3JtYXRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIGxlbmd0aCwgYXR0cmlidXRlcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuZm9ybWF0KGluZGV4LCBsZW5ndGgsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqIEBwYXJhbSB7YW55fSBhdHRyaWJ1dGVWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIHRoYXQgYmVsb25ncyB0byB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpZGVudGlmaWVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgKiBAcmV0dXJuIHthbnl9IFRoZSBxdWVyaWVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZU1hcEdldCh0aGlzLCBhdHRyaWJ1dGVOYW1lKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBpbiBhIEpTT04gT2JqZWN0LlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3NuYXBzaG90XVxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBBIEpTT04gT2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzIChzbmFwc2hvdCkge1xuICAgIHJldHVybiB0eXBlTWFwR2V0QWxsKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZUVuY29kZXJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlUZXh0UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZURlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlUZXh0ID0gZGVjb2RlciA9PiBuZXcgWVRleHQoKTtcblxuLyoqXG4gKiBAbW9kdWxlIFlYbWxcbiAqL1xuXG4vKipcbiAqIERlZmluZSB0aGUgZWxlbWVudHMgdG8gd2hpY2ggYSBzZXQgb2YgQ1NTIHF1ZXJpZXMgYXBwbHkuXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19TZWxlY3RvcnN8Q1NTX1NlbGVjdG9yc31cbiAqXG4gKiBAZXhhbXBsZVxuICogICBxdWVyeSA9ICcuY2xhc3NTZWxlY3RvcidcbiAqICAgcXVlcnkgPSAnbm9kZVNlbGVjdG9yJ1xuICogICBxdWVyeSA9ICcjaWRTZWxlY3RvcidcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBDU1NfU2VsZWN0b3JcbiAqL1xuXG4vKipcbiAqIERvbSBmaWx0ZXIgZnVuY3Rpb24uXG4gKlxuICogQGNhbGxiYWNrIGRvbUZpbHRlclxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtNYXB9IGF0dHJpYnV0ZXMgVGhlIG1hcCBvZiBhdHRyaWJ1dGVzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0byBpbmNsdWRlIHRoZSBEb20gbm9kZSBpbiB0aGUgWVhtbEVsZW1lbnQuXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3Vic2V0IG9mIHRoZSBub2RlcyBvZiBhIFlYbWxFbGVtZW50IC8gWVhtbEZyYWdtZW50IGFuZCBhXG4gKiBwb3NpdGlvbiB3aXRoaW4gdGhlbS5cbiAqXG4gKiBDYW4gYmUgY3JlYXRlZCB3aXRoIHtAbGluayBZWG1sRnJhZ21lbnQjY3JlYXRlVHJlZVdhbGtlcn1cbiAqXG4gKiBAcHVibGljXG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEVsZW1lbnR8WVhtbEhvb2s+fVxuICovXG5jbGFzcyBZWG1sVHJlZVdhbGtlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxGcmFnbWVudCB8IFlYbWxFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQWJzdHJhY3RUeXBlPGFueT4pOmJvb2xlYW59IFtmXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb3QsIGYgPSAoKSA9PiB0cnVlKSB7XG4gICAgdGhpcy5fZmlsdGVyID0gZjtcbiAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbX1cbiAgICAgKi9cbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHJvb3QuX3N0YXJ0KTtcbiAgICB0aGlzLl9maXJzdENhbGwgPSB0cnVlO1xuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuZXh0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhdG9yUmVzdWx0PFlYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxIb29rPn0gVGhlIG5leHQgbm9kZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbmV4dCAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICBsZXQgbiA9IHRoaXMuX2N1cnJlbnROb2RlO1xuICAgIGxldCB0eXBlID0gLyoqIEB0eXBlIHthbnl9ICovIChuLmNvbnRlbnQpLnR5cGU7XG4gICAgaWYgKG4gIT09IG51bGwgJiYgKCF0aGlzLl9maXJzdENhbGwgfHwgbi5kZWxldGVkIHx8ICF0aGlzLl9maWx0ZXIodHlwZSkpKSB7IC8vIGlmIGZpcnN0IGNhbGwsIHdlIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlIGZpcnN0IGl0ZW1cbiAgICAgIGRvIHtcbiAgICAgICAgdHlwZSA9IC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlO1xuICAgICAgICBpZiAoIW4uZGVsZXRlZCAmJiAodHlwZS5jb25zdHJ1Y3RvciA9PT0gWVhtbEVsZW1lbnQgfHwgdHlwZS5jb25zdHJ1Y3RvciA9PT0gWVhtbEZyYWdtZW50KSAmJiB0eXBlLl9zdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHdhbGsgZG93biBpbiB0aGUgdHJlZVxuICAgICAgICAgIG4gPSB0eXBlLl9zdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3YWxrIHJpZ2h0IG9yIHVwIGluIHRoZSB0cmVlXG4gICAgICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChuLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG4gPSBuLnJpZ2h0O1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuLnBhcmVudCA9PT0gdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgICBuID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG4gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobi5wYXJlbnQpLl9pdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobiAhPT0gbnVsbCAmJiAobi5kZWxldGVkIHx8ICF0aGlzLl9maWx0ZXIoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkpKVxuICAgIH1cbiAgICB0aGlzLl9maXJzdENhbGwgPSBmYWxzZTtcbiAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gbjtcbiAgICByZXR1cm4geyB2YWx1ZTogLyoqIEB0eXBlIHthbnl9ICovIChuLmNvbnRlbnQpLnR5cGUsIGRvbmU6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsaXN0IG9mIHtAbGluayBZWG1sRWxlbWVudH0uYW5kIHtAbGluayBZWG1sVGV4dH0gdHlwZXMuXG4gKiBBIFl4bWxGcmFnbWVudCBpcyBzaW1pbGFyIHRvIGEge0BsaW5rIFlYbWxFbGVtZW50fSwgYnV0IGl0IGRvZXMgbm90IGhhdmUgYVxuICogbm9kZU5hbWUgYW5kIGl0IGRvZXMgbm90IGhhdmUgYXR0cmlidXRlcy4gVGhvdWdoIGl0IGNhbiBiZSBib3VuZCB0byBhIERPTVxuICogZWxlbWVudCAtIGluIHRoaXMgY2FzZSB0aGUgYXR0cmlidXRlcyBhbmQgdGhlIG5vZGVOYW1lIGFyZSBub3Qgc2hhcmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZWG1sRXZlbnQ+XG4gKi9cbmNsYXNzIFlYbWxGcmFnbWVudCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IGZpcnN0Q2hpbGQgKCkge1xuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5fZmlyc3Q7XG4gICAgcmV0dXJuIGZpcnN0ID8gZmlyc3QuY29udGVudC5nZXRDb250ZW50KClbMF0gOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKTtcbiAgICB0aGlzLmluc2VydCgwLCAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KSk7XG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sRnJhZ21lbnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sRnJhZ21lbnQoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWwuaW5zZXJ0KDAsIGVsLnRvQXJyYXkoKS5tYXAoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gaXRlbS5jbG9uZSgpIDogaXRlbSkpO1xuICAgIHJldHVybiBlbFxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWxpbUNvbnRlbnQgPT09IG51bGwgPyB0aGlzLl9sZW5ndGggOiB0aGlzLl9wcmVsaW1Db250ZW50Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN1YnRyZWUgb2YgY2hpbGROb2Rlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgd2Fsa2VyID0gZWxlbS5jcmVhdGVUcmVlV2Fsa2VyKGRvbSA9PiBkb20ubm9kZU5hbWUgPT09ICdkaXYnKVxuICAgKiBmb3IgKGxldCBub2RlIGluIHdhbGtlcikge1xuICAgKiAgIC8vIGBub2RlYCBpcyBhIGRpdiBub2RlXG4gICAqICAgbm9wKG5vZGUpXG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBYnN0cmFjdFR5cGU8YW55Pik6Ym9vbGVhbn0gZmlsdGVyIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggY2hpbGQgZWxlbWVudCBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2hpbGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJ0cmVlLlxuICAgKiBAcmV0dXJuIHtZWG1sVHJlZVdhbGtlcn0gQSBzdWJ0cmVlIGFuZCBhIHBvc2l0aW9uIHdpdGhpbiBpdC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlVHJlZVdhbGtlciAoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmaWx0ZXIpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgWVhtbEVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeS5cbiAgICogU2ltaWxhciB0byBET00ncyB7QGxpbmsgcXVlcnlTZWxlY3Rvcn0uXG4gICAqXG4gICAqIFF1ZXJ5IHN1cHBvcnQ6XG4gICAqICAgLSB0YWduYW1lXG4gICAqIFRPRE86XG4gICAqICAgLSBpZFxuICAgKiAgIC0gYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q1NTX1NlbGVjdG9yfSBxdWVyeSBUaGUgcXVlcnkgb24gdGhlIGNoaWxkcmVuLlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9va3xudWxsfSBUaGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5IG9yIG51bGwuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3IgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSk7XG4gICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBZWG1sRWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcXVlcnkuXG4gICAqIFNpbWlsYXIgdG8gRG9tJ3Mge0BsaW5rIHF1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKlxuICAgKiBAdG9kbyBEb2VzIG5vdCB5ZXQgc3VwcG9ydCBhbGwgcXVlcmllcy4gQ3VycmVudGx5IG9ubHkgcXVlcnkgYnkgdGFnTmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW5cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2t8bnVsbD59IFRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoaXMgcXVlcnkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3JBbGwgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZWxlbWVudCA9PiBlbGVtZW50Lm5vZGVOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gcXVlcnkpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWVhtbEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWVhtbEV2ZW50KHRoaXMsIHBhcmVudFN1YnMsIHRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGlzIFlYbWxGcmFnbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCBjaGlsZHJlbi5cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RNYXAodGhpcywgeG1sID0+IHhtbC50b1N0cmluZygpKS5qb2luKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbaG9va3M9e31dIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAqIEByZXR1cm4ge05vZGV9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MgPSB7fSwgYmluZGluZykge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihmcmFnbWVudCwgdGhpcyk7XG4gICAgfVxuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCB4bWxUeXBlID0+IHtcbiAgICAgIGZyYWdtZW50Lmluc2VydEJlZm9yZSh4bWxUeXBlLnRvRE9NKF9kb2N1bWVudCwgaG9va3MsIGJpbmRpbmcpLCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnJhZ21lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeG1sLmluc2VydCgwLCBbbmV3IFkuWG1sVGV4dCgndGV4dCcpXSlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgX3ByZWxpbUNvbnRlbnQgaXMgZGVmaW5lZCBiZWNhdXNlIHRoaXMgaXMgbm90IHlldCBpbnRlZ3JhdGVkXG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50LnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB4bWwuaW5zZXJ0KDAsIFtuZXcgWS5YbWxUZXh0KCd0ZXh0JyldKVxuICAgKlxuICAgKiBAcGFyYW0ge251bGx8SXRlbXxZWG1sRWxlbWVudHxZWG1sVGV4dH0gcmVmIFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIgKHJlZiwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcmVmSXRlbSA9IChyZWYgJiYgcmVmIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSA/IHJlZi5faXRlbSA6IHJlZjtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCB0aGlzLCByZWZJdGVtLCBjb250ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYyA9IC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpO1xuICAgICAgY29uc3QgaW5kZXggPSByZWYgPT09IG51bGwgPyAwIDogcGMuZmluZEluZGV4KGVsID0+IGVsID09PSByZWYpICsgMTtcbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiByZWYgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlJDEoJ1JlZmVyZW5jZSBpdGVtIG5vdCBmb3VuZCcpXG4gICAgICB9XG4gICAgICBwYy5zcGxpY2UoaW5kZXgsIDAsIC4uLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGVsZW1lbnRzIHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZyBlbGVtZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCA9IDEpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0RGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlIF9wcmVsaW1Db250ZW50IGlzIGRlZmluZWQgYmVjYXVzZSB0aGlzIGlzIG5vdCB5ZXQgaW50ZWdyYXRlZFxuICAgICAgdGhpcy5fcHJlbGltQ29udGVudC5zcGxpY2UoaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9vaz59XG4gICAqL1xuICB0b0FycmF5ICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RUb0FycmF5KHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIGFwcGVuZC5cbiAgICovXG4gIHB1c2ggKGNvbnRlbnQpIHtcbiAgICB0aGlzLmluc2VydCh0aGlzLmxlbmd0aCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gcHJlcHBlbmQuXG4gICAqL1xuICB1bnNoaWZ0IChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQoMCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaS10aCBlbGVtZW50IGZyb20gYSBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuIGZyb20gdGhlIFlBcnJheVxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dH1cbiAgICovXG4gIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RHZXQodGhpcywgaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59XG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0eXBlTGlzdFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZUVuY29kZXJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxGcmFnbWVudFJlZklEKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVhtbEZyYWdtZW50ID0gZGVjb2RlciA9PiBuZXcgWVhtbEZyYWdtZW50KCk7XG5cbi8qKlxuICogQW4gWVhtbEVsZW1lbnQgaW1pdGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGFcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH0uXG4gKlxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgYXR0cmlidXRlcyAoa2V5IHZhbHVlIHBhaXJzKVxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgY2hpbGRFbGVtZW50cyB0aGF0IG11c3QgaW5oZXJpdCBmcm9tIFlYbWxFbGVtZW50XG4gKi9cbmNsYXNzIFlYbWxFbGVtZW50IGV4dGVuZHMgWVhtbEZyYWdtZW50IHtcbiAgY29uc3RydWN0b3IgKG5vZGVOYW1lID0gJ1VOREVGSU5FRCcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgYW55PnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUF0dHJzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IG5leHRTaWJsaW5nICgpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faXRlbSA/IHRoaXMuX2l0ZW0ubmV4dCA6IG51bGw7XG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgcHJldlNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5wcmV2IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pXG4gICAgOygvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1BdHRycykpLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHRoaXMuX3ByZWxpbUF0dHJzID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEl0ZW0gd2l0aCB0aGUgc2FtZSBlZmZlY3QgYXMgdGhpcyBJdGVtICh3aXRob3V0IHBvc2l0aW9uIGVmZmVjdClcbiAgICpcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR9XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sRWxlbWVudCh0aGlzLm5vZGVOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IGVsID0gbmV3IFlYbWxFbGVtZW50KHRoaXMubm9kZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWwuaW5zZXJ0KDAsIGVsLnRvQXJyYXkoKS5tYXAoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gaXRlbS5jbG9uZSgpIDogaXRlbSkpO1xuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFhNTCBzZXJpYWxpemF0aW9uIG9mIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqIFRoZSBhdHRyaWJ1dGVzIGFyZSBvcmRlcmVkIGJ5IGF0dHJpYnV0ZS1uYW1lLCBzbyB5b3UgY2FuIGVhc2lseSB1c2UgdGhpc1xuICAgKiBtZXRob2QgdG8gY29tcGFyZSBZWG1sRWxlbWVudHNcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgY29uc3Qgc3RyaW5nQnVpbGRlciA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMuc29ydCgpO1xuICAgIGNvbnN0IGtleXNMZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNMZW47IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChrZXkgKyAnPVwiJyArIGF0dHJzW2tleV0gKyAnXCInKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZU5hbWUgPSB0aGlzLm5vZGVOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgYXR0cnNTdHJpbmcgPSBzdHJpbmdCdWlsZGVyLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJpbmdCdWlsZGVyLmpvaW4oJyAnKSA6ICcnO1xuICAgIHJldHVybiBgPCR7bm9kZU5hbWV9JHthdHRyc1N0cmluZ30+JHtzdXBlci50b1N0cmluZygpfTwvJHtub2RlTmFtZX0+YFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKS5kZWxldGUoYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZVZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1BdHRycykuc2V0KGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBiZWxvbmdzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaWRlbnRpZmllcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllZCB2YWx1ZS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcXVlcmllZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgaW4gYSBKU09OIE9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3NuYXBzaG90XVxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBBIEpTT04gT2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzIChzbmFwc2hvdCkge1xuICAgIHJldHVybiB0eXBlTWFwR2V0QWxsKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZG9tID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZSk7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgIH1cbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgeXhtbCA9PiB7XG4gICAgICBkb20uYXBwZW5kQ2hpbGQoeXhtbC50b0RPTShfZG9jdW1lbnQsIGhvb2tzLCBiaW5kaW5nKSk7XG4gICAgfSk7XG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sRWxlbWVudFJlZklEKTtcbiAgICBlbmNvZGVyLndyaXRlS2V5KHRoaXMubm9kZU5hbWUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZURlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVhtbEVsZW1lbnQgPSBkZWNvZGVyID0+IG5ldyBZWG1sRWxlbWVudChkZWNvZGVyLnJlYWRLZXkoKSk7XG5cbi8qKlxuICogQW4gRXZlbnQgdGhhdCBkZXNjcmliZXMgY2hhbmdlcyBvbiBhIFlYbWwgRWxlbWVudCBvciBZeG1sIEZyYWdtZW50XG4gKi9cbmNsYXNzIFlYbWxFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxGcmFnbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgb24gd2hpY2ggdGhlIGV2ZW50IGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7U2V0PHN0cmluZ3xudWxsPn0gc3VicyBUaGUgc2V0IG9mIGNoYW5nZWQgYXR0cmlidXRlcy4gYG51bGxgIGlzIGluY2x1ZGVkIGlmIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICBjaGlsZCBsaXN0IGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoIHdpY2ggdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHN1YnMsIHRyYW5zYWN0aW9uKSB7XG4gICAgc3VwZXIodGFyZ2V0LCB0cmFuc2FjdGlvbik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkID0gbmV3IFNldCgpO1xuICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkLmFkZChzdWIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogWW91IGNhbiBtYW5hZ2UgYmluZGluZyB0byBhIGN1c3RvbSB0eXBlIHdpdGggWVhtbEhvb2suXG4gKlxuICogQGV4dGVuZHMge1lNYXA8YW55Pn1cbiAqL1xuY2xhc3MgWVhtbEhvb2sgZXh0ZW5kcyBZTWFwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob29rTmFtZSBub2RlTmFtZSBvZiB0aGUgRG9tIE5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaG9va05hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5ob29rTmFtZSA9IGhvb2tOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEhvb2sodGhpcy5ob29rTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZWG1sSG9va31cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sSG9vayh0aGlzLmhvb2tOYW1lKTtcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGVsLnNldChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzID0ge30sIGJpbmRpbmcpIHtcbiAgICBjb25zdCBob29rID0gaG9va3NbdGhpcy5ob29rTmFtZV07XG4gICAgbGV0IGRvbTtcbiAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb20gPSBob29rLmNyZWF0ZURvbSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmhvb2tOYW1lKTtcbiAgICB9XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycsIHRoaXMuaG9va05hbWUpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRW5jb2Rlcn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEhvb2tSZWZJRCk7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmhvb2tOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sSG9va31cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sSG9vayA9IGRlY29kZXIgPT5cbiAgbmV3IFlYbWxIb29rKGRlY29kZXIucmVhZEtleSgpKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHQgaW4gYSBEb20gRWxlbWVudC4gSW4gdGhlIGZ1dHVyZSB0aGlzIHR5cGUgd2lsbCBhbHNvIGhhbmRsZVxuICogc2ltcGxlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gbGlrZSBib2xkIGFuZCBpdGFsaWMuXG4gKi9cbmNsYXNzIFlYbWxUZXh0IGV4dGVuZHMgWVRleHQge1xuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgbmV4dFNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5uZXh0IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbFRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVhtbFRleHQoKTtcbiAgICB0ZXh0LmFwcGx5RGVsdGEodGhpcy50b0RlbHRhKCkpO1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxUZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7VGV4dH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcywgYmluZGluZykge1xuICAgIGNvbnN0IGRvbSA9IF9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMudG9EZWx0YSgpLm1hcChkZWx0YSA9PiB7XG4gICAgICBjb25zdCBuZXN0ZWROb2RlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBub2RlTmFtZSBpbiBkZWx0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgYXR0cnMucHVzaCh7IGtleSwgdmFsdWU6IGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdW2tleV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29ydCBhdHRyaWJ1dGVzIHRvIGdldCBhIHVuaXF1ZSBvcmRlclxuICAgICAgICBhdHRycy5zb3J0KChhLCBiKSA9PiBhLmtleSA8IGIua2V5ID8gLTEgOiAxKTtcbiAgICAgICAgbmVzdGVkTm9kZXMucHVzaCh7IG5vZGVOYW1lLCBhdHRycyB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHNvcnQgbm9kZSBvcmRlciB0byBnZXQgYSB1bmlxdWUgb3JkZXJcbiAgICAgIG5lc3RlZE5vZGVzLnNvcnQoKGEsIGIpID0+IGEubm9kZU5hbWUgPCBiLm5vZGVOYW1lID8gLTEgOiAxKTtcbiAgICAgIC8vIG5vdyBjb252ZXJ0IHRvIGRvbSBzdHJpbmdcbiAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVzdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5lc3RlZE5vZGVzW2ldO1xuICAgICAgICBzdHIgKz0gYDwke25vZGUubm9kZU5hbWV9YDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgYXR0ciA9IG5vZGUuYXR0cnNbal07XG4gICAgICAgICAgc3RyICs9IGAgJHthdHRyLmtleX09XCIke2F0dHIudmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSAnPic7XG4gICAgICB9XG4gICAgICBzdHIgKz0gZGVsdGEuaW5zZXJ0O1xuICAgICAgZm9yIChsZXQgaSA9IG5lc3RlZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0ciArPSBgPC8ke25lc3RlZE5vZGVzW2ldLm5vZGVOYW1lfT5gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clxuICAgIH0pLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZUVuY29kZXJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxUZXh0UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZURlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxUZXh0ID0gZGVjb2RlciA9PiBuZXcgWVhtbFRleHQoKTtcblxuY2xhc3MgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZW5ndGgpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdGhpcyBzdHJ1Y3Qgd2l0aCB0aGUgaXRlbSB0byB0aGUgcmlnaHQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGFscmVhZHkgYXNzdW1pbmcgdGhhdCBgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoID09PSB0aGlzLmlkLmNsb2NrYC5cbiAgICogQWxzbyB0aGlzIG1ldGhvZCBkb2VzICpub3QqIHJlbW92ZSByaWdodCBmcm9tIFN0cnVjdFN0b3JlIVxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3ZXRoZXIgdGhpcyBtZXJnZWQgd2l0aCByaWdodFxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuY29kaW5nUmVmXG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0LCBlbmNvZGluZ1JlZikge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG59XG5cbmNvbnN0IHN0cnVjdEdDUmVmTnVtYmVyID0gMDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBHQyBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBkZWxldGUgKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtHQ30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLmxlbmd0aCArPSByaWdodC5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgdGhpcy5pZC5jbG9jayArPSBvZmZzZXQ7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBvZmZzZXQ7XG4gICAgfVxuICAgIGFkZFN0cnVjdCh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhzdHJ1Y3RHQ1JlZk51bWJlcik7XG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbmd0aCAtIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuY2xhc3MgQ29udGVudEJpbmFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb250ZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy5jb250ZW50XVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50QmluYXJ5fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50QmluYXJ5KHRoaXMuY29udGVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEJpbmFyeX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRW5jb2Rlcn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUJ1Zih0aGlzLmNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDNcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50QmluYXJ5fVxuICovXG5jb25zdCByZWFkQ29udGVudEJpbmFyeSA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRCaW5hcnkoZGVjb2Rlci5yZWFkQnVmKCkpO1xuXG5jbGFzcyBDb250ZW50RGVsZXRlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVuKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW4pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW4gLSBvZmZzZXQpO1xuICAgIHRoaXMubGVuID0gb2Zmc2V0O1xuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudERlbGV0ZWR9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5sZW4gKz0gcmlnaHQubGVuO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgYWRkVG9EZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpdGVtLmlkLmNsaWVudCwgaXRlbS5pZC5jbG9jaywgdGhpcy5sZW4pO1xuICAgIGl0ZW0ubWFya0RlbGV0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRW5jb2Rlcn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbiAtIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50RGVsZXRlZCA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnREZWxldGVkKGRlY29kZXIucmVhZExlbigpKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50RG9jIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MpIHtcbiAgICBpZiAoZG9jLl9pdGVtKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUaGlzIGRvY3VtZW50IHdhcyBhbHJlYWR5IGludGVncmF0ZWQgYXMgYSBzdWItZG9jdW1lbnQuIFlvdSBzaG91bGQgY3JlYXRlIGEgc2Vjb25kIGluc3RhbmNlIGluc3RlYWQgd2l0aCB0aGUgc2FtZSBndWlkLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RG9jfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgaWYgKCFkb2MuZ2MpIHtcbiAgICAgIG9wdHMuZ2MgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRvYy5hdXRvTG9hZCkge1xuICAgICAgb3B0cy5hdXRvTG9hZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkb2MubWV0YSAhPT0gbnVsbCkge1xuICAgICAgb3B0cy5tZXRhID0gZG9jLm1ldGE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmRvY11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudERvY31cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudERvYyh0aGlzLmRvYylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudERvY30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICAvLyB0aGlzIG5lZWRzIHRvIGJlIHJlZmxlY3RlZCBpbiBkb2MuZGVzdHJveSBhcyB3ZWxsXG4gICAgdGhpcy5kb2MuX2l0ZW0gPSBpdGVtO1xuICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5hZGQodGhpcy5kb2MpO1xuICAgIGlmICh0aGlzLmRvYy5zaG91bGRMb2FkKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzTG9hZGVkLmFkZCh0aGlzLmRvYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5oYXModGhpcy5kb2MpKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuZGVsZXRlKHRoaXMuZG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuYWRkKHRoaXMuZG9jKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkgeyB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHRoaXMuZG9jLmd1aWQpO1xuICAgIGVuY29kZXIud3JpdGVBbnkodGhpcy5vcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA5XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICovXG5jb25zdCByZWFkQ29udGVudERvYyA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnREb2MobmV3IERvYyh7IGd1aWQ6IGRlY29kZXIucmVhZFN0cmluZygpLCAuLi5kZWNvZGVyLnJlYWRBbnkoKSB9KSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudEVtYmVkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbWJlZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVtYmVkKSB7XG4gICAgdGhpcy5lbWJlZCA9IGVtYmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmVtYmVkXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRFbWJlZCh0aGlzLmVtYmVkKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEVtYmVkfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBtZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRFbWJlZH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRW5jb2Rlcn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUpTT04odGhpcy5lbWJlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gNVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEVtYmVkfVxuICovXG5jb25zdCByZWFkQ29udGVudEVtYmVkID0gZGVjb2RlciA9PiBuZXcgQ29udGVudEVtYmVkKGRlY29kZXIucmVhZEpTT04oKSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudEZvcm1hdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRGb3JtYXR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRGb3JtYXQodGhpcy5rZXksIHRoaXMudmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBtZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRGb3JtYXR9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgLy8gQHRvZG8gc2VhcmNobWFya2VyIGFyZSBjdXJyZW50bHkgdW5zdXBwb3J0ZWQgZm9yIHJpY2ggdGV4dCBkb2N1bWVudHNcbiAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpLl9zZWFyY2hNYXJrZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlS2V5KHRoaXMua2V5KTtcbiAgICBlbmNvZGVyLndyaXRlSlNPTih0aGlzLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA2XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEZvcm1hdH1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRGb3JtYXQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50Rm9ybWF0KGRlY29kZXIucmVhZFN0cmluZygpLCBkZWNvZGVyLnJlYWRKU09OKCkpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRKU09OIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXJyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSBhcnI7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmFyclxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEpTT04odGhpcy5hcnIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudEpTT04odGhpcy5hcnIuc2xpY2Uob2Zmc2V0KSk7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5zbGljZSgwLCBvZmZzZXQpO1xuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEpTT059IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5jb25jYXQocmlnaHQuYXJyKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmFyci5sZW5ndGg7XG4gICAgZW5jb2Rlci53cml0ZUxlbihsZW4gLSBvZmZzZXQpO1xuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuYXJyW2ldO1xuICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhjID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gMlxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEpTT059XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50SlNPTiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgY29uc3QgY3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGMgPSBkZWNvZGVyLnJlYWRTdHJpbmcoKTtcbiAgICBpZiAoYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3MucHVzaChKU09OLnBhcnNlKGMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBDb250ZW50SlNPTihjcylcbn07XG5cbmNsYXNzIENvbnRlbnRBbnkge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChhcnIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRBbnl9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRBbnkodGhpcy5hcnIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50QW55KHRoaXMuYXJyLnNsaWNlKG9mZnNldCkpO1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRBbnl9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5jb25jYXQocmlnaHQuYXJyKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmFyci5sZW5ndGg7XG4gICAgZW5jb2Rlci53cml0ZUxlbihsZW4gLSBvZmZzZXQpO1xuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuYXJyW2ldO1xuICAgICAgZW5jb2Rlci53cml0ZUFueShjKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gOFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZURlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRBbnl9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50QW55ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpO1xuICBjb25zdCBjcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY3MucHVzaChkZWNvZGVyLnJlYWRBbnkoKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBDb250ZW50QW55KGNzKVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50U3RyaW5nIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdHIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3RyID0gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHIuc3BsaXQoJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRTdHJpbmd9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRTdHJpbmcodGhpcy5zdHIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50U3RyaW5nfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50U3RyaW5nKHRoaXMuc3RyLnNsaWNlKG9mZnNldCkpO1xuICAgIHRoaXMuc3RyID0gdGhpcy5zdHIuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICAgIC8vIFByZXZlbnQgZW5jb2RpbmcgaW52YWxpZCBkb2N1bWVudHMgYmVjYXVzZSBvZiBzcGxpdHRpbmcgb2Ygc3Vycm9nYXRlIHBhaXJzOiBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9pc3N1ZXMvMjQ4XG4gICAgY29uc3QgZmlyc3RDaGFyQ29kZSA9IHRoaXMuc3RyLmNoYXJDb2RlQXQob2Zmc2V0IC0gMSk7XG4gICAgaWYgKGZpcnN0Q2hhckNvZGUgPj0gMHhEODAwICYmIGZpcnN0Q2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICAvLyBMYXN0IGNoYXJhY3RlciBvZiB0aGUgbGVmdCBzcGxpdCBpcyB0aGUgc3RhcnQgb2YgYSBzdXJyb2dhdGUgdXRmMTYvdWNzMiBwYWlyLlxuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBzcGxpdHRpbmcgb2Ygc3Vycm9nYXRlIHBhaXJzIGJlY2F1c2UgdGhpcyBtYXkgbGVhZCB0byBpbnZhbGlkIGRvY3VtZW50cy5cbiAgICAgIC8vIFJlcGxhY2UgdGhlIGludmFsaWQgY2hhcmFjdGVyIHdpdGggYSB1bmljb2RlIHJlcGxhY2VtZW50IGNoYXJhY3RlciAo77+9IC8gVStGRkZEKVxuICAgICAgdGhpcy5zdHIgPSB0aGlzLnN0ci5zbGljZSgwLCBvZmZzZXQgLSAxKSArICfvv70nO1xuICAgICAgLy8gcmVwbGFjZSByaWdodCBhcyB3ZWxsXG4gICAgICByaWdodC5zdHIgPSAn77+9JyArIHJpZ2h0LnN0ci5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50U3RyaW5nfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuc3RyICs9IHJpZ2h0LnN0cjtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlU3RyaW5nKG9mZnNldCA9PT0gMCA/IHRoaXMuc3RyIDogdGhpcy5zdHIuc2xpY2Uob2Zmc2V0KSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gNFxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRTdHJpbmcgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50U3RyaW5nKGRlY29kZXIucmVhZFN0cmluZygpKTtcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oQWJzdHJhY3RVcGRhdGVEZWNvZGVyKTpBYnN0cmFjdFR5cGU8YW55Pj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0eXBlUmVmcyA9IFtcbiAgcmVhZFlBcnJheSxcbiAgcmVhZFlNYXAsXG4gIHJlYWRZVGV4dCxcbiAgcmVhZFlYbWxFbGVtZW50LFxuICByZWFkWVhtbEZyYWdtZW50LFxuICByZWFkWVhtbEhvb2ssXG4gIHJlYWRZWG1sVGV4dFxuXTtcblxuY29uc3QgWUFycmF5UmVmSUQgPSAwO1xuY29uc3QgWU1hcFJlZklEID0gMTtcbmNvbnN0IFlUZXh0UmVmSUQgPSAyO1xuY29uc3QgWVhtbEVsZW1lbnRSZWZJRCA9IDM7XG5jb25zdCBZWG1sRnJhZ21lbnRSZWZJRCA9IDQ7XG5jb25zdCBZWG1sSG9va1JlZklEID0gNTtcbmNvbnN0IFlYbWxUZXh0UmVmSUQgPSA2O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRUeXBlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPFlFdmVudD59IHR5cGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMudHlwZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudFR5cGV9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRUeXBlKHRoaXMudHlwZS5fY29weSgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudFR5cGV9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IG1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudFR5cGV9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgdGhpcy50eXBlLl9pbnRlZ3JhdGUodHJhbnNhY3Rpb24uZG9jLCBpdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge1xuICAgIGxldCBpdGVtID0gdGhpcy50eXBlLl9zdGFydDtcbiAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hpcyB3aWxsIGJlIGdjJ2QgbGF0ZXIgYW5kIHdlIHdhbnQgdG8gbWVyZ2UgaXQgaWYgcG9zc2libGVcbiAgICAgICAgLy8gV2UgdHJ5IHRvIG1lcmdlIGFsbCBkZWxldGVkIGl0ZW1zIGFmdGVyIGVhY2ggdHJhbnNhY3Rpb24sXG4gICAgICAgIC8vIGJ1dCB3ZSBoYXZlIG5vIGtub3dsZWRnZSBhYm91dCB0aGF0IHRoaXMgbmVlZHMgdG8gYmUgbWVyZ2VkXG4gICAgICAgIC8vIHNpbmNlIGl0IGlzIG5vdCBpbiB0cmFuc2FjdGlvbi5kcy4gSGVuY2Ugd2UgYWRkIGl0IHRvIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHNcbiAgICAgICAgdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgICAgaXRlbSA9IGl0ZW0ucmlnaHQ7XG4gICAgfVxuICAgIHRoaXMudHlwZS5fbWFwLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzYW1lIGFzIGFib3ZlXG4gICAgICAgIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmRlbGV0ZSh0aGlzLnR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHtcbiAgICBsZXQgaXRlbSA9IHRoaXMudHlwZS5fc3RhcnQ7XG4gICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIGl0ZW0uZ2Moc3RvcmUsIHRydWUpO1xuICAgICAgaXRlbSA9IGl0ZW0ucmlnaHQ7XG4gICAgfVxuICAgIHRoaXMudHlwZS5fc3RhcnQgPSBudWxsO1xuICAgIHRoaXMudHlwZS5fbWFwLmZvckVhY2goLyoqIEBwYXJhbSB7SXRlbSB8IG51bGx9IGl0ZW0gKi8gKGl0ZW0pID0+IHtcbiAgICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZW0uZ2Moc3RvcmUsIHRydWUpO1xuICAgICAgICBpdGVtID0gaXRlbS5sZWZ0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudHlwZS5fbWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RVcGRhdGVFbmNvZGVyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICB0aGlzLnR5cGUuX3dyaXRlKGVuY29kZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDdcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZURlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICovXG5jb25zdCByZWFkQ29udGVudFR5cGUgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50VHlwZSh0eXBlUmVmc1tkZWNvZGVyLnJlYWRUeXBlUmVmKCldKGRlY29kZXIpKTtcblxuLyoqXG4gKiBAdG9kbyBUaGlzIHNob3VsZCByZXR1cm4gc2V2ZXJhbCBpdGVtc1xuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7e2l0ZW06SXRlbSwgZGlmZjpudW1iZXJ9fVxuICovXG5jb25zdCBmb2xsb3dSZWRvbmUgPSAoc3RvcmUsIGlkKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7SUR8bnVsbH1cbiAgICovXG4gIGxldCBuZXh0SUQgPSBpZDtcbiAgbGV0IGRpZmYgPSAwO1xuICBsZXQgaXRlbTtcbiAgZG8ge1xuICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgbmV4dElEID0gY3JlYXRlSUQobmV4dElELmNsaWVudCwgbmV4dElELmNsb2NrICsgZGlmZik7XG4gICAgfVxuICAgIGl0ZW0gPSBnZXRJdGVtKHN0b3JlLCBuZXh0SUQpO1xuICAgIGRpZmYgPSBuZXh0SUQuY2xvY2sgLSBpdGVtLmlkLmNsb2NrO1xuICAgIG5leHRJRCA9IGl0ZW0ucmVkb25lO1xuICB9IHdoaWxlIChuZXh0SUQgIT09IG51bGwgJiYgaXRlbSBpbnN0YW5jZW9mIEl0ZW0pXG4gIHJldHVybiB7XG4gICAgaXRlbSwgZGlmZlxuICB9XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGF0IG5laXRoZXIgaXRlbSBub3IgYW55IG9mIGl0cyBwYXJlbnRzIGlzIGV2ZXIgZGVsZXRlZC5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGRvZXMgbm90IHBlcnNpc3Qgd2hlbiBzdG9yaW5nIGl0IGludG8gYSBkYXRhYmFzZSBvciB3aGVuXG4gKiBzZW5kaW5nIGl0IHRvIG90aGVyIHBlZXJzXG4gKlxuICogQHBhcmFtIHtJdGVtfG51bGx9IGl0ZW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFxuICovXG5jb25zdCBrZWVwSXRlbSA9IChpdGVtLCBrZWVwKSA9PiB7XG4gIHdoaWxlIChpdGVtICE9PSBudWxsICYmIGl0ZW0ua2VlcCAhPT0ga2VlcCkge1xuICAgIGl0ZW0ua2VlcCA9IGtlZXA7XG4gICAgaXRlbSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX2l0ZW07XG4gIH1cbn07XG5cbi8qKlxuICogU3BsaXQgbGVmdEl0ZW0gaW50byB0d28gaXRlbXNcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW19IGxlZnRJdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gZGlmZlxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNwbGl0SXRlbSA9ICh0cmFuc2FjdGlvbiwgbGVmdEl0ZW0sIGRpZmYpID0+IHtcbiAgLy8gY3JlYXRlIHJpZ2h0SXRlbVxuICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnRJdGVtLmlkO1xuICBjb25zdCByaWdodEl0ZW0gPSBuZXcgSXRlbShcbiAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksXG4gICAgbGVmdEl0ZW0sXG4gICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYgLSAxKSxcbiAgICBsZWZ0SXRlbS5yaWdodCxcbiAgICBsZWZ0SXRlbS5yaWdodE9yaWdpbixcbiAgICBsZWZ0SXRlbS5wYXJlbnQsXG4gICAgbGVmdEl0ZW0ucGFyZW50U3ViLFxuICAgIGxlZnRJdGVtLmNvbnRlbnQuc3BsaWNlKGRpZmYpXG4gICk7XG4gIGlmIChsZWZ0SXRlbS5kZWxldGVkKSB7XG4gICAgcmlnaHRJdGVtLm1hcmtEZWxldGVkKCk7XG4gIH1cbiAgaWYgKGxlZnRJdGVtLmtlZXApIHtcbiAgICByaWdodEl0ZW0ua2VlcCA9IHRydWU7XG4gIH1cbiAgaWYgKGxlZnRJdGVtLnJlZG9uZSAhPT0gbnVsbCkge1xuICAgIHJpZ2h0SXRlbS5yZWRvbmUgPSBjcmVhdGVJRChsZWZ0SXRlbS5yZWRvbmUuY2xpZW50LCBsZWZ0SXRlbS5yZWRvbmUuY2xvY2sgKyBkaWZmKTtcbiAgfVxuICAvLyB1cGRhdGUgbGVmdCAoZG8gbm90IHNldCBsZWZ0SXRlbS5yaWdodE9yaWdpbiBhcyBpdCB3aWxsIGxlYWQgdG8gcHJvYmxlbXMgd2hlbiBzeW5jaW5nKVxuICBsZWZ0SXRlbS5yaWdodCA9IHJpZ2h0SXRlbTtcbiAgLy8gdXBkYXRlIHJpZ2h0XG4gIGlmIChyaWdodEl0ZW0ucmlnaHQgIT09IG51bGwpIHtcbiAgICByaWdodEl0ZW0ucmlnaHQubGVmdCA9IHJpZ2h0SXRlbTtcbiAgfVxuICAvLyByaWdodCBpcyBtb3JlIHNwZWNpZmljLlxuICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2gocmlnaHRJdGVtKTtcbiAgLy8gdXBkYXRlIHBhcmVudC5fbWFwXG4gIGlmIChyaWdodEl0ZW0ucGFyZW50U3ViICE9PSBudWxsICYmIHJpZ2h0SXRlbS5yaWdodCA9PT0gbnVsbCkge1xuICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodEl0ZW0ucGFyZW50KS5fbWFwLnNldChyaWdodEl0ZW0ucGFyZW50U3ViLCByaWdodEl0ZW0pO1xuICB9XG4gIGxlZnRJdGVtLmxlbmd0aCA9IGRpZmY7XG4gIHJldHVybiByaWdodEl0ZW1cbn07XG5cbi8qKlxuICogUmVkb2VzIHRoZSBlZmZlY3Qgb2YgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIFlqcyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtTZXQ8SXRlbT59IHJlZG9pdGVtc1xuICpcbiAqIEByZXR1cm4ge0l0ZW18bnVsbH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCByZWRvSXRlbSA9ICh0cmFuc2FjdGlvbiwgaXRlbSwgcmVkb2l0ZW1zKSA9PiB7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gIGNvbnN0IG93bkNsaWVudElEID0gZG9jLmNsaWVudElEO1xuICBjb25zdCByZWRvbmUgPSBpdGVtLnJlZG9uZTtcbiAgaWYgKHJlZG9uZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcmVkb25lKVxuICB9XG4gIGxldCBwYXJlbnRJdGVtID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KS5faXRlbTtcbiAgLyoqXG4gICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAqL1xuICBsZXQgbGVmdDtcbiAgLyoqXG4gICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAqL1xuICBsZXQgcmlnaHQ7XG4gIGlmIChpdGVtLnBhcmVudFN1YiA9PT0gbnVsbCkge1xuICAgIC8vIElzIGFuIGFycmF5IGl0ZW0uIEluc2VydCBhdCB0aGUgb2xkIHBvc2l0aW9uXG4gICAgbGVmdCA9IGl0ZW0ubGVmdDtcbiAgICByaWdodCA9IGl0ZW07XG4gIH0gZWxzZSB7XG4gICAgLy8gSXMgYSBtYXAgaXRlbS4gSW5zZXJ0IGFzIGN1cnJlbnQgdmFsdWVcbiAgICBsZWZ0ID0gaXRlbTtcbiAgICB3aGlsZSAobGVmdC5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgbGVmdCA9IGxlZnQucmlnaHQ7XG4gICAgICBpZiAobGVmdC5pZC5jbGllbnQgIT09IG93bkNsaWVudElEKSB7XG4gICAgICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byByZWRvIHRoaXMgaXRlbSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aXRoIGFcbiAgICAgICAgLy8gY2hhbmdlIGZyb20gYW5vdGhlciBjbGllbnRcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnQucmlnaHQgIT09IG51bGwpIHtcbiAgICAgIGxlZnQgPSAvKiogQHR5cGUge0l0ZW19ICovICgvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpLl9tYXAuZ2V0KGl0ZW0ucGFyZW50U3ViKSk7XG4gICAgfVxuICAgIHJpZ2h0ID0gbnVsbDtcbiAgfVxuICAvLyBtYWtlIHN1cmUgdGhhdCBwYXJlbnQgaXMgcmVkb25lXG4gIGlmIChwYXJlbnRJdGVtICE9PSBudWxsICYmIHBhcmVudEl0ZW0uZGVsZXRlZCA9PT0gdHJ1ZSAmJiBwYXJlbnRJdGVtLnJlZG9uZSA9PT0gbnVsbCkge1xuICAgIC8vIHRyeSB0byB1bmRvIHBhcmVudCBpZiBpdCB3aWxsIGJlIHVuZG9uZSBhbnl3YXlcbiAgICBpZiAoIXJlZG9pdGVtcy5oYXMocGFyZW50SXRlbSkgfHwgcmVkb0l0ZW0odHJhbnNhY3Rpb24sIHBhcmVudEl0ZW0sIHJlZG9pdGVtcykgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIGlmIChwYXJlbnRJdGVtICE9PSBudWxsICYmIHBhcmVudEl0ZW0ucmVkb25lICE9PSBudWxsKSB7XG4gICAgd2hpbGUgKHBhcmVudEl0ZW0ucmVkb25lICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnRJdGVtID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHBhcmVudEl0ZW0ucmVkb25lKTtcbiAgICB9XG4gICAgLy8gZmluZCBuZXh0IGNsb25lZF9yZWRvIGl0ZW1zXG4gICAgd2hpbGUgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IGxlZnRUcmFjZSA9IGxlZnQ7XG4gICAgICAvLyB0cmFjZSByZWRvbmUgdW50aWwgcGFyZW50IG1hdGNoZXNcbiAgICAgIHdoaWxlIChsZWZ0VHJhY2UgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGxlZnRUcmFjZS5wYXJlbnQpLl9pdGVtICE9PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIGxlZnRUcmFjZSA9IGxlZnRUcmFjZS5yZWRvbmUgPT09IG51bGwgPyBudWxsIDogZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGxlZnRUcmFjZS5yZWRvbmUpO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobGVmdFRyYWNlLnBhcmVudCkuX2l0ZW0gPT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgbGVmdCA9IGxlZnRUcmFjZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBsZWZ0LmxlZnQ7XG4gICAgfVxuICAgIHdoaWxlIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgcmlnaHRUcmFjZSA9IHJpZ2h0O1xuICAgICAgLy8gdHJhY2UgcmVkb25lIHVudGlsIHBhcmVudCBtYXRjaGVzXG4gICAgICB3aGlsZSAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtICE9PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0VHJhY2UgPSByaWdodFRyYWNlLnJlZG9uZSA9PT0gbnVsbCA/IG51bGwgOiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcmlnaHRUcmFjZS5yZWRvbmUpO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0VHJhY2UgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0VHJhY2UucGFyZW50KS5faXRlbSA9PT0gcGFyZW50SXRlbSkge1xuICAgICAgICByaWdodCA9IHJpZ2h0VHJhY2U7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICByaWdodCA9IHJpZ2h0LnJpZ2h0O1xuICAgIH1cbiAgfVxuICBjb25zdCBuZXh0Q2xvY2sgPSBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SUQpO1xuICBjb25zdCBuZXh0SWQgPSBjcmVhdGVJRChvd25DbGllbnRJRCwgbmV4dENsb2NrKTtcbiAgY29uc3QgcmVkb25lSXRlbSA9IG5ldyBJdGVtKFxuICAgIG5leHRJZCxcbiAgICBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLFxuICAgIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCxcbiAgICBwYXJlbnRJdGVtID09PSBudWxsID8gaXRlbS5wYXJlbnQgOiAvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAocGFyZW50SXRlbS5jb250ZW50KS50eXBlLFxuICAgIGl0ZW0ucGFyZW50U3ViLFxuICAgIGl0ZW0uY29udGVudC5jb3B5KClcbiAgKTtcbiAgaXRlbS5yZWRvbmUgPSBuZXh0SWQ7XG4gIGtlZXBJdGVtKHJlZG9uZUl0ZW0sIHRydWUpO1xuICByZWRvbmVJdGVtLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gIHJldHVybiByZWRvbmVJdGVtXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhbnkgY29udGVudC5cbiAqL1xuY2xhc3MgSXRlbSBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqIEBwYXJhbSB7SXRlbSB8IG51bGx9IGxlZnRcbiAgICogQHBhcmFtIHtJRCB8IG51bGx9IG9yaWdpblxuICAgKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSByaWdodFxuICAgKiBAcGFyYW0ge0lEIHwgbnVsbH0gcmlnaHRPcmlnaW5cbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55PnxJRHxudWxsfSBwYXJlbnQgSXMgYSB0eXBlIGlmIGludGVncmF0ZWQsIGlzIG51bGwgaWYgaXQgaXMgcG9zc2libGUgdG8gY29weSBwYXJlbnQgZnJvbSBsZWZ0IG9yIHJpZ2h0LCBpcyBJRCBiZWZvcmUgaW50ZWdyYXRpb24gdG8gc2VhcmNoIGZvciBpdC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBwYXJlbnRTdWJcbiAgICogQHBhcmFtIHtBYnN0cmFjdENvbnRlbnR9IGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChpZCwgbGVmdCwgb3JpZ2luLCByaWdodCwgcmlnaHRPcmlnaW4sIHBhcmVudCwgcGFyZW50U3ViLCBjb250ZW50KSB7XG4gICAgc3VwZXIoaWQsIGNvbnRlbnQuZ2V0TGVuZ3RoKCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJdGVtIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgaXMgY3VycmVudGx5IHRvIHRoZSByaWdodCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0l0ZW0gfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSByaWdodCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJpZ2h0T3JpZ2luID0gcmlnaHRPcmlnaW47XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fElEfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHBhcmVudCByZWZlcnMgdG8gdGhpcyBpdGVtIHdpdGggc29tZSBraW5kIG9mIGtleSAoZS5nLiBZTWFwLCB0aGVcbiAgICAgKiBrZXkgaXMgc3BlY2lmaWVkIGhlcmUuIFRoZSBrZXkgaXMgdGhlbiB1c2VkIHRvIHJlZmVyIHRvIHRoZSBsaXN0IGluIHdoaWNoXG4gICAgICogdG8gaW5zZXJ0IHRoaXMgaXRlbS4gSWYgYHBhcmVudFN1YiA9IG51bGxgIHR5cGUuX3N0YXJ0IGlzIHRoZSBsaXN0IGluXG4gICAgICogd2hpY2ggdG8gaW5zZXJ0IHRvLiBPdGhlcndpc2UgaXQgaXMgYHBhcmVudC5fbWFwYC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudFN1YiA9IHBhcmVudFN1YjtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIHR5cGUncyBlZmZlY3QgaXMgcmV1bmRvbmUgdGhpcyB0eXBlIHJlZmVycyB0byB0aGUgdHlwZSB0aGF0IHVuZGlkXG4gICAgICogdGhpcyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlZG9uZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0Q29udGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIC8qKlxuICAgICAqIGJpdDE6IGtlZXBcbiAgICAgKiBiaXQyOiBjb3VudGFibGVcbiAgICAgKiBiaXQzOiBkZWxldGVkXG4gICAgICogYml0NDogbWFyayAtIG1hcmsgbm9kZSBhcyBmYXN0LXNlYXJjaC1tYXJrZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBieXRlXG4gICAgICovXG4gICAgdGhpcy5pbmZvID0gdGhpcy5jb250ZW50LmlzQ291bnRhYmxlKCkgPyBCSVQyIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gbWFyayB0aGUgaXRlbSBhcyBhbiBpbmRleGVkIGZhc3Qtc2VhcmNoIG1hcmtlclxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNldCBtYXJrZXIgKGlzTWFya2VkKSB7XG4gICAgaWYgKCgodGhpcy5pbmZvICYgQklUNCkgPiAwKSAhPT0gaXNNYXJrZWQpIHtcbiAgICAgIHRoaXMuaW5mbyBePSBCSVQ0O1xuICAgIH1cbiAgfVxuXG4gIGdldCBtYXJrZXIgKCkge1xuICAgIHJldHVybiAodGhpcy5pbmZvICYgQklUNCkgPiAwXG4gIH1cblxuICAvKipcbiAgICogSWYgdHJ1ZSwgZG8gbm90IGdhcmJhZ2UgY29sbGVjdCB0aGlzIEl0ZW0uXG4gICAqL1xuICBnZXQga2VlcCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBCSVQxKSA+IDBcbiAgfVxuXG4gIHNldCBrZWVwIChkb0tlZXApIHtcbiAgICBpZiAodGhpcy5rZWVwICE9PSBkb0tlZXApIHtcbiAgICAgIHRoaXMuaW5mbyBePSBCSVQxO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjb3VudGFibGUgKCkge1xuICAgIHJldHVybiAodGhpcy5pbmZvICYgQklUMikgPiAwXG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGl0ZW0gd2FzIGRlbGV0ZWQgb3Igbm90LlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIEJJVDMpID4gMFxuICB9XG5cbiAgc2V0IGRlbGV0ZWQgKGRvRGVsZXRlKSB7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCAhPT0gZG9EZWxldGUpIHtcbiAgICAgIHRoaXMuaW5mbyBePSBCSVQzO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtEZWxldGVkICgpIHtcbiAgICB0aGlzLmluZm8gfD0gQklUMztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNyZWF0b3IgY2xpZW50SUQgb2YgdGhlIG1pc3Npbmcgb3Agb3IgZGVmaW5lIG1pc3NpbmcgaXRlbXMgYW5kIHJldHVybiBudWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luICYmIHRoaXMub3JpZ2luLmNsaWVudCAhPT0gdGhpcy5pZC5jbGllbnQgJiYgdGhpcy5vcmlnaW4uY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMub3JpZ2luLmNsaWVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbi5jbGllbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucmlnaHRPcmlnaW4gJiYgdGhpcy5yaWdodE9yaWdpbi5jbGllbnQgIT09IHRoaXMuaWQuY2xpZW50ICYmIHRoaXMucmlnaHRPcmlnaW4uY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQgJiYgdGhpcy5pZC5jbGllbnQgIT09IHRoaXMucGFyZW50LmNsaWVudCAmJiB0aGlzLnBhcmVudC5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5wYXJlbnQuY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNsaWVudFxuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgYWxsIG1pc3NpbmcgaWRzLCBub3cgZmluZCB0aGUgaXRlbXNcblxuICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgdGhpcy5sZWZ0ID0gZ2V0SXRlbUNsZWFuRW5kKHRyYW5zYWN0aW9uLCBzdG9yZSwgdGhpcy5vcmlnaW4pO1xuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkO1xuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbikge1xuICAgICAgdGhpcy5yaWdodCA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCB0aGlzLnJpZ2h0T3JpZ2luKTtcbiAgICAgIHRoaXMucmlnaHRPcmlnaW4gPSB0aGlzLnJpZ2h0LmlkO1xuICAgIH1cbiAgICBpZiAoKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQuY29uc3RydWN0b3IgPT09IEdDKSB8fCAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBHQykpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gb25seSBzZXQgcGFyZW50IGlmIHRoaXMgc2hvdWxkbid0IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQuY29uc3RydWN0b3IgPT09IEl0ZW0pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLmxlZnQucGFyZW50O1xuICAgICAgICB0aGlzLnBhcmVudFN1YiA9IHRoaXMubGVmdC5wYXJlbnRTdWI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBJdGVtKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5yaWdodC5wYXJlbnQ7XG4gICAgICAgIHRoaXMucGFyZW50U3ViID0gdGhpcy5yaWdodC5wYXJlbnRTdWI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSBnZXRJdGVtKHN0b3JlLCB0aGlzLnBhcmVudCk7XG4gICAgICBpZiAocGFyZW50SXRlbS5jb25zdHJ1Y3RvciA9PT0gR0MpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSAvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAocGFyZW50SXRlbS5jb250ZW50KS50eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICB0aGlzLmlkLmNsb2NrICs9IG9mZnNldDtcbiAgICAgIHRoaXMubGVmdCA9IGdldEl0ZW1DbGVhbkVuZCh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayAtIDEpKTtcbiAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5sZWZ0Lmxhc3RJZDtcbiAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudC5zcGxpY2Uob2Zmc2V0KTtcbiAgICAgIHRoaXMubGVuZ3RoIC09IG9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGlmICgoIXRoaXMubGVmdCAmJiAoIXRoaXMucmlnaHQgfHwgdGhpcy5yaWdodC5sZWZ0ICE9PSBudWxsKSkgfHwgKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQucmlnaHQgIT09IHRoaXMucmlnaHQpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbztcbiAgICAgICAgLy8gc2V0IG8gdG8gdGhlIGZpcnN0IGNvbmZsaWN0aW5nIGl0ZW1cbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICBvID0gbGVmdC5yaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgIG8gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuZ2V0KHRoaXMucGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmIG8ubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG8ubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHVzZSBzb21ldGhpbmcgbGlrZSBEZWxldGVTZXQgaGVyZSAoYSB0cmVlIGltcGxlbWVudGF0aW9uIHdvdWxkIGJlIGJlc3QpXG4gICAgICAgIC8vIEB0b2RvIHVzZSBnbG9iYWwgc2V0IGRlZmluaXRpb25zXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY29uZmxpY3RpbmdJdGVtcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpdGVtc0JlZm9yZU9yaWdpbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gTGV0IGMgaW4gY29uZmxpY3RpbmdJdGVtcywgYiBpbiBpdGVtc0JlZm9yZU9yaWdpblxuICAgICAgICAvLyAqKip7b3JpZ2lufWJiYmJ7dGhpc317YyxifXtjLGJ9e299KioqXG4gICAgICAgIC8vIE5vdGUgdGhhdCBjb25mbGljdGluZ0l0ZW1zIGlzIGEgc3Vic2V0IG9mIGl0ZW1zQmVmb3JlT3JpZ2luXG4gICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmIG8gIT09IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICBpdGVtc0JlZm9yZU9yaWdpbi5hZGQobyk7XG4gICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5hZGQobyk7XG4gICAgICAgICAgaWYgKGNvbXBhcmVJRHModGhpcy5vcmlnaW4sIG8ub3JpZ2luKSkge1xuICAgICAgICAgICAgLy8gY2FzZSAxXG4gICAgICAgICAgICBpZiAoby5pZC5jbGllbnQgPCB0aGlzLmlkLmNsaWVudCkge1xuICAgICAgICAgICAgICBsZWZ0ID0gbztcbiAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlSURzKHRoaXMucmlnaHRPcmlnaW4sIG8ucmlnaHRPcmlnaW4pKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgYW5kIG8gYXJlIGNvbmZsaWN0aW5nIGFuZCBwb2ludCB0byB0aGUgc2FtZSBpbnRlZ3JhdGlvbiBwb2ludHMuIFRoZSBpZCBkZWNpZGVzIHdoaWNoIGl0ZW0gY29tZXMgZmlyc3QuXG4gICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgdG8gdGhlIGxlZnQgb2Ygbywgd2UgY2FuIGJyZWFrIGhlcmVcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gLy8gZWxzZSwgbyBtaWdodCBiZSBpbnRlZ3JhdGVkIGJlZm9yZSBhbiBpdGVtIHRoYXQgdGhpcyBjb25mbGljdHMgd2l0aC4gSWYgc28sIHdlIHdpbGwgZmluZCBpdCBpbiB0aGUgbmV4dCBpdGVyYXRpb25zXG4gICAgICAgICAgfSBlbHNlIGlmIChvLm9yaWdpbiAhPT0gbnVsbCAmJiBpdGVtc0JlZm9yZU9yaWdpbi5oYXMoZ2V0SXRlbSh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIG8ub3JpZ2luKSkpIHsgLy8gdXNlIGdldEl0ZW0gaW5zdGVhZCBvZiBnZXRJdGVtQ2xlYW5FbmQgYmVjYXVzZSB3ZSBkb24ndCB3YW50IC8gbmVlZCB0byBzcGxpdCBpdGVtcy5cbiAgICAgICAgICAgIC8vIGNhc2UgMlxuICAgICAgICAgICAgaWYgKCFjb25mbGljdGluZ0l0ZW1zLmhhcyhnZXRJdGVtKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgby5vcmlnaW4pKSkge1xuICAgICAgICAgICAgICBsZWZ0ID0gbztcbiAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBvID0gby5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgfVxuICAgICAgLy8gcmVjb25uZWN0IGxlZnQvcmlnaHQgKyB1cGRhdGUgcGFyZW50IG1hcC9zdGFydCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLmxlZnQucmlnaHQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5sZWZ0LnJpZ2h0ID0gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgICByID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLmdldCh0aGlzLnBhcmVudFN1YikgfHwgbnVsbDtcbiAgICAgICAgICB3aGlsZSAociAhPT0gbnVsbCAmJiByLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHIgPSByLmxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zdGFydFxuICAgICAgICAgIDsvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zdGFydCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yaWdodCA9IHI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJpZ2h0LmxlZnQgPSB0aGlzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBzZXQgYXMgY3VycmVudCBwYXJlbnQgdmFsdWUgaWYgcmlnaHQgPT09IG51bGwgYW5kIHRoaXMgaXMgcGFyZW50U3ViXG4gICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5zZXQodGhpcy5wYXJlbnRTdWIsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWUgb2YgcGFyZW50LiBkZWxldGUgcmlnaHRcbiAgICAgICAgICB0aGlzLmxlZnQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYWRqdXN0IGxlbmd0aCBvZiBwYXJlbnRcbiAgICAgIGlmICh0aGlzLnBhcmVudFN1YiA9PT0gbnVsbCAmJiB0aGlzLmNvdW50YWJsZSAmJiAhdGhpcy5kZWxldGVkKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2xlbmd0aCArPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGFkZFN0cnVjdCh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRoaXMpO1xuICAgICAgdGhpcy5jb250ZW50LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgdGhpcyk7XG4gICAgICAvLyBhZGQgcGFyZW50IHRvIHRyYW5zYWN0aW9uLmNoYW5nZWRcbiAgICAgIGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KSwgdGhpcy5wYXJlbnRTdWIpO1xuICAgICAgaWYgKCgvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9pdGVtICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2l0ZW0uZGVsZXRlZCkgfHwgKHRoaXMucGFyZW50U3ViICE9PSBudWxsICYmIHRoaXMucmlnaHQgIT09IG51bGwpKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBpZiBwYXJlbnQgaXMgZGVsZXRlZCBvciBpZiB0aGlzIGlzIG5vdCB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWUgb2YgcGFyZW50XG4gICAgICAgIHRoaXMuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyZW50IGlzIG5vdCBkZWZpbmVkLiBJbnRlZ3JhdGUgR0Mgc3RydWN0IGluc3RlYWRcbiAgICAgIG5ldyBHQyh0aGlzLmlkLCB0aGlzLmxlbmd0aCkuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmV4dCBub24tZGVsZXRlZCBpdGVtXG4gICAqL1xuICBnZXQgbmV4dCAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLnJpZ2h0O1xuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IHByZXYgKCkge1xuICAgIGxldCBuID0gdGhpcy5sZWZ0O1xuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbGFzdCBjb250ZW50IGFkZHJlc3Mgb2YgdGhpcyBJdGVtLlxuICAgKi9cbiAgZ2V0IGxhc3RJZCAoKSB7XG4gICAgLy8gYWxsb2NhdGluZyBpZHMgaXMgcHJldHR5IGNvc3RseSBiZWNhdXNlIG9mIHRoZSBhbW91bnQgb2YgaWRzIGNyZWF0ZWQsIHNvIHdlIHRyeSB0byByZXVzZSB3aGVuZXZlciBwb3NzaWJsZVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSA/IHRoaXMuaWQgOiBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gbWVyZ2UgdHdvIGl0ZW1zXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlbX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAoXG4gICAgICBjb21wYXJlSURzKHJpZ2h0Lm9yaWdpbiwgdGhpcy5sYXN0SWQpICYmXG4gICAgICB0aGlzLnJpZ2h0ID09PSByaWdodCAmJlxuICAgICAgY29tcGFyZUlEcyh0aGlzLnJpZ2h0T3JpZ2luLCByaWdodC5yaWdodE9yaWdpbikgJiZcbiAgICAgIHRoaXMuaWQuY2xpZW50ID09PSByaWdodC5pZC5jbGllbnQgJiZcbiAgICAgIHRoaXMuaWQuY2xvY2sgKyB0aGlzLmxlbmd0aCA9PT0gcmlnaHQuaWQuY2xvY2sgJiZcbiAgICAgIHRoaXMuZGVsZXRlZCA9PT0gcmlnaHQuZGVsZXRlZCAmJlxuICAgICAgdGhpcy5yZWRvbmUgPT09IG51bGwgJiZcbiAgICAgIHJpZ2h0LnJlZG9uZSA9PT0gbnVsbCAmJlxuICAgICAgdGhpcy5jb250ZW50LmNvbnN0cnVjdG9yID09PSByaWdodC5jb250ZW50LmNvbnN0cnVjdG9yICYmXG4gICAgICB0aGlzLmNvbnRlbnQubWVyZ2VXaXRoKHJpZ2h0LmNvbnRlbnQpXG4gICAgKSB7XG4gICAgICBpZiAocmlnaHQua2VlcCkge1xuICAgICAgICB0aGlzLmtlZXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0LnJpZ2h0O1xuICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yaWdodC5sZWZ0ID0gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgdGhpcyBJdGVtIGFzIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCk7XG4gICAgICAvLyBhZGp1c3QgdGhlIGxlbmd0aCBvZiBwYXJlbnRcbiAgICAgIGlmICh0aGlzLmNvdW50YWJsZSAmJiB0aGlzLnBhcmVudFN1YiA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuX2xlbmd0aCAtPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFya0RlbGV0ZWQoKTtcbiAgICAgIGFkZFRvRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgdGhpcy5pZC5jbGllbnQsIHRoaXMuaWQuY2xvY2ssIHRoaXMubGVuZ3RoKTtcbiAgICAgIGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgcGFyZW50LCB0aGlzLnBhcmVudFN1Yik7XG4gICAgICB0aGlzLmNvbnRlbnQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJlbnRHQ2RcbiAgICovXG4gIGdjIChzdG9yZSwgcGFyZW50R0NkKSB7XG4gICAgaWYgKCF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHRocm93IHVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgdGhpcy5jb250ZW50LmdjKHN0b3JlKTtcbiAgICBpZiAocGFyZW50R0NkKSB7XG4gICAgICByZXBsYWNlU3RydWN0KHN0b3JlLCB0aGlzLCBuZXcgR0ModGhpcy5pZCwgdGhpcy5sZW5ndGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFVwZGF0ZUVuY29kZXJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IG9yaWdpbiA9IG9mZnNldCA+IDAgPyBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayArIG9mZnNldCAtIDEpIDogdGhpcy5vcmlnaW47XG4gICAgY29uc3QgcmlnaHRPcmlnaW4gPSB0aGlzLnJpZ2h0T3JpZ2luO1xuICAgIGNvbnN0IHBhcmVudFN1YiA9IHRoaXMucGFyZW50U3ViO1xuICAgIGNvbnN0IGluZm8gPSAodGhpcy5jb250ZW50LmdldFJlZigpICYgQklUUzUpIHxcbiAgICAgIChvcmlnaW4gPT09IG51bGwgPyAwIDogQklUOCkgfCAvLyBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgKHJpZ2h0T3JpZ2luID09PSBudWxsID8gMCA6IEJJVDcpIHwgLy8gcmlnaHQgb3JpZ2luIGlzIGRlZmluZWRcbiAgICAgIChwYXJlbnRTdWIgPT09IG51bGwgPyAwIDogQklUNik7IC8vIHBhcmVudFN1YiBpcyBub24tbnVsbFxuICAgIGVuY29kZXIud3JpdGVJbmZvKGluZm8pO1xuICAgIGlmIChvcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQob3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0T3JpZ2luICE9PSBudWxsKSB7XG4gICAgICBlbmNvZGVyLndyaXRlUmlnaHRJRChyaWdodE9yaWdpbik7XG4gICAgfVxuICAgIGlmIChvcmlnaW4gPT09IG51bGwgJiYgcmlnaHRPcmlnaW4gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCk7XG4gICAgICBjb25zdCBwYXJlbnRJdGVtID0gcGFyZW50Ll9pdGVtO1xuICAgICAgaWYgKHBhcmVudEl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgLy8gcGFyZW50IHR5cGUgb24geS5fbWFwXG4gICAgICAgIC8vIGZpbmQgdGhlIGNvcnJlY3Qga2V5XG4gICAgICAgIGNvbnN0IHlrZXkgPSBmaW5kUm9vdFR5cGVLZXkocGFyZW50KTtcbiAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8odHJ1ZSk7IC8vIHdyaXRlIHBhcmVudFlLZXlcbiAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyh5a2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKGZhbHNlKTsgLy8gd3JpdGUgcGFyZW50IGlkXG4gICAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQocGFyZW50SXRlbS5pZCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcocGFyZW50U3ViKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250ZW50LndyaXRlKGVuY29kZXIsIG9mZnNldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VXBkYXRlRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGluZm9cbiAqL1xuY29uc3QgcmVhZEl0ZW1Db250ZW50ID0gKGRlY29kZXIsIGluZm8pID0+IGNvbnRlbnRSZWZzW2luZm8gJiBCSVRTNV0oZGVjb2Rlcik7XG5cbi8qKlxuICogQSBsb29rdXAgbWFwIGZvciByZWFkaW5nIEl0ZW0gY29udGVudC5cbiAqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oQWJzdHJhY3RVcGRhdGVEZWNvZGVyKTpBYnN0cmFjdENvbnRlbnQ+fVxuICovXG5jb25zdCBjb250ZW50UmVmcyA9IFtcbiAgKCkgPT4geyB0aHJvdyB1bmV4cGVjdGVkQ2FzZSgpIH0sIC8vIEdDIGlzIG5vdCBJdGVtQ29udGVudFxuICByZWFkQ29udGVudERlbGV0ZWQsIC8vIDFcbiAgcmVhZENvbnRlbnRKU09OLCAvLyAyXG4gIHJlYWRDb250ZW50QmluYXJ5LCAvLyAzXG4gIHJlYWRDb250ZW50U3RyaW5nLCAvLyA0XG4gIHJlYWRDb250ZW50RW1iZWQsIC8vIDVcbiAgcmVhZENvbnRlbnRGb3JtYXQsIC8vIDZcbiAgcmVhZENvbnRlbnRUeXBlLCAvLyA3XG4gIHJlYWRDb250ZW50QW55LCAvLyA4XG4gIHJlYWRDb250ZW50RG9jIC8vIDlcbl07XG5cbmV4cG9ydCB7IEFic3RyYWN0Q29ubmVjdG9yLCBBYnN0cmFjdFN0cnVjdCwgQWJzdHJhY3RUeXBlLCBZQXJyYXkgYXMgQXJyYXksIENvbnRlbnRBbnksIENvbnRlbnRCaW5hcnksIENvbnRlbnREZWxldGVkLCBDb250ZW50RW1iZWQsIENvbnRlbnRGb3JtYXQsIENvbnRlbnRKU09OLCBDb250ZW50U3RyaW5nLCBDb250ZW50VHlwZSwgRG9jLCBHQywgSUQsIEl0ZW0sIFlNYXAgYXMgTWFwLCBQZXJtYW5lbnRVc2VyRGF0YSwgUmVsYXRpdmVQb3NpdGlvbiwgU25hcHNob3QsIFlUZXh0IGFzIFRleHQsIFRyYW5zYWN0aW9uLCBVbmRvTWFuYWdlciwgWVhtbEVsZW1lbnQgYXMgWG1sRWxlbWVudCwgWVhtbEZyYWdtZW50IGFzIFhtbEZyYWdtZW50LCBZWG1sSG9vayBhcyBYbWxIb29rLCBZWG1sVGV4dCBhcyBYbWxUZXh0LCBZQXJyYXlFdmVudCwgWUV2ZW50LCBZTWFwRXZlbnQsIFlUZXh0RXZlbnQsIFlYbWxFdmVudCwgYXBwbHlVcGRhdGUsIGFwcGx5VXBkYXRlVjIsIGNvbXBhcmVJRHMsIGNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucywgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uLCBjcmVhdGVEZWxldGVTZXQsIGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZSwgY3JlYXRlRG9jRnJvbVNuYXBzaG90LCBjcmVhdGVJRCwgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OLCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCwgY3JlYXRlU25hcHNob3QsIGRlY29kZVNuYXBzaG90LCBkZWNvZGVTbmFwc2hvdFYyLCBkZWNvZGVTdGF0ZVZlY3RvciwgZGVjb2RlU3RhdGVWZWN0b3JWMiwgZW1wdHlTbmFwc2hvdCwgZW5jb2RlU25hcHNob3QsIGVuY29kZVNuYXBzaG90VjIsIGVuY29kZVN0YXRlQXNVcGRhdGUsIGVuY29kZVN0YXRlQXNVcGRhdGVWMiwgZW5jb2RlU3RhdGVWZWN0b3IsIGVuY29kZVN0YXRlVmVjdG9yVjIsIGVxdWFsU25hcHNob3RzLCBmaW5kUm9vdFR5cGVLZXksIGdldEl0ZW0sIGdldFN0YXRlLCBnZXRUeXBlQ2hpbGRyZW4sIGlzRGVsZXRlZCwgaXNQYXJlbnRPZiwgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzLCBsb2dUeXBlLCByZWFkVXBkYXRlLCByZWFkVXBkYXRlVjIsIHNuYXBzaG90LCB0cmFuc2FjdCwgdHJ5R2MsIHR5cGVMaXN0VG9BcnJheVNuYXBzaG90LCB0eXBlTWFwR2V0U25hcHNob3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXlqcy5tanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-crdt/node_modules/yjs/dist/yjs.mjs\n")},"../CoCreate-action/src/index.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n// -testing1\nconst CoCreateAction = {\n  attribute: 'data-actions',\n  actions: {},\n  selectedStage: [],\n  stageIndex: 0,\n  selectedElement: null,\n  completedEventName: 'completedEvent',\n  __init: function () {\n    this.actionButtonEvent();\n  },\n  // init: function(container) {\n  //   const __container = container || document\n  //   if (!__container.querySelectorAll) {\n  // \treturn;\n  // }\n  // let buttons = __container.querySelectorAll(\"[data-actions]\");\n  // for (let i = 0; i < buttons.length; i++) {\n  //   this.actionButtonEvent(buttons[i]);\n  // }\n  // },\n  // actionButtonEvent: function(btn) {\n  //   const _this = this;    \n  // let checkActions = btn.getAttribute('data-actions') || \"\";\n  // checkActions = checkActions.replace(/\\s/g, '').split(',');\n  // if (checkActions.length == 0) {\n  //   return;\n  // }\n  //   btn.addEventListener('click', function(event) {\n  //     event.preventDefault();\n  //     let actions = this.getAttribute(_this.attribute) || \"\";\n  //     actions = actions.replace(/\\s/g, '').split(',');\n  //     _this.stageIndex = 0;\n  //     _this.selectedStage = actions;\n  //     //. run function\n  //     _this.selectedElement = btn;\n  //     _this.__runActionFunc();\n  //   })\n  // },\n  actionButtonEvent: function () {\n    const self = this;\n    document.addEventListener('click', function (event) {\n      let btn = event.target;\n\n      if (!btn.getAttribute('data-actions')) {\n        btn = event.target.closest('[data-actions]');\n      }\n\n      if (!btn) return;\n      event.preventDefault();\n      let actions = (btn.getAttribute(self.attribute) || \"\").replace(/\\s/g, '').split(',');\n      if (actions.length == 0) return;\n      self.stageIndex = 0;\n      self.selectedStage = actions; //. run function\n\n      self.selectedElement = btn;\n\n      self.__runActionFunc();\n    });\n  },\n  init: function ({\n    action,\n    callback,\n    endEvent\n  }) {\n    this.registerEvent(action, callback, null, endEvent);\n  },\n\n  /**\n   * key: string\n   * runFunc: function\n   * instance: object\n   * endEvent: string\n   **/\n  registerEvent: function (key, runFunc, instance, endEvent) {\n    if (this.actions[key]) {\n      return;\n    }\n\n    this.actions[key] = {\n      key: key,\n      runFunc: runFunc,\n      instance: instance || window,\n      endEvent: endEvent\n    }; //. register events\n\n    for (let __key in this.actions) {\n      if (__key != key && this.actions[__key]['endEvent'] === endEvent) {\n        return;\n      }\n    } //. register events\n\n\n    const _this = this;\n\n    document.addEventListener(endEvent, function (e) {\n      _this.__nextAction(endEvent, e.detail);\n    });\n  },\n  __runActionFunc: function (data) {\n    if (this.stageIndex >= this.selectedStage.length) {\n      //. if latest case, it will be run aTag\n      if (this.stageIndex == this.selectedStage.length) {\n        this.__runAtag(this.selectedElement);\n      }\n\n      return;\n    }\n\n    const key = this.selectedStage[this.stageIndex]; //. run function\n\n    const action = this.actions[key];\n\n    if (action) {\n      if (action.runFunc) {\n        action.runFunc.call(null, this.selectedElement, data);\n      } else {\n        this.__nextAction(action.endEvent, {});\n      }\n    }\n  },\n  __nextAction: function (eventName, data) {\n    const key = this.selectedStage[this.stageIndex];\n\n    if (!key) {\n      return;\n    }\n\n    if (eventName !== this.actions[key].endEvent) {\n      return;\n    }\n\n    this.stageIndex++;\n\n    this.__runActionFunc(data);\n  },\n  __runAtag: function (button) {\n    var aTag = button.querySelector('a');\n\n    if (aTag) {\n      CoCreate.logic.setLinkProcess(aTag);\n    }\n  }\n};\n\nCoCreateAction.__init();\n\nvar _default = CoCreateAction;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWFjdGlvbi9zcmMvaW5kZXguanM/NTBkNSJdLCJuYW1lcyI6WyJDb0NyZWF0ZUFjdGlvbiIsImF0dHJpYnV0ZSIsImFjdGlvbnMiLCJzZWxlY3RlZFN0YWdlIiwic3RhZ2VJbmRleCIsInNlbGVjdGVkRWxlbWVudCIsImNvbXBsZXRlZEV2ZW50TmFtZSIsIl9faW5pdCIsImFjdGlvbkJ1dHRvbkV2ZW50Iiwic2VsZiIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiYnRuIiwidGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwiY2xvc2VzdCIsInByZXZlbnREZWZhdWx0IiwicmVwbGFjZSIsInNwbGl0IiwibGVuZ3RoIiwiX19ydW5BY3Rpb25GdW5jIiwiaW5pdCIsImFjdGlvbiIsImNhbGxiYWNrIiwiZW5kRXZlbnQiLCJyZWdpc3RlckV2ZW50Iiwia2V5IiwicnVuRnVuYyIsImluc3RhbmNlIiwid2luZG93IiwiX19rZXkiLCJfdGhpcyIsImUiLCJfX25leHRBY3Rpb24iLCJkZXRhaWwiLCJkYXRhIiwiX19ydW5BdGFnIiwiY2FsbCIsImV2ZW50TmFtZSIsImJ1dHRvbiIsImFUYWciLCJxdWVyeVNlbGVjdG9yIiwiQ29DcmVhdGUiLCJsb2dpYyIsInNldExpbmtQcm9jZXNzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBLE1BQU1BLGNBQWMsR0FBRztBQUNyQkMsV0FBUyxFQUFFLGNBRFU7QUFFckJDLFNBQU8sRUFBRSxFQUZZO0FBR3JCQyxlQUFhLEVBQUUsRUFITTtBQUlyQkMsWUFBVSxFQUFFLENBSlM7QUFLckJDLGlCQUFlLEVBQUUsSUFMSTtBQU9yQkMsb0JBQWtCLEVBQUUsZ0JBUEM7QUFTckJDLFFBQU0sRUFBRSxZQUFXO0FBQ2pCLFNBQUtDLGlCQUFMO0FBQ0QsR0FYb0I7QUFZckI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFD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WyIvLyAtdGVzdGluZzFcbmNvbnN0IENvQ3JlYXRlQWN0aW9uID0ge1xuICBhdHRyaWJ1dGU6ICdkYXRhLWFjdGlvbnMnLFxuICBhY3Rpb25zOiB7fSxcbiAgc2VsZWN0ZWRTdGFnZTogW10sXG4gIHN0YWdlSW5kZXg6IDAsXG4gIHNlbGVjdGVkRWxlbWVudDogbnVsbCxcbiAgXG4gIGNvbXBsZXRlZEV2ZW50TmFtZTogJ2NvbXBsZXRlZEV2ZW50JyxcbiAgXG4gIF9faW5pdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hY3Rpb25CdXR0b25FdmVudCgpXG4gIH0sXG4gIC8vIGluaXQ6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIFxuICAvLyAgIGNvbnN0IF9fY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50XG4gIC8vICAgaWYgKCFfX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKSB7XG5cdFx0Ly8gXHRyZXR1cm47XG5cdFx0Ly8gfVxuXHRcdFxuXHRcdC8vIGxldCBidXR0b25zID0gX19jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWFjdGlvbnNdXCIpO1xuXG5cdFx0Ly8gZm9yIChsZXQgaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0Ly8gICB0aGlzLmFjdGlvbkJ1dHRvbkV2ZW50KGJ1dHRvbnNbaV0pO1xuXHRcdC8vIH1cbiAgLy8gfSxcbiAgXG4gIC8vIGFjdGlvbkJ1dHRvbkV2ZW50OiBmdW5jdGlvbihidG4pIHtcbiAgLy8gICBjb25zdCBfdGhpcyA9IHRoaXM7ICAgIFxuXHQgLy8gbGV0IGNoZWNrQWN0aW9ucyA9IGJ0bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aW9ucycpIHx8IFwiXCI7XG5cdCAvLyBjaGVja0FjdGlvbnMgPSBjaGVja0FjdGlvbnMucmVwbGFjZSgvXFxzL2csICcnKS5zcGxpdCgnLCcpO1xuXHQgIFxuXHQgLy8gaWYgKGNoZWNrQWN0aW9ucy5sZW5ndGggPT0gMCkge1xuXHQgLy8gICByZXR1cm47XG5cdCAvLyB9XG5cbiAgLy8gICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAvLyAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgLy8gICAgIGxldCBhY3Rpb25zID0gdGhpcy5nZXRBdHRyaWJ1dGUoX3RoaXMuYXR0cmlidXRlKSB8fCBcIlwiO1xuICAvLyAgICAgYWN0aW9ucyA9IGFjdGlvbnMucmVwbGFjZSgvXFxzL2csICcnKS5zcGxpdCgnLCcpO1xuICAvLyAgICAgX3RoaXMuc3RhZ2VJbmRleCA9IDA7XG4gIC8vICAgICBfdGhpcy5zZWxlY3RlZFN0YWdlID0gYWN0aW9ucztcbiAgICAgIFxuICAvLyAgICAgLy8uIHJ1biBmdW5jdGlvblxuICAvLyAgICAgX3RoaXMuc2VsZWN0ZWRFbGVtZW50ID0gYnRuO1xuICAvLyAgICAgX3RoaXMuX19ydW5BY3Rpb25GdW5jKCk7XG4gICAgICBcbiAgLy8gICB9KVxuICAvLyB9LFxuICBcbiAgYWN0aW9uQnV0dG9uRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGxldCBidG4gPSBldmVudC50YXJnZXQ7XG4gICAgICBpZiAoIWJ0bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aW9ucycpKSB7XG4gICAgICAgIGJ0biA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KCdbZGF0YS1hY3Rpb25zXScpO1xuICAgICAgfVxuICAgICAgaWYgKCFidG4pIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGxldCBhY3Rpb25zID0gKGJ0bi5nZXRBdHRyaWJ1dGUoc2VsZi5hdHRyaWJ1dGUpIHx8IFwiXCIpLnJlcGxhY2UoL1xccy9nLCAnJykuc3BsaXQoJywnKTtcbiAgICAgIGlmIChhY3Rpb25zLmxlbmd0aCA9PSAwKSByZXR1cm47XG4gICAgICBzZWxmLnN0YWdlSW5kZXggPSAwO1xuICAgICAgc2VsZi5zZWxlY3RlZFN0YWdlID0gYWN0aW9ucztcbiAgICAgIFxuICAgICAgLy8uIHJ1biBmdW5jdGlvblxuICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQgPSBidG47XG4gICAgICBzZWxmLl9fcnVuQWN0aW9uRnVuYygpO1xuICAgIH0pXG4gIH0sXG4gIFxuICBpbml0OiBmdW5jdGlvbih7YWN0aW9uLCBjYWxsYmFjaywgZW5kRXZlbnR9KSB7XG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KGFjdGlvbiwgY2FsbGJhY2ssIG51bGwsIGVuZEV2ZW50KTtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBrZXk6IHN0cmluZ1xuICAgKiBydW5GdW5jOiBmdW5jdGlvblxuICAgKiBpbnN0YW5jZTogb2JqZWN0XG4gICAqIGVuZEV2ZW50OiBzdHJpbmdcbiAgICoqL1xuICByZWdpc3RlckV2ZW50OiBmdW5jdGlvbihrZXksIHJ1bkZ1bmMsIGluc3RhbmNlLCBlbmRFdmVudCkge1xuICAgIGlmICh0aGlzLmFjdGlvbnNba2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmFjdGlvbnNba2V5XSA9IHtcbiAgICAgIGtleToga2V5LFxuICAgICAgcnVuRnVuYzogcnVuRnVuYyxcbiAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSB8fCB3aW5kb3csXG4gICAgICBlbmRFdmVudDogZW5kRXZlbnRcbiAgICB9XG4gICAgLy8uIHJlZ2lzdGVyIGV2ZW50c1xuICAgIFxuICAgIGZvciAobGV0IF9fa2V5IGluIHRoaXMuYWN0aW9ucykge1xuICAgICAgaWYgKF9fa2V5ICE9IGtleSAmJiB0aGlzLmFjdGlvbnNbX19rZXldWydlbmRFdmVudCddID09PSBlbmRFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vLiByZWdpc3RlciBldmVudHNcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgX3RoaXMuX19uZXh0QWN0aW9uKGVuZEV2ZW50LCBlLmRldGFpbClcbiAgICB9KTtcbiAgfSxcbiAgXG4gIF9fcnVuQWN0aW9uRnVuYzogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgaWYgKHRoaXMuc3RhZ2VJbmRleCA+PSB0aGlzLnNlbGVjdGVkU3RhZ2UubGVuZ3RoKSB7XG5cbiAgICAgIC8vLiBpZiBsYXRlc3QgY2FzZSwgaXQgd2lsbCBiZSBydW4gYVRhZ1xuICAgICAgaWYgKHRoaXMuc3RhZ2VJbmRleCA9PSB0aGlzLnNlbGVjdGVkU3RhZ2UubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX19ydW5BdGFnKHRoaXMuc2VsZWN0ZWRFbGVtZW50KTsgICAgICAgIFxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBrZXkgPSB0aGlzLnNlbGVjdGVkU3RhZ2VbdGhpcy5zdGFnZUluZGV4XTtcbiAgICAvLy4gcnVuIGZ1bmN0aW9uXG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25zW2tleV07XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgaWYgKGFjdGlvbi5ydW5GdW5jKSB7XG4gICAgICAgIGFjdGlvbi5ydW5GdW5jLmNhbGwobnVsbCwgdGhpcy5zZWxlY3RlZEVsZW1lbnQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX25leHRBY3Rpb24oYWN0aW9uLmVuZEV2ZW50LCB7fSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcbiAgX19uZXh0QWN0aW9uOiBmdW5jdGlvbihldmVudE5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnNlbGVjdGVkU3RhZ2VbdGhpcy5zdGFnZUluZGV4XTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmV0dXJuIDtcbiAgICB9XG4gICAgaWYgKGV2ZW50TmFtZSAhPT0gdGhpcy5hY3Rpb25zW2tleV0uZW5kRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGFnZUluZGV4ICsrO1xuICAgIHRoaXMuX19ydW5BY3Rpb25GdW5jKGRhdGEpO1xuICB9LFxuICBcbiAgX19ydW5BdGFnOiBmdW5jdGlvbihidXR0b24pIHtcbiAgICB2YXIgYVRhZyA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKCdhJyk7XG4gICAgICAgICAgXG4gICAgaWYgKGFUYWcpIHtcbiAgICAgIENvQ3JlYXRlLmxvZ2ljLnNldExpbmtQcm9jZXNzKGFUYWcpXG4gICAgfVxuICB9XG59XG5cblxuQ29DcmVhdGVBY3Rpb24uX19pbml0KCk7XG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlQWN0aW9uOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-action/src/index.js\n")},"../CoCreate-crdt/src/core.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar Y = _interopRequireWildcard(__webpack_require__(/*! yjs */ "../CoCreate-crdt/node_modules/yjs/dist/yjs.mjs"));\n\nvar _yWebsocket = __webpack_require__(/*! y-websocket */ "../CoCreate-crdt/node_modules/y-websocket/src/y-websocket.js");\n\nvar _yIndexeddb = __webpack_require__(/*! y-indexeddb */ "../CoCreate-crdt/node_modules/y-indexeddb/src/y-indexeddb.js");\n\nvar _src = __webpack_require__(/*! ../../../CoCreateJS/src */ "../../CoCreateJS/src/index.js");\n\nvar _src2 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-cursors/src */ "../CoCreate-cursors/src/index.js"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst debug = false;\n\nclass CoCreateYSocket {\n  constructor(org, ydoc) {\n    this.doc = ydoc;\n    this.orgName = org;\n    this.docs = {};\n    this._awarenessListener = null;\n    this.character = \'_\';\n\n    this.listenAwereness = function () {};\n  }\n\n  createDoc(id, element) {\n    if (!id || id == "") {\n      return null;\n    }\n\n    let newInfo = this.parseType(id); // if(debug)\n    // \tconsole.log(newInfo);\n\n    const newId = newInfo.id;\n\n    if (this.docs[newId]) {\n      if (element && !this.__checkExistElement(this.docs[newId].elements, element)) {\n        this.docs[newId].elements.push(element);\n      }\n\n      if (!this.docs[newId].types.some(type => type === id)) {\n        // register event\n        this.docs[newId].types.push(id);\n        this.registerUpdateEvent(this.docs[newId], id);\n      }\n\n      return false;\n    }\n\n    const yDoc = this.doc;\n\n    const url_socket = this.__getSocketUrl(); //draw cursor dinamially\n    // new UserCursor(socketProvider);\n\n\n    var socketProvider = new _yWebsocket.WebsocketProvider(url_socket, newId, yDoc);\n    let indexeddbProvider = null;\n\n    if (newInfo.document_id != "null") {\n      indexeddbProvider = new _yIndexeddb.IndexeddbPersistence(newId, this.doc);\n      indexeddbProvider.whenSynced.then(() => {\n        console.log(\'loaded data from indexed db\');\n      });\n    }\n\n    let awareness = socketProvider.awareness;\n    this._cursors = new Map();\n\n    this._awarenessListener = event => {\n      const f = clientId => {\n        if (clientId !== this.doc.clientID) {\n          this.updateRemoteSelection(yDoc, id, yDoc.getText(id), this._cursors, clientId, awareness);\n        }\n      };\n\n      event.added.forEach(f);\n      event.removed.forEach(f);\n      event.updated.forEach(f);\n    };\n\n    awareness.on(\'change\', this._awarenessListener);\n    /*\n    awareness.getStates().forEach((aw, clientId) => {\n    \tconsole.log("Update --")\n          })\n          */\n\n    this.docs[newId] = {\n      id: newId,\n      doc: yDoc,\n      socket: socketProvider,\n      awareness: awareness,\n      elements: element ? [element] : [],\n      types: [id],\n      indexeddb: indexeddbProvider\n    };\n    this.registerUpdateEvent(this.docs[newId], id);\n    return true;\n  }\n\n  registerUpdateEvent(docObject, id) {\n    const yDoc = docObject.doc;\n    const shardType = yDoc.getText(id);\n\n    let _this = this;\n\n    shardType.observe(event => {\n      _this.__setTypeObserveEvent(event, docObject.elements, id);\n    });\n  }\n\n  __checkExistElement(elements, element) {\n    for (var i = 0; i < elements.length; i++) {\n      if (elements[i].isSameNode(element)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  __getSocketUrl() {\n    console.log("get_socket url");\n    let w_location = window.location || window.parent.location;\n    let w_protocol = w_location.protocol;\n    let w_host = w_location.host;\n\n    if (w_location.protocol === "about:") {\n      w_protocol = w_location.protocol;\n      w_host = document.referrer;\n    }\n\n    let protocol = w_protocol === \'http:\' ? \'ws\' : \'wss\';\n    let url_socket = `${protocol}://${w_host}:8080/`;\n\n    if (window.config && window.config.host) {\n      if (window.config.host.includes("://")) {\n        url_socket = `${window.config.host}/`;\n      } else {\n        url_socket = `${protocol}://${window.config.host}/`;\n      }\n    }\n\n    console.log(url_socket);\n    url_socket += "crdt/";\n    return url_socket;\n  }\n\n  __setTypeObserveEvent(event, elements, id) {\n    if (!id) return;\n    const eventDelta = event.delta;\n    const info = JSON.parse(atob(id));\n    let is_save_value = false;\n    const wholestring = event.target.toString();\n    const store_event = new CustomEvent(\'store-content-db\', {\n      detail: wholestring\n    });\n    const update_event = new CustomEvent(\'cocreate-y-update\', {\n      detail: eventDelta\n    });\n    elements.forEach(el => {\n      if (_src.utils.isReadValue(el) && el.getAttribute(\'name\') === info.name) {\n        el.dispatchEvent(update_event);\n      }\n    });\n\n    if (typeof info !== \'object\') {\n      return;\n    }\n\n    if (event.transaction.local) {\n      if (elements.length == 0) {\n        is_save_value = true;\n      }\n\n      elements.forEach(el => {\n        if (el.getAttribute(\'data-save_value\') != \'false\' && el.getAttribute(\'name\') === info.name && info.document_id != "null") {\n          is_save_value = true;\n          el.dispatchEvent(store_event);\n        }\n      });\n\n      if (is_save_value) {\n        _src.crud.updateDocument({\n          collection: info.collection,\n          document_id: info.document_id,\n          data: {\n            [info.name]: wholestring\n          },\n          metadata: \'yjs-change\'\n        });\n      }\n    } else {}\n  }\n\n  deleteDoc(id) {\n    const info = this.parseType(id);\n\n    if (this.docs[info.id]) {\n      delete this.docs[info.id];\n    }\n  }\n\n  generateDocName(collection, document_id, name) {\n    const info = {\n      org: this.orgName,\n      collection,\n      document_id,\n      name\n    };\n    return btoa(JSON.stringify(info)); // return this.orgName + "_" + collection + "_" + document_id + "_" + name;\n  }\n\n  insertData(id, index, content, attribute) {\n    const info = this.parseType(id);\n\n    if (this.docs[info.id]) {\n      if (attribute) {\n        this.docs[info.id].doc.getText(id).insert(index, content, attribute);\n      } else {\n        this.docs[info.id].doc.getText(id).insert(index, content);\n      }\n    }\n  }\n\n  deleteData(id, index, length) {\n    const info = this.parseType(id);\n\n    if (this.docs[info.id]) {\n      this.docs[info.id].doc.getText(id).delete(index, length);\n    }\n  }\n\n  getWholeString(id) {\n    const info = this.parseType(id);\n\n    if (this.docs[info.id]) {\n      console.log("!Get data");\n      return this.docs[info.id].doc.getText(id).toString();\n    } else {\n      return "--";\n    }\n  }\n\n  updateRemoteSelection(y, cm, type, cursors, clientId, awareness) {\n    if (debug) console.log("CHANGE ---- DOCID ", this.doc.clientID, \' OTHER CLIENTEID \', clientId);\n\n    if (clientId !== this.doc.clientID) {\n      //console.log("TEXT -> updateRemoteSelection ",clientId,awareness,cursor)\n      //console.log("AW status",awareness.getLocalState())\n      // destroy current text mark\n      const m = cursors.get(clientId);\n\n      if (m !== undefined) {\n        m.caret.clear();\n\n        if (m.sel !== null) {\n          m.sel.clear();\n        }\n\n        cursors.delete(clientId);\n      } // redraw caret and selection for clientId\n\n\n      const aw = awareness.getStates().get(clientId);\n      if (debug) console.log(aw);\n\n      if (aw === undefined) {\n        if (debug) console.log(" Cursor OUT ", clientId); //awareness.setLocalStateField(\'cursor\', null);\n\n        let elements = document.querySelectorAll(\'[id*="socket_\' + clientId + \'"]\');\n        elements.forEach(function (element, index, array) {\n          element.parentNode.removeChild(element);\n        });\n        let sel_elements = document.querySelectorAll(\'[id*="sel-\' + clientId + \'"]\');\n        sel_elements.forEach(function (sel_element, index, array) {\n          sel_element.parentNode.removeChild(sel_element);\n        });\n        /*\n         let element = document.getElementById("socket_"+clientId)\n         let sel_element = document.getElementById("sel-"+clientId)\n         if(element)\n        element.parentNode.removeChild(element);\n        if(sel_element)\n        sel_element.parentNode.removeChild(sel_element);\n         */\n\n        return;\n      }\n\n      const user = aw.user || {};\n\n      if (user.color == null) {\n        user.color = \'#ffa500\';\n      }\n\n      if (user.name == null) {\n        user.name = `User: ${clientId}`;\n      }\n\n      const cursor = aw.cursor;\n      if (debug) console.log("Cursor ", cursor);\n\n      if (cursor == null || cursor.anchor == null || cursor.head == null) {\n        //let element = document.getElementById("socket_"+clientId)\n        let elements = document.querySelectorAll(\'[id*="socket_\' + clientId + \'"]\');\n        elements.forEach(function (element, index, array) {\n          element.parentNode.removeChild(element);\n        }); //let sel_element = document.getElementById("sel-"+clientId)  \n\n        let sel_elements = document.querySelectorAll(\'[id*="sel-\' + clientId + \'"]\');\n        sel_elements.forEach(function (sel_element, index, array) {\n          sel_element.parentNode.removeChild(sel_element);\n        });\n        return;\n      }\n\n      const anchor = Y.createAbsolutePositionFromRelativePosition(Y.createRelativePositionFromJSON(cursor.anchor), y);\n      const head = Y.createAbsolutePositionFromRelativePosition(Y.createRelativePositionFromJSON(cursor.head), y); //CoCreate.cursors.draw_cursor(1,11,12,66,{},true);\n\n      if (debug) {\n        console.log("PRE Draw Cursor ");\n        console.log("anchor  ", anchor, " head ", head, \' Type \', type);\n        console.log("anchor  Type", anchor.type === type);\n        console.log("anchor  Type", head.type === type);\n      } //if (anchor !== null && head !== null && anchor.type === type && head.type === type) {\n\n\n      if (anchor !== null && head !== null) {\n        let from, to;\n\n        if (head.index < anchor.index) {\n          from = head.index;\n          to = anchor.index;\n        } else {\n          if (debug) console.log(anchor.index);\n          from = anchor.index;\n          to = head.index;\n        }\n\n        if (debug) console.log("Draw Cursor ", from, to, clientId, aw.user);\n        let t_info = this.parseTypeName(cursor.anchor[\'tname\']);\n        let id_mirror = t_info.document_id + t_info.name + \'--mirror-div\';\n        let json = {};\n        let selector = \'[data-collection="\' + t_info.collection + \'"][data-document_id="\' + t_info.document_id + \'"][name="\' + t_info.name + \'"]\';\n        selector += \':not(.codemirror):not(.quill):not(.monaco)\';\n        let elements = document.querySelectorAll(selector);\n        let that = this;\n        elements.forEach(function (element, index, array) {\n          json = {\n            element: element,\n            startPosition: from,\n            selector: selector,\n            endPositon: to,\n            clientId: clientId,\n            user: {\n              \'color\': user.color,\n              \'name\': user.name\n            }\n          };\n          console.log(json);\n\n          _src2.default.draw_cursor(json); //sent custom position\n\n\n          that.listen(json);\n        });\n      }\n    }\n  }\n\n  changeListenAwereness(callback) {\n    this.listenAwereness = callback;\n  }\n\n  listen(json) {\n    this.listenAwereness.apply(this, [json]);\n  }\n\n  destroyObserver(id, element) {\n    const info = this.parseType(id);\n    this.docs[info.id].doc.getText(id).unobserve(event => {});\n    this.docs[info.id].socket.awareness.off(\'change\', this._awarenessListener);\n  }\n\n  getProvider(id) {\n    const info = this.parseType(id);\n\n    if (!this.docs[info.id]) {\n      return null;\n    }\n\n    return this.docs[info.id].socket;\n  }\n\n  getType(id) {\n    const info = this.parseType(id);\n\n    if (!this.docs[info.id]) {\n      return null;\n    }\n\n    return this.docs[info.id].doc.getText(id);\n  }\n\n  setCursorNull(id) {\n    const info = this.parseType(id);\n\n    if (!this.docs[info.id]) {\n      return null;\n    }\n\n    this.docs[info.id].socket.awareness.setLocalStateField(\'cursor\', null);\n  }\n\n  setPositionYJS(id, from, to) {\n    const info = this.parseType(id);\n    const type = this.getType(id); //console.log("Type ",type)\n\n    if (!type) {\n      return;\n    }\n\n    var anchor = Y.createRelativePositionFromTypeIndex(type, from);\n    var head = Y.createRelativePositionFromTypeIndex(type, to);\n    if (debug) console.log("Sending Cursor ", {\n      anchor,\n      head\n    }, {\n      \'to\': to,\n      \'from\': from,\n      \'info.id\': info.id\n    });\n    this.docs[info.id].socket.awareness.setLocalStateField(\'cursor\', {\n      anchor,\n      head\n    });\n    /*\n    if(debug)\n    \tconsole.log("Cursor Send")\n    \t*/\n  } //send Position Custom\n\n\n  sendPosition(json) {\n    let collection = json[\'collection\'];\n    let document_id = json[\'document_id\'];\n    let name = json[\'name\'];\n    let from = json[\'startPosition\'];\n    let to = json[\'endPositon\'];\n    let id = this.generateID(config.organization_Id, collection, document_id, name);\n    this.setPositionYJS(id, from, to);\n  }\n\n  generateID(org, collection, document_id, name) {\n    const info = {\n      org,\n      collection,\n      document_id,\n      name\n    };\n    return btoa(JSON.stringify(info));\n  }\n\n  parseTypeName(name) {\n    const data = JSON.parse(atob(name));\n    return data;\n  }\n\n  parseType(id) {\n    let data = JSON.parse(atob(id));\n    let newId = {\n      org: data.org,\n      collection: data.collection,\n      document_id: data.document_id\n    };\n    return {\n      id: btoa(JSON.stringify(newId)),\n      name: data.name,\n      document_id: data.document_id\n    };\n  }\n\n}\n\nvar _default = CoCreateYSocket;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvc3JjL2NvcmUuanM/MTk5NyJdLCJuYW1lcyI6WyJkZWJ1ZyIsIkNvQ3JlYXRlWVNvY2tldCIsImNvbnN0cnVjdG9yIiwib3JnIiwieWRvYyIsImRvYyIsIm9yZ05hbWUiLCJkb2NzIiwiX2F3YXJlbmVzc0xpc3RlbmVyIiwiY2hhcmFjdGVyIiwibGlzdGVuQXdlcmVuZXNzIiwiY3JlYXRlRG9jIiwiaWQiLCJlbGVtZW50IiwibmV3SW5mbyIsInBhcnNlVHlwZSIsIm5ld0lkIiwiX19jaGVja0V4aXN0RWxlbWVudCIsImVsZW1lbnRzIiwicHVzaCIsInR5cGVzIiwic29tZSIsInR5cGUiLCJyZWdpc3RlclVwZGF0ZUV2ZW50IiwieURvYyIsInVybF9zb2NrZXQiLCJfX2dldFNvY2tldFVybCIsInNvY2tldFByb3ZpZGVyIiwiV2Vic29ja2V0UHJvdmlkZXIiLCJpbmRleGVkZGJQcm92aWRlciIsImRvY3VtZW50X2lkIiwiSW5kZXhlZGRiUGVyc2lzdGVuY2UiLCJ3aGVuU3luY2VkIiwidGhlbiIsImNvbnNvbGUiLCJsb2ciLCJhd2FyZW5lc3MiLCJfY3Vyc29ycyIsIk1hcCIsImV2ZW50IiwiZiIsImNsaWVudElkIiwiY2xpZW50SUQiLCJ1cGRhdGVSZW1vdGVTZWxlY3Rpb24iLCJnZXRUZXh0IiwiYWRkZWQiLCJmb3JFYWNoIiwicmVtb3ZlZCIsInVwZGF0ZWQiLCJvbiIsInNvY2tldCIsImluZGV4ZWRkYiIsImRvY09iamVjdCIsInNoYXJkVHlwZSIsIl90aGlzIiwib2JzZXJ2ZSIsIl9fc2V0VHlwZU9ic2VydmVFdmVudCIsImkiLCJsZW5ndGgiLCJpc1NhbWVOb2RlIiwid19sb2NhdGlvbiIsIndpbmRvdyIsImxvY2F0aW9uIiwicGFyZW50Iiwid19wcm90b2NvbCIsInByb3RvY29sIiwid19ob3N0IiwiaG9zdCIsImRvY3VtZW50IiwicmVmZXJyZXIiLCJjb25maWciLCJpbmNsdWRlcyIsImV2ZW50RGVsdGEiLCJkZWx0YSIsImluZm8iLCJKU09OIiwicGFyc2UiLCJhdG9iIiwiaXNfc2F2ZV92YWx1ZSIsIndob2xlc3RyaW5nIiwidGFyZ2V0IiwidG9TdHJpbmciLCJzdG9yZV9ldmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwidXBkYXRlX2V2ZW50IiwiZWwiLCJ1dGlscyIsImlzUmVhZFZhbHVlIiwiZ2V0QXR0cmlidXRlIiwibmFtZSIsImRpc3BhdGNoRXZlbnQiLCJ0cmFuc2FjdGlvbiIsImxvY2FsIiwiY3J1ZCIsInVwZGF0ZURvY3VtZW50IiwiY29sbGVjdGlvbiIsImRhdGEiLCJtZXRhZGF0YSIsImRlbGV0ZURvYyIsImdlbmVyYXRlRG9jTmFtZSIsImJ0b2EiLCJzdHJpbmdpZnkiLCJpbnNlcnREYXRhIiwiaW5kZXgiLCJjb250ZW50IiwiYXR0cmlidXRlIiwiaW5zZXJ0IiwiZGVsZXRlRGF0YSIsImRlbGV0ZSIsImdldFdob2xlU3RyaW5nIiwieSIsImNtIiwiY3Vyc29ycyIsIm0iLCJnZXQiLCJ1bmRlZmluZWQiLCJjYXJldCIsImNsZWFyIiwic2VsIiwiYXciLCJnZXRTdGF0ZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYXJyYXkiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJzZWxfZWxlbWVudHMiLCJzZWxfZWxlbWVudCIsInVzZXIiLCJjb2xvciIsImN1cnNvciIsImFuY2hvciIsImhlYWQiLCJZIiwiY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uIiwiY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OIiwiZnJvbSIsInRvIiwidF9pbmZvIiwicGFyc2VUeXBlTmFtZSIsImlkX21pcnJvciIsImpzb24iLCJzZWxlY3RvciIsInRoYXQiLCJzdGFydFBvc2l0aW9uIiwiZW5kUG9zaXRvbiIsIkNvQ3JlYXRlQ3Vyc29ycyIsImRyYXdfY3Vyc29yIiwibGlzdGVuIiwiY2hhbmdlTGlzdGVuQXdlcmVuZXNzIiwiY2FsbGJhY2siLCJhcHBseSIsImRlc3Ryb3lPYnNlcnZlciIsInVub2JzZXJ2ZSIsIm9mZiIsImdldFByb3ZpZGVyIiwiZ2V0VHlwZSIsInNldEN1cnNvck51bGwiLCJzZXRMb2NhbFN0YXRlRmllbGQiLCJzZXRQb3NpdGlvbllKUyIsImNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4Iiwic2VuZFBvc2l0aW9uIiwiZ2VuZXJhdGVJRCIsIm9yZ2FuaXphdGlvbl9JZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLE1BQU1BLEtBQUssR0FBRyxLQUFkOztBQUVBLE1BQU1DLGVBQU4sQ0FBc0I7QUFDckJDLGFBQVcsQ0FBQ0MsR0FBRCxFQUFNQyxJQUFOLEVBQVk7QUFDdEIsU0FBS0MsR0FBTCxHQUFXRCxJQUFYO0FBQ0EsU0FBS0UsT0FBTCxHQUFlSCxHQUFmO0FBQ0EsU0FBS0ksSUFBTCxHQUFZLEVBQVo7QUFDQSxTQUFLQyxrQkFBTCxHQUEwQixJQUExQjtBQUNBLFNBQUtDLFNBQUwsR0FBaUIsR0FBakI7O0FBQ0EsU0FBS0MsZUFBTCxHQUF1QixZQUFVLENBQUUsQ0FBbkM7QUFDQTs7QUFFREMsV0FBUyxDQUFDQyxFQUFELEVBQUtDLE9BQUwsRUFBYztBQUN0QixRQUFJLENBQUNELEVBQUQsSUFBT0EsRUFBRSxJQUFJLEVBQWpCLEVBQXFCO0FBQ3BCLGFBQU8sSUFBUDtBQUNBOztBQUVELFFBQUlFLE9BQU8sR0FBRyxLQUFLQyxTQUFMLENBQWVILEVBQWYsQ0FBZCxDQUxzQixDQU10QjtBQUNBOztBQUVBLFVBQU1JLEtBQUssR0FBR0YsT0FBTyxDQUFDRixFQUF0Qjs7QUFFQSxRQUFJLEtBQUtMLElBQUwsQ0FBVVMsS0FBVixDQUFKLEVBQXNCO0FBQ3JCLFVBQUlILE9BQU8sSUFBSSxDQUFDLEtBQUtJLG1CQUFMLENBQXlCLEtBQUtWLElBQUwsQ0FBVVMsS0FBVixFQUFpQkUsUUFBMUMsRUFBb0RMLE9BQXBELENB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QUNBOztBQUVEaUUsZUFBYSxDQUFDakQsSUFBRCxFQUFPO0FBQ25CLFVBQU1PLElBQUksR0FBR3RCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxJQUFJLENBQUNhLElBQUQsQ0FBZixDQUFiO0FBQ0EsV0FBT08sSUFBUDtBQUNBOztBQUVEbEYsV0FBUyxDQUFDSCxFQUFELEVBQUs7QUFDYixRQUFJcUYsSUFBSSxHQUFHdEIsSUFBSSxDQUFDQyxLQUFMLENBQVdDLElBQUksQ0FBQ2pFLEVBQUQsQ0FBZixDQUFYO0FBRUEsUUFBSUksS0FBSyxHQUFHO0FBQUNiLFNBQUcsRUFBRThGLElBQUksQ0FBQzlGLEdBQVg7QUFBZ0I2RixnQkFBVSxFQUFFQyxJQUFJLENBQUNELFVBQWpDO0FBQTZDbEUsaUJBQVcsRUFBRW1FLElBQUksQ0FBQ25FO0FBQS9ELEtBQVo7QUFDQSxXQUFPO0FBQ05sQixRQUFFLEVBQUV5RixJQUFJLENBQUMxQixJQUFJLENBQUMyQixTQUFMLENBQWV0RixLQUFmLENBQUQsQ0FERjtBQUVOMEUsVUFBSSxFQUFFTyxJQUFJLENBQUNQLElBRkw7QUFHTjVELGlCQUFXLEVBQUVtRSxJQUFJLENBQUNuRTtBQUhaLEtBQVA7QUFLQTs7QUEzYm9COztlQThiUDdCLGUiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY3JkdC9zcmMvY29yZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyBXZWJzb2NrZXRQcm92aWRlciB9IGZyb20gJ3ktd2Vic29ja2V0J1xuaW1wb3J0IHsgZmV0Y2hVcGRhdGVzLCBzdG9yZVN0YXRlLCBJbmRleGVkZGJQZXJzaXN0ZW5jZSB9IGZyb20gJ3ktaW5kZXhlZGRiJ1xuaW1wb3J0IHtjcnVkLCB1dGlsc30gZnJvbSAnLi4vLi4vLi4vQ29DcmVhdGVKUy9zcmMnO1xuaW1wb3J0IENvQ3JlYXRlQ3Vyc29ycyBmcm9tICcuLi8uLi9Db0NyZWF0ZS1jdXJzb3JzL3NyYydcblxuY29uc3QgZGVidWcgPSBmYWxzZTtcblxuY2xhc3MgQ29DcmVhdGVZU29ja2V0IHtcblx0Y29uc3RydWN0b3Iob3JnLCB5ZG9jKSB7XG5cdFx0dGhpcy5kb2MgPSB5ZG9jO1xuXHRcdHRoaXMub3JnTmFtZSA9IG9yZztcblx0XHR0aGlzLmRvY3MgPSB7fTtcblx0XHR0aGlzLl9hd2FyZW5lc3NMaXN0ZW5lciA9IG51bGw7XG5cdFx0dGhpcy5jaGFyYWN0ZXIgPSAnXyc7XG5cdFx0dGhpcy5saXN0ZW5Bd2VyZW5lc3MgPSBmdW5jdGlvbigpe31cblx0fVxuXHRcblx0Y3JlYXRlRG9jKGlkLCBlbGVtZW50KSB7XG5cdFx0aWYgKCFpZCB8fCBpZCA9PSBcIlwiKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0bGV0IG5ld0luZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHQvLyBpZihkZWJ1Zylcblx0XHQvLyBcdGNvbnNvbGUubG9nKG5ld0luZm8pO1xuXHRcdFxuXHRcdGNvbnN0IG5ld0lkID0gbmV3SW5mby5pZDtcblx0XHRcblx0XHRpZiAodGhpcy5kb2NzW25ld0lkXSkgeyBcblx0XHRcdGlmIChlbGVtZW50ICYmICF0aGlzLl9fY2hlY2tFeGlzdEVsZW1lbnQodGhpcy5kb2NzW25ld0lkXS5lbGVtZW50cywgZWxlbWVudCkpIHtcblx0XHRcdFx0dGhpcy5kb2NzW25ld0lkXS5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuZG9jc1tuZXdJZF0udHlwZXMuc29tZSgodHlwZSkgPT4gdHlwZSA9PT0gaWQpKSB7XG5cdFx0XHRcdC8vIHJlZ2lzdGVyIGV2ZW50XG5cdFx0XHRcdHRoaXMuZG9jc1tuZXdJZF0udHlwZXMucHVzaChpZCk7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJVcGRhdGVFdmVudCh0aGlzLmRvY3NbbmV3SWRdLCBpZClcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBcblx0XHRcblx0XHRjb25zdCB5RG9jID0gdGhpcy5kb2Ncblx0XHRcblx0XHRjb25zdCB1cmxfc29ja2V0ID0gdGhpcy5fX2dldFNvY2tldFVybCgpO1xuXHRcdC8vZHJhdyBjdXJzb3IgZGluYW1pYWxseVxuXHRcdC8vIG5ldyBVc2VyQ3Vyc29yKHNvY2tldFByb3ZpZGVyKTtcblxuXHRcdFx0XG5cdFx0dmFyIHNvY2tldFByb3ZpZGVyID0gbmV3IFdlYnNvY2tldFByb3ZpZGVyKHVybF9zb2NrZXQsIG5ld0lkLCB5RG9jKTtcblx0XHRsZXQgaW5kZXhlZGRiUHJvdmlkZXIgPSBudWxsO1xuXHRcdGlmIChuZXdJbmZvLmRvY3VtZW50X2lkICE9IFwibnVsbFwiKSB7XG5cdFx0XHRpbmRleGVkZGJQcm92aWRlciA9IG5ldyBJbmRleGVkZGJQZXJzaXN0ZW5jZShuZXdJZCwgdGhpcy5kb2MpXG5cdFx0XHRpbmRleGVkZGJQcm92aWRlci53aGVuU3luY2VkLnRoZW4oKCkgPT4ge1xuXHRcdFx0ICBjb25zb2xlLmxvZygnbG9hZGVkIGRhdGEgZnJvbSBpbmRleGVkIGRiJylcblx0XHRcdH0pXG5cdFx0fVx0XG5cdFx0XG5cdFx0bGV0IGF3YXJlbmVzcyA9IHNvY2tldFByb3ZpZGVyLmF3YXJlbmVzcztcblx0XHRcblx0XHR0aGlzLl9jdXJzb3JzID0gbmV3IE1hcCgpO1xuXHRcdFxuXHRcdHRoaXMuX2F3YXJlbmVzc0xpc3RlbmVyID0gZXZlbnQgPT4ge1xuXHRcdCAgY29uc3QgZiA9IGNsaWVudElkID0+IHtcblx0XHRcdGlmIChjbGllbnRJZCAhPT0gdGhpcy5kb2MuY2xpZW50SUQpIHtcblx0XHRcdCAgdGhpcy51cGRhdGVSZW1vdGVTZWxlY3Rpb24oeURvYywgaWQsIHlEb2MuZ2V0VGV4dChpZCksIHRoaXMuX2N1cnNvcnMsIGNsaWVudElkLCBhd2FyZW5lc3MpXG5cdFx0XHR9XG5cdFx0ICB9XG5cdFx0ICBldmVudC5hZGRlZC5mb3JFYWNoKGYpXG5cdFx0ICBldmVudC5yZW1vdmVkLmZvckVhY2goZilcblx0XHQgIGV2ZW50LnVwZGF0ZWQuZm9yRWFjaChmKVxuXHRcdH1cblx0XHRcblx0XHRhd2FyZW5lc3Mub24oJ2NoYW5nZScsIHRoaXMuX2F3YXJlbmVzc0xpc3RlbmVyKTtcblx0XHQvKlxuXHRcdGF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5mb3JFYWNoKChhdywgY2xpZW50SWQpID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKFwiVXBkYXRlIC0tXCIpXG4gICAgICAgIH0pXG4gICAgICAgICovXG4gICAgICAgIFxuICAgICAgICB0aGlzLmRvY3NbbmV3SWRdID0ge1xuXHRcdFx0aWQ6IG5ld0lkLFxuXHRcdFx0ZG9jOiB5RG9jLFxuXHRcdFx0c29ja2V0OiBzb2NrZXRQcm92aWRlcixcblx0XHRcdGF3YXJlbmVzczogYXdhcmVuZXNzLFxuXHRcdFx0ZWxlbWVudHM6IGVsZW1lbnQgPyBbZWxlbWVudF0gOiBbXSxcblx0XHRcdHR5cGVzOiBbaWRdLFxuXHRcdFx0aW5kZXhlZGRiOiBpbmRleGVkZGJQcm92aWRlclxuXHRcdH1cblx0XHR0aGlzLnJlZ2lzdGVyVXBkYXRlRXZlbnQodGhpcy5kb2NzW25ld0lkXSwgaWQpXG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRcblx0cmVnaXN0ZXJVcGRhdGVFdmVudChkb2NPYmplY3QsIGlkKSB7XG5cdFx0Y29uc3QgeURvYyA9IGRvY09iamVjdC5kb2M7XG5cdFx0Y29uc3Qgc2hhcmRUeXBlID0geURvYy5nZXRUZXh0KGlkKVxuXHRcdGxldCBfdGhpcyA9IHRoaXM7XG5cdFx0XG5cdFx0c2hhcmRUeXBlLm9ic2VydmUoKGV2ZW50KSA9PiB7XG5cdFx0XHRfdGhpcy5fX3NldFR5cGVPYnNlcnZlRXZlbnQoZXZlbnQsIGRvY09iamVjdC5lbGVtZW50cywgaWQpO1xuXHRcdH0pXG5cdH1cblx0XG5cdF9fY2hlY2tFeGlzdEVsZW1lbnQoZWxlbWVudHMsIGVsZW1lbnQpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZWxlbWVudHNbaV0uaXNTYW1lTm9kZShlbGVtZW50KSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxuXHRfX2dldFNvY2tldFVybCgpIHtcblx0XHRjb25zb2xlLmxvZyhcImdldF9zb2NrZXQgdXJsXCIpXG5cdFx0bGV0IHdfbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24gfHwgd2luZG93LnBhcmVudC5sb2NhdGlvbjtcblx0XHRsZXQgd19wcm90b2NvbCA9IHdfbG9jYXRpb24ucHJvdG9jb2w7XG5cdFx0bGV0IHdfaG9zdCA9IHdfbG9jYXRpb24uaG9zdDtcblx0XHRpZiAod19sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJhYm91dDpcIikge1xuXHRcdFx0d19wcm90b2NvbCA9IHdfbG9jYXRpb24ucHJvdG9jb2w7XG5cdFx0XHR3X2hvc3QgPSBkb2N1bWVudC5yZWZlcnJlcjtcblx0XHR9XG5cdFx0bGV0IHByb3RvY29sID0gd19wcm90b2NvbCA9PT0gJ2h0dHA6JyA/ICd3cycgOiAnd3NzJztcblxuXHRcdGxldCB1cmxfc29ja2V0ID0gYCR7cHJvdG9jb2x9Oi8vJHt3X2hvc3R9OjgwODAvYDtcblx0XHRpZiAod2luZG93LmNvbmZpZyAmJiB3aW5kb3cuY29uZmlnLmhvc3QpIHtcblx0XHRcdGlmICh3aW5kb3cuY29uZmlnLmhvc3QuaW5jbHVkZXMoXCI6Ly9cIikpIHtcblx0XHRcdFx0dXJsX3NvY2tldCA9IGAke3dpbmRvdy5jb25maWcuaG9zdH0vYDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVybF9zb2NrZXQgPSBgJHtwcm90b2NvbH06Ly8ke3dpbmRvdy5jb25maWcuaG9zdH0vYDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Y29uc29sZS5sb2codXJsX3NvY2tldClcblx0XHR1cmxfc29ja2V0ICs9IFwiY3JkdC9cIjtcblx0XHRcblx0XHRyZXR1cm4gdXJsX3NvY2tldDtcblxuXHR9XG5cdFxuXHRfX3NldFR5cGVPYnNlcnZlRXZlbnQoZXZlbnQsIGVsZW1lbnRzLCBpZCkge1xuXHRcdGlmICghaWQpIHJldHVybjtcblxuXHRcdGNvbnN0IGV2ZW50RGVsdGEgPSBldmVudC5kZWx0YTtcblx0XHRjb25zdCBpbmZvID0gSlNPTi5wYXJzZShhdG9iKGlkKSk7XG5cdFx0bGV0IGlzX3NhdmVfdmFsdWUgPSBmYWxzZVxuXHRcdFxuXHRcdGNvbnN0IHdob2xlc3RyaW5nID0gZXZlbnQudGFyZ2V0LnRvU3RyaW5nKClcblx0XHRjb25zdCBzdG9yZV9ldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc3RvcmUtY29udGVudC1kYicsIHtcblx0XHRcdGRldGFpbDogd2hvbGVzdHJpbmdcblx0XHR9KVxuXHRcdFxuXHRcdGNvbnN0IHVwZGF0ZV9ldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29jcmVhdGUteS11cGRhdGUnLCB7XG5cdFx0XHRkZXRhaWw6IGV2ZW50RGVsdGFcblx0XHR9KVxuXHRcdGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRpZiAodXRpbHMuaXNSZWFkVmFsdWUoZWwpICYmIGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpID09PSBpbmZvLm5hbWUpIHtcblx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudCh1cGRhdGVfZXZlbnQpXG5cdFx0XHR9XG5cdFx0fSlcblx0XHRcdFxuXHRcdFxuXHRcdGlmICh0eXBlb2YgaW5mbyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQudHJhbnNhY3Rpb24ubG9jYWwpIHtcblx0XHRcdGlmIChlbGVtZW50cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRpc19zYXZlX3ZhbHVlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2F2ZV92YWx1ZScpICE9ICdmYWxzZScgJiYgZWwuZ2V0QXR0cmlidXRlKCduYW1lJykgPT09IGluZm8ubmFtZSAmJiBpbmZvLmRvY3VtZW50X2lkICE9IFwibnVsbFwiKSB7XG5cdFx0XHRcdFx0aXNfc2F2ZV92YWx1ZSA9IHRydWU7XG5cdFx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChzdG9yZV9ldmVudClcblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHRcdFx0aWYgKGlzX3NhdmVfdmFsdWUpIHtcblx0XHRcdFx0Y3J1ZC51cGRhdGVEb2N1bWVudCh7XG5cdFx0XHRcdFx0Y29sbGVjdGlvbjogaW5mby5jb2xsZWN0aW9uLFxuXHRcdFx0XHRcdGRvY3VtZW50X2lkOiBpbmZvLmRvY3VtZW50X2lkLFxuXHRcdFx0XHRcdGRhdGE6IHtcblx0XHRcdFx0XHRcdFtpbmZvLm5hbWVdOiB3aG9sZXN0cmluZ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bWV0YWRhdGE6ICd5anMtY2hhbmdlJ1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHR9XG5cdH1cblx0XG5cdGRlbGV0ZURvYyhpZCkge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAodGhpcy5kb2NzW2luZm8uaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5kb2NzW2luZm8uaWRdO1xuXHRcdH1cblx0fVxuXHRcblx0Z2VuZXJhdGVEb2NOYW1lKGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lKSB7XG5cdFx0Y29uc3QgaW5mbyA9IHtvcmc6IHRoaXMub3JnTmFtZSwgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWV9XG5cdFx0cmV0dXJuIGJ0b2EoSlNPTi5zdHJpbmdpZnkoaW5mbykpOyBcblx0XHQvLyByZXR1cm4gdGhpcy5vcmdOYW1lICsgXCJfXCIgKyBjb2xsZWN0aW9uICsgXCJfXCIgKyBkb2N1bWVudF9pZCArIFwiX1wiICsgbmFtZTtcblx0fVxuXHRcblx0aW5zZXJ0RGF0YShpZCwgaW5kZXgsIGNvbnRlbnQsIGF0dHJpYnV0ZSkge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAodGhpcy5kb2NzW2luZm8uaWRdKSB7XG5cdFx0XHRpZiAoYXR0cmlidXRlKSB7XG5cdFx0XHRcdHRoaXMuZG9jc1tpbmZvLmlkXS5kb2MuZ2V0VGV4dChpZCkuaW5zZXJ0KGluZGV4LCBjb250ZW50LCBhdHRyaWJ1dGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuZG9jc1tpbmZvLmlkXS5kb2MuZ2V0VGV4dChpZCkuaW5zZXJ0KGluZGV4LCBjb250ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdGRlbGV0ZURhdGEoaWQsIGluZGV4LCBsZW5ndGgpIHtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0aWYgKHRoaXMuZG9jc1tpbmZvLmlkXSkge1xuXHRcdFx0dGhpcy5kb2NzW2luZm8uaWRdLmRvYy5nZXRUZXh0KGlkKS5kZWxldGUoaW5kZXgsIGxlbmd0aCk7XG5cdFx0fVxuXHR9XG5cdFxuXHRnZXRXaG9sZVN0cmluZyhpZCkge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAodGhpcy5kb2NzW2luZm8uaWRdKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIiFHZXQgZGF0YVwiKVxuXHRcdFx0cmV0dXJuIHRoaXMuZG9jc1tpbmZvLmlkXS5kb2MuZ2V0VGV4dChpZCkudG9TdHJpbmcoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwiLS1cIjtcblx0XHR9XG5cdH1cblx0XG5cdHVwZGF0ZVJlbW90ZVNlbGVjdGlvbiAoeSwgY20sIHR5cGUsIGN1cnNvcnMsIGNsaWVudElkLCBhd2FyZW5lc3MpICB7XG5cdFx0aWYoZGVidWcpXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiQ0hBTkdFIC0tLS0gRE9DSUQgXCIsdGhpcy5kb2MuY2xpZW50SUQsJyBPVEhFUiBDTElFTlRFSUQgJyxjbGllbnRJZClcblx0XHRpZihjbGllbnRJZCAhPT0gdGhpcy5kb2MuY2xpZW50SUQpe1xuXHRcdFx0XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIlRFWFQgLT4gdXBkYXRlUmVtb3RlU2VsZWN0aW9uIFwiLGNsaWVudElkLGF3YXJlbmVzcyxjdXJzb3IpXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkFXIHN0YXR1c1wiLGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkpXG5cdFx0XHRcdFx0ICAvLyBkZXN0cm95IGN1cnJlbnQgdGV4dCBtYXJrXG5cdFx0XHRcdFx0ICBjb25zdCBtID0gY3Vyc29ycy5nZXQoY2xpZW50SWQpXG5cdFx0XHRcdFx0ICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRtLmNhcmV0LmNsZWFyKClcblx0XHRcdFx0XHRcdGlmIChtLnNlbCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ICBtLnNlbC5jbGVhcigpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJzb3JzLmRlbGV0ZShjbGllbnRJZClcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHQgIC8vIHJlZHJhdyBjYXJldCBhbmQgc2VsZWN0aW9uIGZvciBjbGllbnRJZFxuXHRcdFx0XHRcdCAgY29uc3QgYXcgPSBhd2FyZW5lc3MuZ2V0U3RhdGVzKCkuZ2V0KGNsaWVudElkKTtcblx0XHRcdFx0XHQgIGlmKGRlYnVnKVxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYXcpXG5cdFx0XHRcdFx0ICBpZiAoYXcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0ICBpZihkZWJ1Zylcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCIgQ3Vyc29yIE9VVCBcIixjbGllbnRJZClcblx0XHRcdFx0XHRcdCAgIC8vYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgnY3Vyc29yJywgbnVsbCk7XG5cdFx0XHRcdFx0XHQgICBsZXQgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWQqPVwic29ja2V0XycrY2xpZW50SWQrJ1wiXScpO1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRsZXQgc2VsX2VsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkKj1cInNlbC0nK2NsaWVudElkKydcIl0nKTtcblx0XHRcdFx0XHRcdFx0ICBzZWxfZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VsX2VsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuXHRcdFx0XHRcdFx0XHRcdHNlbF9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsX2VsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0ICAvKlxuXHRcdFx0XHRcdFx0ICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvY2tldF9cIitjbGllbnRJZClcblx0XHRcdFx0XHRcdCAgIGxldCBzZWxfZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VsLVwiK2NsaWVudElkKVxuXHRcdFx0XHRcdFx0ICAgaWYoZWxlbWVudClcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHRpZihzZWxfZWxlbWVudClcblx0XHRcdFx0XHRcdFx0c2VsX2VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxfZWxlbWVudCk7XG5cdFx0XHRcdFx0XHQgICAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICBjb25zdCB1c2VyID0gYXcudXNlciB8fCB7fVxuXHRcdFx0XHRcdCAgaWYgKHVzZXIuY29sb3IgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dXNlci5jb2xvciA9ICcjZmZhNTAwJ1xuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdCAgaWYgKHVzZXIubmFtZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR1c2VyLm5hbWUgPSBgVXNlcjogJHtjbGllbnRJZH1gXG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICBjb25zdCBjdXJzb3IgPSBhdy5jdXJzb3Jcblx0XHRcdFx0XHQgIGlmKGRlYnVnKVxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJDdXJzb3IgXCIsY3Vyc29yKVxuXHRcdFx0XHRcdCAgaWYgKGN1cnNvciA9PSBudWxsIHx8IGN1cnNvci5hbmNob3IgPT0gbnVsbCB8fCBjdXJzb3IuaGVhZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHQgIC8vbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvY2tldF9cIitjbGllbnRJZClcblx0XHRcdFx0XHRcdCAgbGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkKj1cInNvY2tldF8nK2NsaWVudElkKydcIl0nKTtcblx0XHRcdFx0XHRcdCAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0XHRcdFx0XHRcdCAgfSlcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly9sZXQgc2VsX2VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlbC1cIitjbGllbnRJZCkgIFxuXHRcdFx0XHRcdFx0bGV0IHNlbF9lbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZCo9XCJzZWwtJytjbGllbnRJZCsnXCJdJyk7XG5cdFx0XHRcdFx0XHQgIHNlbF9lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxfZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG5cdFx0XHRcdFx0XHRcdHNlbF9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsX2VsZW1lbnQpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcblx0XHRcdFx0XHQgIGNvbnN0IGFuY2hvciA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnNvci5hbmNob3IpLCB5KVxuXHRcdFx0XHRcdCAgY29uc3QgaGVhZCA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnNvci5oZWFkKSwgeSlcblx0XHRcdFx0XHQgIC8vQ29DcmVhdGUuY3Vyc29ycy5kcmF3X2N1cnNvcigxLDExLDEyLDY2LHt9LHRydWUpO1xuXHRcdFx0XHRcdCAgaWYoZGVidWcpe1xuXHRcdFx0XHRcdFx0ICBjb25zb2xlLmxvZyhcIlBSRSBEcmF3IEN1cnNvciBcIilcblx0XHRcdFx0XHRcdCAgY29uc29sZS5sb2coXCJhbmNob3IgIFwiLGFuY2hvciAsIFwiIGhlYWQgXCIsaGVhZCwnIFR5cGUgJyx0eXBlKVxuXHRcdFx0XHRcdFx0ICBjb25zb2xlLmxvZyhcImFuY2hvciAgVHlwZVwiLGFuY2hvci50eXBlID09PSB0eXBlKVxuXHRcdFx0XHRcdFx0ICBjb25zb2xlLmxvZyhcImFuY2hvciAgVHlwZVwiLGhlYWQudHlwZSA9PT0gdHlwZSlcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHQgIC8vaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBoZWFkICE9PSBudWxsICYmIGFuY2hvci50eXBlID09PSB0eXBlICYmIGhlYWQudHlwZSA9PT0gdHlwZSkge1xuXHRcdFx0XHRcdCAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBoZWFkICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bGV0IGZyb20sIHRvO1xuXHRcdFx0XHRcdFx0aWYgKGhlYWQuaW5kZXggPCBhbmNob3IuaW5kZXgpIHtcblx0XHRcdFx0XHRcdCAgZnJvbSA9IGhlYWQuaW5kZXhcblx0XHRcdFx0XHRcdCAgdG8gPSBhbmNob3IuaW5kZXhcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmKGRlYnVnKVxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGFuY2hvci5pbmRleClcblx0XHRcdFx0XHRcdCAgZnJvbSA9IGFuY2hvci5pbmRleFxuXHRcdFx0XHRcdFx0ICB0byA9IGhlYWQuaW5kZXhcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGRlYnVnKVxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkRyYXcgQ3Vyc29yIFwiLGZyb20sdG8sY2xpZW50SWQsYXcudXNlcilcblx0XHRcdFx0XHRcdGxldCB0X2luZm8gPSB0aGlzLnBhcnNlVHlwZU5hbWUoY3Vyc29yLmFuY2hvclsndG5hbWUnXSk7XG5cdFx0XHRcdFx0XHRsZXQgaWRfbWlycm9yID0gdF9pbmZvLmRvY3VtZW50X2lkICsgdF9pbmZvLm5hbWUrJy0tbWlycm9yLWRpdic7XG5cdFx0XHRcdFx0XHRsZXQganNvbiA9IHt9O1xuXHRcdFx0XHRcdFx0bGV0IHNlbGVjdG9yID0gJ1tkYXRhLWNvbGxlY3Rpb249XCInK3RfaW5mby5jb2xsZWN0aW9uKydcIl1bZGF0YS1kb2N1bWVudF9pZD1cIicrdF9pbmZvLmRvY3VtZW50X2lkKydcIl1bbmFtZT1cIicrdF9pbmZvLm5hbWUrJ1wiXSdcblx0XHRcdFx0XHRcdHNlbGVjdG9yICs9ICc6bm90KC5jb2RlbWlycm9yKTpub3QoLnF1aWxsKTpub3QoLm1vbmFjbyknO1xuXHRcdFx0XHRcdFx0bGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdFx0XHRcdFx0XHRsZXQgdGhhdCA9IHRoaXM7XG5cdFx0XHRcdFx0XHRlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0anNvbiA9IHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50OmVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRQb3NpdGlvbjpmcm9tLFxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdG9yOnNlbGVjdG9yLFxuXHRcdFx0XHRcdFx0XHRcdGVuZFBvc2l0b246dG8sXG5cdFx0XHRcdFx0XHRcdFx0Y2xpZW50SWQgOiBjbGllbnRJZCxcblx0XHRcdFx0XHRcdFx0XHR1c2VyOntcblx0XHRcdFx0XHRcdFx0XHRcdCdjb2xvcic6dXNlci5jb2xvcixcblx0XHRcdFx0XHRcdFx0XHRcdCduYW1lJzp1c2VyLm5hbWVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGpzb24pXG5cdFx0XHRcdFx0XHRcdENvQ3JlYXRlQ3Vyc29ycy5kcmF3X2N1cnNvcihqc29uKTtcblx0XHRcdFx0XHRcdFx0Ly9zZW50IGN1c3RvbSBwb3NpdGlvblxuXHRcdFx0XHRcdFx0XHR0aGF0Lmxpc3Rlbihqc29uKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdCAgfVxuXHRcdH1cblx0fVxuXHRcblx0Y2hhbmdlTGlzdGVuQXdlcmVuZXNzKGNhbGxiYWNrKXtcblx0XHR0aGlzLmxpc3RlbkF3ZXJlbmVzcyA9IGNhbGxiYWNrO1xuXHR9XG5cdFxuXHRsaXN0ZW4oanNvbil7XG5cdFx0dGhpcy5saXN0ZW5Bd2VyZW5lc3MuYXBwbHkodGhpcyxbanNvbl0pXG5cdH1cblx0XG5cdGRlc3Ryb3lPYnNlcnZlcihpZCwgZWxlbWVudCkge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHR0aGlzLmRvY3NbaW5mby5pZF0uZG9jLmdldFRleHQoaWQpLnVub2JzZXJ2ZSgoZXZlbnQpID0+IHt9KTtcblx0XHRcblx0XHR0aGlzLmRvY3NbaW5mby5pZF0uc29ja2V0LmF3YXJlbmVzcy5vZmYoJ2NoYW5nZScsIHRoaXMuX2F3YXJlbmVzc0xpc3RlbmVyKTtcblx0fVxuXHRcblx0Z2V0UHJvdmlkZXIoaWQpe1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAoIXRoaXMuZG9jc1tpbmZvLmlkXSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmRvY3NbaW5mby5pZF0uc29ja2V0O1xuXHR9XG5cdFxuXHRnZXRUeXBlKGlkKXtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0aWYgKCF0aGlzLmRvY3NbaW5mby5pZF0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5kb2NzW2luZm8uaWRdLmRvYy5nZXRUZXh0KGlkKTtcblx0fVxuXG5cdHNldEN1cnNvck51bGwoaWQpe1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRpZiAoIXRoaXMuZG9jc1tpbmZvLmlkXSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuZG9jc1tpbmZvLmlkXS5zb2NrZXQuYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgnY3Vyc29yJywgbnVsbCk7XG5cdH1cblx0XG5cdHNldFBvc2l0aW9uWUpTKGlkLCBmcm9tLCB0bykge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLnBhcnNlVHlwZShpZClcblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGlkKTtcblx0XHQvL2NvbnNvbGUubG9nKFwiVHlwZSBcIix0eXBlKVxuXHRcdGlmICghdHlwZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgYW5jaG9yID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCBmcm9tKVxuXHRcdHZhciBoZWFkID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCB0bylcblx0XHRcblx0XHRpZihkZWJ1Zylcblx0XHRcdGNvbnNvbGUubG9nKFwiU2VuZGluZyBDdXJzb3IgXCIse1xuXHRcdFx0XHRhbmNob3IsXG5cdFx0XHRcdGhlYWRcblx0XHRcdH0seyd0byc6dG8sJ2Zyb20nOmZyb20sJ2luZm8uaWQnOmluZm8uaWR9KVxuXHRcdFxuXHRcdHRoaXMuZG9jc1tpbmZvLmlkXS5zb2NrZXQuYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgnY3Vyc29yJywge1xuXHRcdFx0YW5jaG9yLFxuXHRcdFx0aGVhZFxuXHRcdH0pXG5cdFx0Lypcblx0XHRpZihkZWJ1Zylcblx0XHRcdGNvbnNvbGUubG9nKFwiQ3Vyc29yIFNlbmRcIilcblx0XHRcdCovXG5cdH1cblx0XG5cdC8vc2VuZCBQb3NpdGlvbiBDdXN0b21cblx0c2VuZFBvc2l0aW9uKGpzb24pIHtcblx0XHRsZXQgY29sbGVjdGlvbiA9IGpzb25bJ2NvbGxlY3Rpb24nXTtcblx0XHRsZXQgZG9jdW1lbnRfaWQgPSBqc29uWydkb2N1bWVudF9pZCddO1xuXHRcdGxldCBuYW1lID0ganNvblsnbmFtZSddO1xuXHRcdGxldCBmcm9tID0ganNvblsnc3RhcnRQb3NpdGlvbiddO1xuXHRcdGxldCB0byA9IGpzb25bJ2VuZFBvc2l0b24nXTtcblx0XHRsZXQgaWQgPSB0aGlzLmdlbmVyYXRlSUQoY29uZmlnLm9yZ2FuaXphdGlvbl9JZCwgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUpO1xuXHRcdHRoaXMuc2V0UG9zaXRpb25ZSlMoaWQsZnJvbSx0byk7XG5cdH1cblx0XG5cdGdlbmVyYXRlSUQob3JnLCBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSkge1xuXHRcdGNvbnN0IGluZm8gPSB7b3JnLCBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZX1cblx0XHRyZXR1cm4gYnRvYShKU09OLnN0cmluZ2lmeShpbmZvKSk7ICAgICAgICBcblx0fVxuXHRcblx0cGFyc2VUeXBlTmFtZShuYW1lKSB7XG5cdFx0Y29uc3QgZGF0YSA9IEpTT04ucGFyc2UoYXRvYihuYW1lKSk7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblx0XG5cdHBhcnNlVHlwZShpZCkge1xuXHRcdGxldCBkYXRhID0gSlNPTi5wYXJzZShhdG9iKGlkKSk7XG5cdFx0XG5cdFx0bGV0IG5ld0lkID0ge29yZzogZGF0YS5vcmcsIGNvbGxlY3Rpb246IGRhdGEuY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQ6IGRhdGEuZG9jdW1lbnRfaWR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlkOiBidG9hKEpTT04uc3RyaW5naWZ5KG5ld0lkKSksXG5cdFx0XHRuYW1lOiBkYXRhLm5hbWUsXG5cdFx0XHRkb2N1bWVudF9pZDogZGF0YS5kb2N1bWVudF9pZFxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb0NyZWF0ZVlTb2NrZXQ7XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/src/core.js\n')},"../CoCreate-crdt/src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _core = _interopRequireDefault(__webpack_require__(/*! ./core.js */ \"../CoCreate-crdt/src/core.js\"));\n\nvar Y = _interopRequireWildcard(__webpack_require__(/*! yjs */ \"../CoCreate-crdt/node_modules/yjs/dist/yjs.mjs\"));\n\nvar _src = __webpack_require__(/*! ../../../CoCreateJS/src */ \"../../CoCreateJS/src/index.js\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass CoCreateCRDTClass extends _core.default {\n  constructor(org, doc) {\n    super(org, doc);\n  }\n  /*\n  crdt.init({\n    collection: \"module\",\n    document_id: \"\",\n    name: \"\",\n    element: dom_object,\n    metadata: \"xxxx\"\n  })\n  */\n\n\n  init(info) {\n    try {\n      this.__validateKeysJson(info, ['collection', 'document_id', 'name']);\n\n      const id = this.__getYDocId(info['collection'], info['document_id'], info['name']);\n\n      if (!id) return;\n      const status = this.createDoc(id, info.element);\n      console.log(\"InitCrdt\");\n    } catch (e) {\n      console.log('Invalid param', e);\n    }\n  }\n  /*. init data function\n  crdt.replaceText({\n    collection: \"module\",\n    document_id: \"\",\n    name: \"\",\n    value: \"\",\n    updateCrud: true | false,\n    element: dom_object,\n    metadata: \"xxxx\"\n  })\n  */\n\n\n  replaceText(info) {\n    if (!info) return;\n\n    const id = this.__getYDocId(info.collection, info.document_id, info.name);\n\n    if (!id) return;\n    if (info.updateCrud != false) info.updateCrud = true;\n\n    if (this.getType(id)) {\n      let oldData = this.getType(id).toString();\n      let textValue = info.value.toString();\n\n      if (oldData && oldData.length > 0) {\n        this.deleteData(id, 0, Math.max(oldData.length, textValue.length));\n      }\n\n      this.insertData(id, 0, textValue);\n    }\n\n    if (info.updateCrud) {\n      _src.crud.updateDocument({\n        collection: info.collection,\n        document_id: info.document_id,\n        data: {\n          [info.name]: info.value\n        },\n        element: info.element,\n        metadata: info.metadata,\n        namespace: info.namespace,\n        room: info.room,\n        broadcast: info.broadcast,\n        upsert: info.upsert,\n        broadcast_sender: info.broadcast_sender\n      });\n    }\n  }\n  /*\n  crdt.insertText({\n  \tcollection: 'module_activities',\n  \tdocument_id: '5e4802ce3ed96d38e71fc7e5',\n  \tname: 'name',\n  \tvalue: 'T',\n  \tposition: '8',\n  \tattributes: {bold: true}\n  })\n  */\n\n\n  insertText(info) {\n    try {\n      this.__validateKeysJson(info, ['collection', 'document_id', 'name', 'value', 'position']);\n\n      let id = this.__getYDocId(info['collection'], info['document_id'], info['name']);\n\n      if (id) {\n        this.insertData(id, info['position'], info['value'].toString(), info['attributes']);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  /*\n  crdt.deleteText({\n  \tcollection: 'module_activities',\n  \tdocument_id: '5e4802ce3ed96d38e71fc7e5',\n  \tname: 'name',\n  \tposition: '8',\n  \tlength: 2,\n  })\n  */\n\n\n  deleteText(info) {\n    try {\n      this.__validateKeysJson(info, ['collection', 'document_id', 'name', 'position', 'length']);\n\n      let id = this.__getYDocId(info['collection'], info['document_id'], info['name']);\n\n      if (id) {\n        this.deleteData(id, info['position'], info['length']);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  /*\n  crdt.getText({\n  \tcollection: 'module_activities',\n  \tdocument_id: '5e4802ce3ed96d38e71fc7e5',\n  \tname: 'name'\n  })\n  */\n\n\n  getText(info) {\n    try {\n      this.__validateKeysJson(info, ['collection', 'document_id', 'name']);\n\n      let id = this.__getYDocId(info['collection'], info['document_id'], info['name']);\n\n      if (id) {\n        return this.getWholeString(id);\n      } else {\n        return \"\";\n      }\n    } catch (e) {\n      console.error(e);\n      return \"\";\n    }\n  }\n  /* \n  crdt.getPosition(function(data))\n  crdt.getPosition(function(data){console.log(\" EScuchando ahora  \",data)})\n  */\n\n\n  getPosition(callback) {\n    if (typeof miFuncion === 'function') this.changeListenAwereness(callback);else console.error('Callback should be a function');\n  }\n\n  __getYDocId(collection, document_id, name) {\n    if (!_src.utils.checkValue(collection) || !_src.utils.checkValue(document_id) || !_src.utils.checkValue(name)) {\n      return null;\n    }\n\n    return this.generateID(config.organization_Id, collection, document_id, name);\n  }\n\n  __validateKeysJson(json, rules) {\n    let keys_json = Object.keys(json);\n    keys_json.forEach(key => {\n      const index = rules.indexOf(key);\n      if (index != -1) rules.splice(index, 1);\n    });\n    if (rules.length) throw \"Requires the following \" + rules.toString();\n  }\n\n}\n\nconst g_yDoc = new Y.Doc();\nlet CoCreateCrdt = new CoCreateCRDTClass(config.organization_Id, g_yDoc);\nwindow.Y = Y;\nvar _default = CoCreateCrdt;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWNyZHQvc3JjL2luZGV4LmpzPzY0MDAiXSwibmFtZXMiOlsiQ29DcmVhdGVDUkRUQ2xhc3MiLCJDb0NyZWF0ZVlTb2NrZXQiLCJjb25zdHJ1Y3RvciIsIm9yZyIsImRvYyIsImluaXQiLCJpbmZvIiwiX192YWxpZGF0ZUtleXNKc29uIiwiaWQiLCJfX2dldFlEb2NJZCIsInN0YXR1cyIsImNyZWF0ZURvYyIsImVsZW1lbnQiLCJjb25zb2xlIiwibG9nIiwiZSIsInJlcGxhY2VUZXh0IiwiY29sbGVjdGlvbiIsImRvY3VtZW50X2lkIiwibmFtZSIsInVwZGF0ZUNydWQiLCJnZXRUeXBlIiwib2xkRGF0YSIsInRvU3RyaW5nIiwidGV4dFZhbHVlIiwidmFsdWUiLCJsZW5ndGgiLCJkZWxldGVEYXRhIiwiTWF0aCIsIm1heCIsImluc2VydERhdGEiLCJjcnVkIiwidXBkYXRlRG9jdW1lbnQiLCJkYXRhIiwibWV0YWRhdGEiLCJuYW1lc3BhY2UiLCJyb29tIiwiYnJvYWRjYXN0IiwidXBzZXJ0IiwiYnJvYWRjYXN0X3NlbmRlciIsImluc2VydFRleHQiLCJlcnJvciIsImRlbGV0ZVRleHQiLCJnZXRUZXh0IiwiZ2V0V2hvbGVTdHJpbmciLCJnZXRQb3NpdGlvbiIsImNhbGxiYWNrIiwibWlGdW5jaW9uIiwiY2hhbmdlTGlzdGVuQXdlcmVuZXNzIiwidXRpbHMiLCJjaGVja1ZhbHVlIiwiZ2VuZXJhdGVJRCIsImNvbmZpZyIsIm9yZ2FuaXphdGlvbl9JZCIsImpzb24iLCJydWxlcyIsImtleXNfanNvbiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiZ195RG9jIiwiWSIsIkRvYyIsIkNvQ3JlYXRlQ3JkdCIsIndpbmRvdyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7Ozs7OztBQUdBLE1BQU1B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QURELElBRUEsQ0FBQytCLFdBQU1DLFVBQU4sQ0FBaUIvQixJQUFqQixDQUZMLEVBR0E7QUFDRSxhQUFPLElBQVA7QUFDRDs7QUFDRCxXQUFPLEtBQUtnQyxVQUFMLENBQWdCQyxNQUFNLENBQUNDLGVBQXZCLEVBQXdDcEMsVUFBeEMsRUFBb0RDLFdBQXBELEVBQWlFQyxJQUFqRSxDQUFQO0FBQ0Q7O0FBRURaLG9CQUFrQixDQUFDK0MsSUFBRCxFQUFNQyxLQUFOLEVBQVk7QUFDNUIsUUFBSUMsU0FBUyxHQUFHQyxNQUFNLENBQUNDLElBQVAsQ0FBWUosSUFBWixDQUFoQjtBQUNBRSxhQUFTLENBQUNHLE9BQVYsQ0FBa0JDLEdBQUcsSUFBRTtBQUNyQixZQUFNQyxLQUFLLEdBQUdOLEtBQUssQ0FBQ08sT0FBTixDQUFjRixHQUFkLENBQWQ7QUFDQSxVQUFHQyxLQUFLLElBQUksQ0FBQyxDQUFiLEVBQ0VOLEtBQUssQ0FBQ1EsTUFBTixDQUFhRixLQUFiLEVBQW9CLENBQXBCO0FBQ0gsS0FKRDtBQUtBLFFBQUlOLEtBQUssQ0FBQzdCLE1BQVYsRUFDRSxNQUFNLDRCQUEyQjZCLEtBQUssQ0FBQ2hDLFFBQU4sRUFBakM7QUFDSDs7QUE3S0g7O0FBZ0xBLE1BQU15QyxNQUFNLEdBQUcsSUFBSUMsQ0FBQyxDQUFDQyxHQUFOLEVBQWY7QUFDQSxJQUFJQyxZQUFZLEdBQUcsSUFBSW5FLGlCQUFKLENBQXNCb0QsTUFBTSxDQUFDQyxlQUE3QixFQUE4Q1csTUFBOUMsQ0FBbkI7QUFDQUksTUFBTSxDQUFDSCxDQUFQLEdBQVdBLENBQVg7ZUFFZUUsWSIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jcmR0L3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb0NyZWF0ZVlTb2NrZXQgZnJvbSBcIi4vY29yZS5qc1wiXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7dXRpbHMsIGNydWR9IGZyb20gJy4uLy4uLy4uL0NvQ3JlYXRlSlMvc3JjJztcblxuXG5jbGFzcyBDb0NyZWF0ZUNSRFRDbGFzcyBleHRlbmRzIENvQ3JlYXRlWVNvY2tldCBcbntcbiAgY29uc3RydWN0b3Iob3JnLCBkb2MpIHtcbiAgICBzdXBlcihvcmcsIGRvYylcbiAgfVxuXG4gIC8qXG4gIGNyZHQuaW5pdCh7XG4gICAgY29sbGVjdGlvbjogXCJtb2R1bGVcIixcbiAgICBkb2N1bWVudF9pZDogXCJcIixcbiAgICBuYW1lOiBcIlwiLFxuICAgIGVsZW1lbnQ6IGRvbV9vYmplY3QsXG4gICAgbWV0YWRhdGE6IFwieHh4eFwiXG4gIH0pXG4gICovXG4gIGluaXQoaW5mbykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9fdmFsaWRhdGVLZXlzSnNvbihpbmZvLCBbJ2NvbGxlY3Rpb24nLCAnZG9jdW1lbnRfaWQnLCAnbmFtZSddKTtcbiAgICAgIFxuICAgICAgY29uc3QgaWQgPSB0aGlzLl9fZ2V0WURvY0lkKGluZm9bJ2NvbGxlY3Rpb24nXSwgaW5mb1snZG9jdW1lbnRfaWQnXSwgaW5mb1snbmFtZSddKVxuXG4gICAgICBpZiAoIWlkKSByZXR1cm47XG4gICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmNyZWF0ZURvYyhpZCwgaW5mby5lbGVtZW50KVxuICAgICAgY29uc29sZS5sb2coXCJJbml0Q3JkdFwiKVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgcGFyYW0nLCBlKTtcbiAgICB9XG4gIH1cblxuICAvKi4gaW5pdCBkYXRhIGZ1bmN0aW9uXG4gIGNyZHQucmVwbGFjZVRleHQoe1xuICAgIGNvbGxlY3Rpb246IFwibW9kdWxlXCIsXG4gICAgZG9jdW1lbnRfaWQ6IFwiXCIsXG4gICAgbmFtZTogXCJcIixcbiAgICB2YWx1ZTogXCJcIixcbiAgICB1cGRhdGVDcnVkOiB0cnVlIHwgZmFsc2UsXG4gICAgZWxlbWVudDogZG9tX29iamVjdCxcbiAgICBtZXRhZGF0YTogXCJ4eHh4XCJcbiAgfSlcbiAgKi9cbiAgXG4gIHJlcGxhY2VUZXh0KGluZm8pe1xuICAgIGlmICghaW5mbykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGlkID0gdGhpcy5fX2dldFlEb2NJZChpbmZvLmNvbGxlY3Rpb24sIGluZm8uZG9jdW1lbnRfaWQsIGluZm8ubmFtZSlcbiAgICBpZiAoIWlkKSByZXR1cm47XG5cbiAgICBpZiAoaW5mby51cGRhdGVDcnVkICE9IGZhbHNlKSBpbmZvLnVwZGF0ZUNydWQgPSB0cnVlO1xuICAgIFxuICAgIGlmICh0aGlzLmdldFR5cGUoaWQpICkge1xuICAgICAgbGV0IG9sZERhdGEgPSB0aGlzLmdldFR5cGUoaWQpLnRvU3RyaW5nKCk7XG4gICAgICBsZXQgdGV4dFZhbHVlID0gaW5mby52YWx1ZS50b1N0cmluZygpO1xuICAgICAgaWYgKG9sZERhdGEgJiYgb2xkRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlRGF0YShpZCwgMCwgTWF0aC5tYXgob2xkRGF0YS5sZW5ndGgsIHRleHRWYWx1ZS5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zZXJ0RGF0YShpZCwgMCwgdGV4dFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGluZm8udXBkYXRlQ3J1ZCkge1xuICAgICAgY3J1ZC51cGRhdGVEb2N1bWVudCh7XG4gICAgICAgIGNvbGxlY3Rpb246IGluZm8uY29sbGVjdGlvbixcbiAgICAgICAgZG9jdW1lbnRfaWQ6IGluZm8uZG9jdW1lbnRfaWQsXG4gICAgICAgIGRhdGE6IHtbaW5mby5uYW1lXTogaW5mby52YWx1ZX0sXG4gICAgICAgIGVsZW1lbnQ6IGluZm8uZWxlbWVudCxcbiAgICAgICAgbWV0YWRhdGE6aW5mby5tZXRhZGF0YSxcbiAgICAgICAgbmFtZXNwYWNlOiBpbmZvLm5hbWVzcGFjZSxcbiAgICAgICAgcm9vbTogaW5mby5yb29tLFxuICAgICAgICBicm9hZGNhc3Q6IGluZm8uYnJvYWRjYXN0LFxuICAgICAgICB1cHNlcnQ6IGluZm8udXBzZXJ0LFxuICAgICAgICBicm9hZGNhc3Rfc2VuZGVyOiBpbmZvLmJyb2FkY2FzdF9zZW5kZXJcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIFxuICAvKlxuICBjcmR0Lmluc2VydFRleHQoe1xuICBcdGNvbGxlY3Rpb246ICdtb2R1bGVfYWN0aXZpdGllcycsXG4gIFx0ZG9jdW1lbnRfaWQ6ICc1ZTQ4MDJjZTNlZDk2ZDM4ZTcxZmM3ZTUnLFxuICBcdG5hbWU6ICduYW1lJyxcbiAgXHR2YWx1ZTogJ1QnLFxuICBcdHBvc2l0aW9uOiAnOCcsXG4gIFx0YXR0cmlidXRlczoge2JvbGQ6IHRydWV9XG4gIH0pXG4gICovXG4gIGluc2VydFRleHQoaW5mbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fX3ZhbGlkYXRlS2V5c0pzb24oaW5mbyxbJ2NvbGxlY3Rpb24nLCdkb2N1bWVudF9pZCcsJ25hbWUnLCd2YWx1ZScsJ3Bvc2l0aW9uJ10pO1xuICAgICAgICBsZXQgaWQgPSB0aGlzLl9fZ2V0WURvY0lkKGluZm9bJ2NvbGxlY3Rpb24nXSwgaW5mb1snZG9jdW1lbnRfaWQnXSwgaW5mb1snbmFtZSddKVxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICB0aGlzLmluc2VydERhdGEoaWQsIGluZm9bJ3Bvc2l0aW9uJ10sIGluZm9bJ3ZhbHVlJ10udG9TdHJpbmcoKSwgaW5mb1snYXR0cmlidXRlcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTsgXG4gICAgICB9XG4gIH1cbiAgXG4gIFxuICAvKlxuICBjcmR0LmRlbGV0ZVRleHQoe1xuICBcdGNvbGxlY3Rpb246ICdtb2R1bGVfYWN0aXZpdGllcycsXG4gIFx0ZG9jdW1lbnRfaWQ6ICc1ZTQ4MDJjZTNlZDk2ZDM4ZTcxZmM3ZTUnLFxuICBcdG5hbWU6ICduYW1lJyxcbiAgXHRwb3NpdGlvbjogJzgnLFxuICBcdGxlbmd0aDogMixcbiAgfSlcbiAgKi9cbiAgZGVsZXRlVGV4dChpbmZvKSB7XG4gICAgdHJ5e1xuICAgICAgdGhpcy5fX3ZhbGlkYXRlS2V5c0pzb24oaW5mbyxbJ2NvbGxlY3Rpb24nLCdkb2N1bWVudF9pZCcsJ25hbWUnLCAncG9zaXRpb24nLCdsZW5ndGgnXSk7XG4gICAgICBsZXQgaWQgPSB0aGlzLl9fZ2V0WURvY0lkKGluZm9bJ2NvbGxlY3Rpb24nXSwgaW5mb1snZG9jdW1lbnRfaWQnXSwgaW5mb1snbmFtZSddKVxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlRGF0YShpZCwgaW5mb1sncG9zaXRpb24nXSwgaW5mb1snbGVuZ3RoJ10pO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTsgXG4gICAgfVxuICB9XG4gIFxuICBcbiAgLypcbiAgY3JkdC5nZXRUZXh0KHtcbiAgXHRjb2xsZWN0aW9uOiAnbW9kdWxlX2FjdGl2aXRpZXMnLFxuICBcdGRvY3VtZW50X2lkOiAnNWU0ODAyY2UzZWQ5NmQzOGU3MWZjN2U1JyxcbiAgXHRuYW1lOiAnbmFtZSdcbiAgfSlcbiAgKi9cbiAgZ2V0VGV4dChpbmZvKSB7XG4gICAgdHJ5e1xuICAgICAgdGhpcy5fX3ZhbGlkYXRlS2V5c0pzb24oaW5mbyxbJ2NvbGxlY3Rpb24nLCdkb2N1bWVudF9pZCcsJ25hbWUnXSk7XG4gICAgICBsZXQgaWQgPSB0aGlzLl9fZ2V0WURvY0lkKGluZm9bJ2NvbGxlY3Rpb24nXSwgaW5mb1snZG9jdW1lbnRfaWQnXSwgaW5mb1snbmFtZSddKVxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdob2xlU3RyaW5nKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTsgXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cblxuICBcbiAgLyogXG4gIGNyZHQuZ2V0UG9zaXRpb24oZnVuY3Rpb24oZGF0YSkpXG4gIGNyZHQuZ2V0UG9zaXRpb24oZnVuY3Rpb24oZGF0YSl7Y29uc29sZS5sb2coXCIgRVNjdWNoYW5kbyBhaG9yYSAgXCIsZGF0YSl9KVxuICAqL1xuICBnZXRQb3NpdGlvbihjYWxsYmFjayl7XG4gIGlmKHR5cGVvZiBtaUZ1bmNpb24gPT09ICdmdW5jdGlvbicpXG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5Bd2VyZW5lc3MoY2FsbGJhY2spO1xuICBlbHNlXG4gICAgY29uc29sZS5lcnJvcignQ2FsbGJhY2sgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKVxuICB9XG4gXG4gIF9fZ2V0WURvY0lkKGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lKSB7XG4gICAgaWYgKCF1dGlscy5jaGVja1ZhbHVlKGNvbGxlY3Rpb24pIHx8IFxuICAgICAgICAhdXRpbHMuY2hlY2tWYWx1ZShkb2N1bWVudF9pZCkgfHwgXG4gICAgICAgICF1dGlscy5jaGVja1ZhbHVlKG5hbWUpKSBcbiAgICB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJRChjb25maWcub3JnYW5pemF0aW9uX0lkLCBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSk7XG4gIH1cbiAgXG4gIF9fdmFsaWRhdGVLZXlzSnNvbihqc29uLHJ1bGVzKXtcbiAgICBsZXQga2V5c19qc29uID0gT2JqZWN0LmtleXMoanNvbik7XG4gICAga2V5c19qc29uLmZvckVhY2goa2V5PT57XG4gICAgICBjb25zdCBpbmRleCA9IHJ1bGVzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmKGluZGV4ICE9IC0xKVxuICAgICAgICBydWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH0pO1xuICAgIGlmKCBydWxlcy5sZW5ndGggKVxuICAgICAgdGhyb3cgXCJSZXF1aXJlcyB0aGUgZm9sbG93aW5nIFwiKyBydWxlcy50b1N0cmluZygpO1xuICB9XG59XG5cbmNvbnN0IGdfeURvYyA9IG5ldyBZLkRvYygpO1xubGV0IENvQ3JlYXRlQ3JkdCA9IG5ldyBDb0NyZWF0ZUNSRFRDbGFzcyhjb25maWcub3JnYW5pemF0aW9uX0lkLCBnX3lEb2MpO1xud2luZG93LlkgPSBZO1xuXG5leHBvcnQgZGVmYXVsdCBDb0NyZWF0ZUNyZHQ7XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-crdt/src/index.js\n")},"../CoCreate-cursors/src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _src = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-observer/src */ \"../CoCreate-observer/src/index.js\"));\n\nvar _utils = _interopRequireDefault(__webpack_require__(/*! ../../../CoCreateJS/src/utils */ \"../../CoCreateJS/src/utils.js\"));\n\nvar _src2 = __webpack_require__(/*! ../../../CoCreateJS/src */ \"../../CoCreateJS/src/index.js\");\n\nvar _src3 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-crdt/src */ \"../CoCreate-crdt/src/index.js\"));\n\nvar _src4 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-input/src */ \"../CoCreate-input/src/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*global Element*/\n\n/**Uso esta variable para mostrar errores en caso que no este en prod*/\nvar element_multicursors = document.querySelectorAll('input,textarea,[contenteditable]'); //console.log(element_multicursors)\n\nvar debug = false;\nvar enviroment_prod = true;\nvar properties = ['boxSizing', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'fontStyle', 'fontVariant', 'fontWeight', 'fontStretch', 'fontSize', 'lineHeight', 'fontFamily', 'textAlign', 'textTransform', 'textIndent', 'textDecoration', 'letterSpacing', 'wordSpacing', 'textRendering', 'webkitWritingMode', 'textTransform', 'textIndent', 'overflowWrap'];\nvar length_uuid = 30;\n\nclass CocreateUtilsCursor {\n  static print(message, debug) {\n    debug = debug || false;\n    if (debug) console.log(message);\n  }\n\n  static generateUUID(length = null) {\n    var d = new Date().getTime();\n    var d2 = performance && performance.now && performance.now() * 1000 || 0; //Time in microseconds since page-load or 0 if unsupported\n\n    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = Math.random() * 16;\n\n      if (d > 0) {\n        var r = (d + r) % 16 | 0;\n        d = Math.floor(d / 16);\n      } else {\n        var r = (d2 + r) % 16 | 0;\n        d2 = Math.floor(d2 / 16);\n      }\n\n      return (c == 'x' ? r : r & 0x7 | 0x8).toString(16);\n    });\n\n    if (length != null) {\n      uuid = uuid.substr(0, length);\n    }\n\n    return uuid;\n  }\n\n}\n\nvar getParents = function (elem, selector) {// \tif (!Element.prototype.matches) {\n  // \t\tElement.prototype.matches =\n  // \t\t\tElement.prototype.matchesSelector ||\n  // \t\t\tElement.prototype.mozMatchesSelector ||\n  // \t\t\tElement.prototype.msMatchesSelector ||\n  // \t\t\tElement.prototype.oMatchesSelector ||\n  // \t\t\tElement.prototype.webkitMatchesSelector ||\n  // \t\t\tfunction(s) {\n  // \t\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s),\n  // \t\t\t\t\ti = matches.length;\n  // \t\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n  // \t\t\t\treturn i > -1;\n  // \t\t\t};\n  // \t}\n};\n\nvar mirrorDiv, computed, style, computedParentElement;\n\nvar getCaretCoordinates = function (element, position_start, position_end) {\n  // mirrored div\n  let name = element.getAttribute('name');\n  let document_id = element.getAttribute('data-document_id') || '';\n\n  if (document_id == '') {\n    return false;\n  }\n\n  var ID_MIRROR = element.dataset['mirror_id']; //document_id + name +  '--mirror-div';\n\n  mirrorDiv = document.getElementById(ID_MIRROR);\n  var add_class_scroll = element.className.indexOf('floating-label') == -1 ? false : true;\n\n  if (!mirrorDiv) {\n    mirrorDiv = document.createElement('div');\n    mirrorDiv.id = ID_MIRROR; //document_id +name+ '--mirror-div';\n\n    mirrorDiv.className = enviroment_prod ? 'mirror_color mirror_scroll mirror-width-scroll' : 'mirror-width-scroll'; //document.body.appendChild(mirrorDiv);\n\n    element.insertAdjacentElement('afterend', mirrorDiv);\n  }\n\n  var scrollwidth = element.offsetWidth - element.scrollWidth;\n  style = mirrorDiv.style;\n  computed = getComputedStyle(element);\n  computedParentElement = getComputedStyle(element.parentElement);\n  let margin_top = parseInt(computed['marginTop']);\n  let margin_left = parseInt(computed['marginLeft']);\n\n  if (element.nodeName !== 'INPUT') {\n    style.wordWrap = 'break-word'; // only for textarea-s\n\n    style.whiteSpace = 'pre-wrap';\n  } else {\n    style.whiteSpace = 'pre';\n  } // position off-screen\n\n\n  style.position = 'absolute'; // required to return coordinates properly\n\n  var rect = element.getBoundingClientRect(); // get Position from element\n\n  let scrrollTop_browser = document.documentElement.scrollTop; //style.top = ((rect.top+scrrollTop_browser)-1) - (parseInt(computed['marginTop']) - parseInt(computed['borderTopWidth']) ) + 'px'//parseInt(computed.borderTopWidth) + 'px'; //  element.offsetTop + parseInt(computed.borderTopWidth) + 'px';\n  //style.top = computedParentElement['top'];\n\n  style.top = element.offsetTop + 'px'; //style.left = rect.left - (parseInt(computed['marginLeft']) -  parseInt(computed['borderLeftWidth']) ) + 'px'//parseInt(computed.borderLeftWidth) + 'px'   // margin_left+\"px\";//\"400px\";\n  //style.left =  computedParentElement['left'];\n\n  style.left = element.offsetLeft + 'px';\n  style.width = rect.width + 'px'; // - (parseInt(computed.borderLeftWidth) + parseInt(computed.borderRightWidth)) + 'px'   // margin_left+\"px\";//\"400px\";\n\n  style.height = rect.height + 'px'; // - (parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth)) + 'px'   // margin_left+\"px\";//\"400px\";\n\n  style.visibility = 'visible';\n  properties.forEach(function (prop) {\n    if (['left', 'top'].indexOf(prop.toLowerCase()) === -1) style[prop] = computed[prop];\n  });\n  style.overflowX = 'auto';\n  style.overflowY = 'hidden';\n  style.margin = '0px'; //style.padding = '0px'\n\n  style.border = computed['border'];\n  style.borderColor = 'transparent';\n  /* \n  if(element.nodeName.toLowerCase()=='input'){\n    style.overflowX ='auto';\n    style.overflowY ='hidden';\n  }else{\n    style.overflow=\"visible\"\n  }*/\n  // style.paddingRight = (parseInt(style.paddingRight) + scrollwidth - parseInt(computed.borderRightWidth)) +'px';\n\n  let cursor_container = mirrorDiv.querySelectorAll('.cursor-container');\n  let selectors_by_users = mirrorDiv.querySelectorAll('.selectors_by_users');\n  let value_element = ['TEXTAREA', 'INPUT'].indexOf(element.nodeName) == -1 ? element.innerHTML : element.value;\n  mirrorDiv.textContent = value_element.substring(0, position_start);\n  if (element.nodeName === 'INPUT') mirrorDiv.textContent = mirrorDiv.textContent.replace(/\\s/g, \"\\u00a0\");\n  var span = document.createElement('span');\n  span.id = element.nodeName + 'span_selections';\n  let value_span = value_element.substring(position_start, position_end) || '';\n  span.textContent = value_span; // || because a completely empty faux span doesn't render at all\n  //span.style.backgroundColor = \"lightgrey\";\n\n  mirrorDiv.appendChild(span);\n\n  if (cursor_container) {\n    cursor_container.forEach(function (child_cursor, index, array) {\n      mirrorDiv.appendChild(child_cursor);\n    });\n  }\n\n  if (selectors_by_users) {\n    selectors_by_users.forEach(function (child_selection, index, array) {\n      mirrorDiv.appendChild(child_selection);\n    });\n  }\n\n  let value_end = value_element.substring(position_end) || '';\n  var span_end = document.createElement('span');\n  mirrorDiv.appendChild(span_end);\n  span_end.textContent = value_end;\n  var rect = element.getBoundingClientRect(); // get Position from element\n\n  var coordinates = {\n    start: {\n      top: span.offsetTop,\n      left: span.offsetLeft\n    },\n    end: {\n      top: span_end.offsetTop,\n      //+ parseInt(computed['borderTopWidth']),\n      left: span_end.offsetLeft // + parseInt(computed['borderLeftWidth'])\n\n    }\n  };\n  return coordinates;\n};\n\nfunction getStyle(el, styleProp) {\n  if (window.getComputedStyle) var y = document.defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);\n  return y;\n}\n\nfunction getDocument(collection, module_id) {\n  _src2.crud.readDocument({\n    'collection': collection,\n    'document_id': module_id\n  });\n}\n\n_src2.socket.listen('readDocument', function (data) {\n  let cursor = document.querySelector('.cursor-flag[data-document_id=\"' + data['document_id'] + '\"]');\n  if (cursor) cursor.innerHTML = data.result[cursor.getAttribute('name')];\n});\n\nfunction draw_cursor(json) {\n  CocreateUtilsCursor.print([\"draw Cursor \", json], debug);\n  let element = json['element'];\n  let activate_cursor = element.dataset['cursors'] ? element.dataset['mirror_id'] : true;\n\n  if (activate_cursor) {\n    let start = json['startPosition'];\n    let end = json['endPositon'];\n    let socket_id = json['clientId'];\n    let document_id = element.getAttribute('data-document_id') || '';\n\n    if (document_id != '') {\n      CocreateUtilsCursor.print(\"action document_id \" + document_id, debug);\n      if (typeof element.dataset['mirror_id'] == 'undefined' || element.dataset['mirror_id'] == '') element.dataset['mirror_id'] = CocreateUtilsCursor.generateUUID(length_uuid);\n      let coordinates = getCaretCoordinates(element, start, end);\n      if (!coordinates) return false;\n      let name = element.getAttribute('name');\n      let id_mirror = element.dataset['mirror_id']; //document_id+name+'--mirror-div'\n\n      let mi_mirror = document.getElementById(id_mirror);\n      let cursor = false;\n      let selection_user = false;\n      let identify = '_' + id_mirror;\n      let user = typeof json != 'undefined' && json.hasOwnProperty('user') ? json.user : false;\n      let user_id = typeof json != 'undefined' && json.hasOwnProperty('user_id') ? user.user_id : false;\n\n      if (socket_id) {\n        //if(data && data.hasOwnProperty('id_mirror')){\n        var cursores_other_elements = document.querySelectorAll('#socket_' + socket_id + identify);\n        cursores_other_elements.forEach(function (child_cursor, index, array) {\n          if (child_cursor.parentElement.getAttribute('id') != id_mirror) {\n            CocreateUtilsCursor.print(\"remove old cursor others elements\", debug);\n            child_cursor.remove();\n          }\n        }); //}\n\n        cursor = mi_mirror.querySelector('.cursor-container#socket_' + socket_id + identify);\n\n        if (!cursor && json.hasOwnProperty('user')) {\n          if (user) {\n            CocreateUtilsCursor.print(\"Create Cursor\", debug);\n            let cursor_template = '<div style=\"color:blue;\" class=\"cursor-container\" \\\n                                                  id=\"socket_' + socket_id + identify + '\" \\\n                                                  ><div class=\"cursor\" \\\n                                                  style=\"background-color:' + user.color + '\"></div>\\\n                                                  <div class=\"cursor-flag\" data-collection=\"users\" \\\n                                                  name=\"name\" \\\n                                                  data-user_name=\"' + user.name + '\" \\\n                                                  data-user_color=\"' + user.color + '\" \\\n                                                  data-socket_id=\"' + socket_id + '\" \\\n                                                  data-id_mirror=\"' + id_mirror + '\" \\\n                                                  data-document_id=\"' + user_id + '\" \\\n                                                  style=\"background-color:' + user.color + '\" \\\n                                                  flag>' + user.name + '</div></div>';\n            mi_mirror.innerHTML = cursor_template + mi_mirror.innerHTML;\n          }\n\n          if (user_id) {\n            // si tiene user_id actualiza el nombre del cursor usando crud\n            _src2.crud.readDocument({\n              'collection': 'users',\n              'document_id': user_id\n            });\n          }\n        }\n\n        cursor = mi_mirror.querySelector('.cursor-container#socket_' + socket_id + identify);\n      }\n\n      if (cursor) {\n        CocreateUtilsCursor.print([\"Update Cursor\", cursor, coordinates], debug);\n        let font_size = getStyle(element, 'font-size');\n        font_size = parseFloat(font_size.substring(0, font_size.length - 2));\n        let cursor_height = font_size * 112.5 / 100;\n        let my_cursor = cursor.querySelector('.cursor');\n        cursor.dataset.start = start;\n        cursor.dataset.end = end;\n        cursor.dataset.socket_id = socket_id;\n        /*cursor.dataset.user_name = user.name\n        cursor.dataset.user_color = user.color*/\n\n        cursor.style[\"top\"] = coordinates.end.top + \"px\";\n        cursor.style[\"width\"] = \"2px\"; //2px\n\n        my_cursor.style[\"height\"] = cursor_height + \"px\";\n        cursor.style[\"left\"] = coordinates.end.left + \"px\"; //add selections\n\n        selection_user = document.getElementById('sel-' + socket_id + identify);\n\n        if (start != end && user) {\n          selection_user = document.getElementById('sel-' + socket_id + identify);\n\n          if (selection_user) {\n            selection_user.remove();\n          }\n\n          var scrollwidth = element.offsetWidth - element.scrollWidth;\n          var padding_right = parseInt(getComputedStyle(element)[\"paddingRight\"]);\n          selection_user = document.createElement('span');\n          selection_user.id = 'sel-' + socket_id + identify;\n          selection_user.className = 'selectors_by_users';\n          let style_mirror = getComputedStyle(mi_mirror);\n          selection_user.style[\"position\"] = \"absolute\";\n          selection_user.style[\"top\"] = style_mirror.paddingTop;\n          selection_user.style[\"left\"] = style_mirror.paddingLeft;\n          selection_user.style[\"padding-right\"] = scrollwidth + padding_right + \"px\";\n          mi_mirror.insertBefore(selection_user, mi_mirror.firstChild);\n          let selection_span_by_user = document.createElement('span');\n          selection_span_by_user.id = 'selection-' + socket_id + identify;\n          selection_span_by_user.style.backgroundColor = user.color;\n          let value_element = ['TEXTAREA', 'INPUT'].indexOf(element.nodeName) == -1 ? element.innerHTML : element.value;\n          selection_user.textContent = value_element.substring(0, start);\n          let value_span_selection = value_element.substring(start, end) || '';\n          console.log(\"Selection \", value_span_selection, start, end); //selection_span_by_user.style.opacity = 0.5;\n\n          selection_span_by_user.textContent = value_span_selection;\n          selection_user.appendChild(selection_span_by_user);\n        } //end Selections\n        else {\n            if (selection_user) {\n              selection_user.remove();\n            }\n          }\n      }\n    } //end if document_id\n\n  } //end activate_cursors\n\n} //draw_cursor\n\n\nfunction refresh_mirror(element) {\n  var id_mirror = '';\n  let document_id = element.getAttribute('data-document_id') || '';\n\n  if (document_id != '') {\n    name = element.getAttribute('name');\n    if (element.dataset['mirror_id']) id_mirror = element.dataset['mirror_id'];else return; //console.log(\"Refresh \",id_mirror)\n\n    var mi_mirror = document.getElementById(id_mirror);\n    CocreateUtilsCursor.print([\"refresh_mirror \", mi_mirror], debug);\n    var selector_element = element.nodeName + \"[name='\" + name + \"'][data-document_id='\" + document_id + \"']\";\n    CocreateUtilsCursor.print([\"selector -> \" + selector_element], debug);\n\n    if (mi_mirror) {\n      computed = getComputedStyle(element);\n      style = mi_mirror.style;\n      style.width = element.offsetWidth - (parseInt(computed.borderLeftWidth) + parseInt(computed.borderRightWidth)) + 'px';\n      style.height = element.offsetHeight - (parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth)) + 'px';\n      var cursor_container = mi_mirror.querySelectorAll('.cursor-container');\n      cursor_container.forEach(function (child_cursor, index, array) {\n        //console.log(\"REdraw cursor\")\n        let child = child_cursor.querySelector('.cursor-flag');\n        let dataset_child = child.dataset;\n        let dataset = child_cursor.dataset;\n        draw_cursor({\n          element: element,\n          startPosition: dataset.start,\n          endPositon: dataset.end,\n          clientId: dataset.socket_id,\n          user: {\n            'color': dataset_child.user_color,\n            'name': dataset.user_name\n          }\n        });\n      });\n    }\n  } //end document\n\n} //end verify \n\n\nElement.prototype.remove = function () {\n  if (this.parentElement) {\n    this.parentElement.removeChild(this);\n  }\n};\n\nfunction recalculate_local_cursors(element, count) {\n  CocreateUtilsCursor.print(\"count \" + count, debug);\n  let my_start = !element.hasAttribute('contenteditable') ? element.selectionStart : parseInt(element.getAttribute(\"selection_start\")); //let my_start   = element.selectionStart\n\n  let name = element.getAttribute('name') || '';\n  let document_id = element.getAttribute('data-document_id') || '';\n  let collection = element.getAttribute('data-collection') || '';\n  let selector = '[data-collection=\"' + collection + '\"][data-document_id=\"' + document_id + '\"][name=\"' + name + '\"]';\n  let id_mirror = element.dataset['mirror_id']; //let id_mirror = document_id+name+'--mirror-div';\n\n  let mirrorDiv = document.getElementById(id_mirror);\n  let cursor_container = mirrorDiv ? mirrorDiv.querySelectorAll('.cursor-container') : null;\n\n  if (cursor_container) {\n    let containers_cursors = [];\n    cursor_container.forEach(function (child_cursor, index, array) {\n      let start = parseInt(child_cursor.getAttribute('data-start'));\n      let user_name = child_cursor.getAttribute('data-user_name');\n      CocreateUtilsCursor.print([\"my_start local\", my_start, 'start cursor ' + user_name + \" = \", start], debug);\n\n      if (start > my_start && containers_cursors.indexOf(user_name) == -1) {\n        CocreateUtilsCursor.print(\"Es mayor\", debug);\n        let end = parseInt(child_cursor.getAttribute('data-end'));\n        let pos_start = start + count;\n        let pos_end = end + count;\n        CocreateUtilsCursor.print(['pos_start', pos_start, 'pos_end', pos_end], debug);\n        let dataset = child_cursor.querySelector('.cursor-flag').dataset;\n        let clientId = dataset.socket_id;\n        let json = {\n          element: element,\n          startPosition: pos_start,\n          endPositon: pos_end,\n          clientId: clientId,\n          'user': {\n            'color': dataset.user_color,\n            'name': dataset.user_name\n          }\n        };\n        CocreateUtilsCursor.print([\"sent Draw Cursor \", json], debug);\n        draw_cursor(json);\n        containers_cursors.push(user_name);\n      } //mirrorDiv.appendChild(child_cursor);\n\n    });\n  }\n}\n\nfunction initCursorEl(element) {\n  let formulario = getParents(element, 'form');\n  let realtime = element.hasAttribute('data-realtime') ? element.getAttribute('data-realtime') : 'true';\n\n  if (realtime == 'true' || formulario && formulario.getAttribute('data-realtime') == 'true') {\n    if (realtime == 'false') return false;\n    CocreateUtilsCursor.print([\"Init Events \", element], debug);\n    /*\n    element.addEventListener('input',function(event){\n        let start = element.selectionStart;\n        let end = element.selectionEnd;\n        let coordinates = getCaretCoordinates(element,start,end);\n        let count = 0;\n        switch(event.inputType){\n          case 'insertText':\n            count = 1;\n          break;\n          case 'insertFromPaste':\n           // count = event.clipboardData.getData('Text').length\n          break;\n          case 'deleteContentBackward':\n          //case 'insertFromPaste':\n            count = -1;\n          break;\n        }\n        if(count)\n          recalculate_local_cursors(this,count)\n    },false)\n    */\n\n    element.addEventListener('scroll', function () {\n      CocreateUtilsCursor.print([\"Move Scroll \", element], true);\n      let name = element.getAttribute('name');\n      let document_id = element.getAttribute('data-document_id') || '';\n      let id_mirror = element.dataset['mirror_id'];\n      let mi_mirror = document.getElementById(id_mirror);\n\n      if (mi_mirror) {\n        mi_mirror.scrollTo(element.scrollLeft, element.scrollTop);\n      }\n    }, false); //resize\n\n    function outputsize() {\n      element_multicursors.forEach(function (element_for, index, array) {\n        let name = element_for.getAttribute('name');\n        let id_mirror = element.dataset['mirror_id'];\n        CocreateUtilsCursor.print([\"Resize id_mirror -> \" + id_mirror], debug);\n        let mi_mirror = document.getElementById(id_mirror);\n\n        if (mi_mirror) {\n          mi_mirror.style[\"width\"] = element_for.offsetWidth + \"px\";\n          mi_mirror.style[\"height\"] = element_for.offsetHeight + \"px\"; //var isFocused = (document.activeElement === element_for);\n          //verify_cursor(element_for,isFocused)\n\n          var isFocused = document.activeElement === element;\n          if (isFocused) getCaretCoordinates(element, element.selectionStart, element.selectionEnd);\n          refresh_mirror(element);\n        }\n      });\n    }\n\n    new ResizeObserver(outputsize).observe(element); //if (element.nodeName == 'INPUT'){\n\n    element.addEventListener('mousemove', function (event) {\n      let name = element.getAttribute('name');\n      let document_id = element.getAttribute('data-document_id');\n      let id_mirror = element.dataset['mirror_id'];\n      let mi_mirror = document.getElementById(id_mirror);\n      if (mi_mirror) mi_mirror.scrollTo(element.scrollLeft, element.scrollTop);\n    });\n    element.addEventListener('focusout', function (event) {\n      let name = element.getAttribute('name');\n      let document_id = element.getAttribute('data-document_id') || '';\n      let id_mirror = element.dataset['mirror_id'];\n      let mi_mirror = document.getElementById(id_mirror);\n      if (mi_mirror) mi_mirror.scrollTo(element.scrollLeft, element.scrollTop);\n    });\n    element.addEventListener('keydown', function (event) {\n      //console.log(\"keydown L,T => \",element.scrollLeft,element.scrollTop)\n      let name = element.getAttribute('name');\n      let id_mirror = element.dataset['mirror_id'];\n      let mi_mirror = document.getElementById(id_mirror);\n\n      if (mi_mirror) {\n        mi_mirror.scrollTo(element.scrollLeft, element.scrollTop);\n        refresh_mirror(element);\n      }\n    });\n    element.addEventListener('keyup', function (event) {\n      //console.log(\"keyup L,T => \",element.scrollLeft,element.scrollTop)\n      let name = element.getAttribute('name');\n      let id_mirror = element.dataset['mirror_id'];\n      let mi_mirror = document.getElementById(id_mirror);\n      if (mi_mirror) mi_mirror.scrollTo(element.scrollLeft, element.scrollTop);\n    }); //}\n  } //end if realtime TRUE\n\n}\n\nvar initialize_multicursor = function (element_multicursors) {\n  element_multicursors.forEach(function (element, index, array) {\n    initCursorEl(element);\n  }); // element_multicursors.forEach\n}; //end initialize_multicursor \n\n\nwindow.addEventListener('resize', function (e) {\n  //console.log(\"resize windows\")\n  document.querySelectorAll('[data-mirror_id]').forEach(function (element, index, array) {\n    refresh_mirror(element);\n  }); // element_multicursors.forEach\n}, true);\ndocument.addEventListener('scroll', function (e) {\n  //console.log(\"Scroll \")\n  //console.log(\"scroll windows\",document.body.scrollLeft,document.body.scrollTop)\n  //element_multicursors.forEach(function (element, index, array) {\n  document.querySelectorAll('[data-mirror_id]').forEach(function (element, index, array) {\n    refresh_mirror(element);\n  }); // element_multicursors.forEach\n}, true);\n\nfunction initCursorElements(container) {\n  let mainContainer = container || window;\n\n  if (!mainContainer.querySelectorAll) {\n    return;\n  }\n\n  let elements = mainContainer.querySelectorAll('[data-realtime=true]');\n  elements.forEach(el => {\n    initCursorEl(el);\n  });\n}\n\nif (debug) console.log(\"elements to INIT -> \", element_multicursors);\ninitialize_multicursor(element_multicursors); // CoCreateInit.register_old('[data-realtime=true]',initCursorEl);\n// CoCreateInit.register('CoCreateCursor', window, initCursorElements);\n\n_src.default.init({\n  name: 'CoCreateCursor',\n  observe: ['subtree', 'childList'],\n  include: '[data-collection][data-document_id][name][data-realtime=true]',\n  callback: function (mutation) {\n    initCursorElements(mutation.target);\n  }\n});\n\nconst CoCreateCursors = {\n  draw_cursor,\n  refresh_mirror,\n  recalculate_local_cursors\n};\nvar _default = CoCreateCursors;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWN1cnNvcnMvc3JjL2luZGV4LmpzPzQ4N2MiXSwibmFtZXMiOlsiZWxlbWVudF9tdWx0aWN1cnNvcnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJkZWJ1ZyIsImVudmlyb21lbnRfcHJvZCIsInByb3BlcnRpZXMiLCJsZW5ndGhfdXVpZCIsIkNvY3JlYXRlVXRpbHNDdXJzb3IiLCJwcmludCIsIm1lc3NhZ2UiLCJjb25zb2xlIiwibG9nIiwiZ2VuZXJhdGVVVUlEIiwibGVuZ3RoIiwiZCIsIkRhdGUiLCJnZXRUaW1lIiwiZDIiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInV1aWQiLCJyZXBsYWNlIiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwiZmxvb3IiLCJ0b1N0cmluZyIsInN1YnN0ciIsImdldFBhcmVudHMiLCJlbGVtIiwic2VsZWN0b3IiLCJtaXJyb3JEaXYiLCJjb21wdXRlZCIsInN0eWxlIiwiY29tcHV0ZWRQYXJlbnRFbGVtZW50IiwiZ2V0Q2FyZXRDb29yZGluYXRlcyIsImVsZW1lbnQiLCJwb3NpdGlvbl9zdGFydCIsInBvc2l0aW9uX2VuZCIsIm5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJkb2N1bWVudF9pZCIsIklEX01JUlJPUiIsImRhdGFzZXQiLCJnZXRFbGVtZW50QnlJZCIsImFkZF9jbGFzc19zY3JvbGwiLCJjbGFzc05hbWUiLCJpbmRleE9mIiwiY3JlYXRlRWxlbWVudCIsImlkIiwiaW5zZXJ0QWRqYWNlbnRFbGVtZW50Iiwic2Nyb2xsd2lkdGgiLCJvZmZzZXRXaWR0aCIsInNjcm9sbFdpZHRoIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBhcmVudEVsZW1lbnQiLCJtYXJnaW5fdG9wIiwicGFyc2VJbnQiLCJtYXJnaW5fbGVmdCIsIm5vZGVOYW1lIiwid29yZFdyYXAiLCJ3aGl0ZVNwYWNlIiwicG9zaXRpb24iLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nycm9sbFRvcF9icm93c2VyIiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsVG9wIiwidG9wIiwib2Zmc2V0VG9wIiwibGVmdCIsIm9mZnNldExlZnQiLCJ3aWR0aCIsImhlaWdodCIsInZpc2liaWxpdHkiLCJmb3JFYWNoIiwicHJvcCIsInRvTG93ZXJDYXNlIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwibWFyZ2luIiwiYm9yZGVyIiwiYm9yZGVyQ29sb3IiLCJjdXJzb3JfY29udGFpbmVyIiwic2VsZWN0b3JzX2J5X3VzZXJzIiwidmFsdWVfZWxlbWVudCIsImlubmVySFRNTCIsInZhbHVlIiwidGV4dENvbnRlbnQiLCJzdWJzdHJpbmciLCJzcGFuIiwidmFsdWVfc3BhbiIsImFwcGVuZENoaWxkIiwiY2hpbGRfY3Vyc29yIiwiaW5kZXgiLCJhcnJheSIsImNoaWxkX3NlbGVjdGlvbiIsInZhbHVlX2VuZCIsInNwYW5fZW5kIiwiY29vcmRpbmF0ZXMiLCJzdGFydCIsImVuZCIsImdldFN0eWxlIiwiZWwiLCJzdHlsZVByb3AiLCJ3aW5kb3ciLCJ5IiwiZGVmYXVsdFZpZXciLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0RG9jdW1lbnQiLCJjb2xsZWN0aW9uIiwibW9kdWxlX2lkIiwiY3J1ZCIsInJlYWREb2N1bWVudCIsInNvY2tldCIsImxpc3RlbiIsImRhdGEiLCJjdXJzb3IiLCJxdWVyeVNlbGVjdG9yIiwicmVzdWx0IiwiZHJhd19jdXJzb3IiLCJqc29uIiwiYWN0aXZhdGVfY3Vyc29yIiwic29ja2V0X2lkIiwiaWRfbWlycm9yIiwibWlfbWlycm9yIiwic2VsZWN0aW9uX3VzZXIiLCJpZGVudGlmeSIsInVzZXIiLCJoYXNPd25Qcm9wZXJ0eSIsInVzZXJfaWQiLCJjdXJzb3Jlc19vdGhlcl9lbGVtZW50cyIsInJlbW92ZSIsImN1cnNvcl90ZW1wbGF0ZSIsImNvbG9yIiwiZm9udF9zaXplIiwicGFyc2VGbG9hdCIsImN1cnNvcl9oZWlnaHQiLCJteV9jdXJzb3IiLCJwYWRkaW5nX3JpZ2h0Iiwic3R5bGVfbWlycm9yIiwicGFkZGluZ1RvcCIsInBhZGRpbmdMZWZ0IiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsInNlbGVjdGlvbl9zcGFuX2J5X3VzZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJ2YWx1ZV9zcGFuX3NlbGVjdGlvbiIsInJlZnJlc2hfbWlycm9yIiwic2VsZWN0b3JfZWxlbWVudCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwiY2hpbGQiLCJkYXRhc2V0X2NoaWxkIiwic3RhcnRQb3NpdGlvbiIsImVuZFBvc2l0b24iLCJjbGllbnRJZCIsInVzZXJfY29sb3IiLCJ1c2VyX25hbWUiLCJFbGVtZW50IiwicHJvdG90eXBlIiwicmVtb3ZlQ2hpbGQiLCJyZWNhbGN1bGF0ZV9sb2NhbF9jdXJzb3JzIiwiY291bnQiLCJteV9zdGFydCIsImhhc0F0dHJpYnV0ZSIsInNlbGVjdGlvblN0YXJ0IiwiY29udGFpbmVyc19jdXJzb3JzIiwicG9zX3N0YXJ0IiwicG9zX2VuZCIsInB1c2giLCJpbml0Q3Vyc29yRWwiLCJmb3JtdWxhcmlvIiwicmVhbHRpbWUiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsVG8iLCJzY3JvbGxMZWZ0Iiwib3V0cHV0c2l6ZSIsImVsZW1lbnRfZm9yIiwiaXNGb2N1c2VkIiwiYWN0aXZlRWxlbWVudCIsInNlbGVjdGlvbkVuZCIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImV2ZW50IiwiaW5pdGlhbGl6ZV9tdWx0aWN1cnNvciIsImUiLCJpbml0Q3Vyc29yRWxlbWVudHMiLCJjb250YWluZXIiLCJtYWluQ29udGFpbmVyIiwiZWxlbWVudHMiLCJvYnNlcnZlciIsImluaXQiLCJpbmNsdWRlIiwiY2FsbGJhY2siLCJtdXRhdGlvbiIsInRhcmdldCIsIkNvQ3JlYXRlQ3Vyc29ycyJdLCJtYXBwaW5ncyI6Ijs7Ozs7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U0FBTyxFQUFFLCtEQUhJO0FBSWJDLFVBQVEsRUFBRSxVQUFTQyxRQUFULEVBQW1CO0FBQzVCUixzQkFBa0IsQ0FBQ1EsUUFBUSxDQUFDQyxNQUFWLENBQWxCO0FBQ0E7QUFOWSxDQUFkOztBQVNBLE1BQU1DLGVBQWUsR0FBRztBQUFFaEYsYUFBRjtBQUFlNEIsZ0JBQWY7QUFBK0JpQjtBQUEvQixDQUF4QjtlQUNlbUMsZSIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jdXJzb3JzL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIEVsZW1lbnQqL1xuaW1wb3J0IG9ic2VydmVyIGZyb20gJy4uLy4uL0NvQ3JlYXRlLW9ic2VydmVyL3NyYydcbmltcG9ydCB1dGlscyBmcm9tICcuLi8uLi8uLi9Db0NyZWF0ZUpTL3NyYy91dGlscyc7XG5pbXBvcnQge3NvY2tldCwgY3J1ZH0gZnJvbSAnLi4vLi4vLi4vQ29DcmVhdGVKUy9zcmMnO1xuaW1wb3J0IGNyZHQgZnJvbSAnLi4vLi4vQ29DcmVhdGUtY3JkdC9zcmMnXG5pbXBvcnQgaW5wdXQgZnJvbSAnLi4vLi4vQ29DcmVhdGUtaW5wdXQvc3JjJ1xuXG5cbi8qKlVzbyBlc3RhIHZhcmlhYmxlIHBhcmEgbW9zdHJhciBlcnJvcmVzIGVuIGNhc28gcXVlIG5vIGVzdGUgZW4gcHJvZCovXG5cbnZhciBlbGVtZW50X211bHRpY3Vyc29ycyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LHRleHRhcmVhLFtjb250ZW50ZWRpdGFibGVdJylcblxuLy9jb25zb2xlLmxvZyhlbGVtZW50X211bHRpY3Vyc29ycylcbnZhciBkZWJ1ZyA9IGZhbHNlXG52YXIgZW52aXJvbWVudF9wcm9kID0gdHJ1ZVxudmFyIHByb3BlcnRpZXMgPSBbJ2JveFNpemluZycsJ2JvcmRlclRvcFdpZHRoJywnYm9yZGVyUmlnaHRXaWR0aCcsJ2JvcmRlckJvdHRvbVdpZHRoJywnYm9yZGVyTGVmdFdpZHRoJywncGFkZGluZ1RvcCcsJ3BhZGRpbmdSaWdodCcsJ3BhZGRpbmdCb3R0b20nLCdwYWRkaW5nTGVmdCcsJ21hcmdpblRvcCcsJ21hcmdpblJpZ2h0JywnbWFyZ2luQm90dG9tJywnbWFyZ2luTGVmdCcsJ2ZvbnRTdHlsZScsJ2ZvbnRWYXJpYW50JywnZm9udFdlaWdodCcsJ2ZvbnRTdHJldGNoJywnZm9udFNpemUnLCdsaW5lSGVpZ2h0JywnZm9udEZhbWlseScsJ3RleHRBbGlnbicsJ3RleHRUcmFuc2Zvcm0nLCd0ZXh0SW5kZW50JywndGV4dERlY29yYXRpb24nLCdsZXR0ZXJTcGFjaW5nJywnd29yZFNwYWNpbmcnLCd0ZXh0UmVuZGVyaW5nJywnd2Via2l0V3JpdGluZ01vZGUnLCd0ZXh0VHJhbnNmb3JtJywndGV4dEluZGVudCcsJ292ZXJmbG93V3JhcCddO1xudmFyIGxlbmd0aF91dWlkID0gMzA7XG5cblxuY2xhc3MgQ29jcmVhdGVVdGlsc0N1cnNvcntcbiAgXG4gIHN0YXRpYyBwcmludChtZXNzYWdlLGRlYnVnKSB7XG4gICAgZGVidWcgPSBkZWJ1ZyB8fCBmYWxzZTtcbiAgICBpZihkZWJ1ZylcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpXG4gIH1cbiAgXG4gIHN0YXRpYyBnZW5lcmF0ZVVVSUQobGVuZ3RoPW51bGwpIHtcbiAgICB2YXIgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBkMiA9IChwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgJiYgKHBlcmZvcm1hbmNlLm5vdygpKjEwMDApKSB8fCAwOy8vVGltZSBpbiBtaWNyb3NlY29uZHMgc2luY2UgcGFnZS1sb2FkIG9yIDAgaWYgdW5zdXBwb3J0ZWRcbiAgICB2YXIgdXVpZCA9ICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNjtcbiAgICAgICAgaWYoZCA+IDApe1xuICAgICAgICAgICAgdmFyIHIgPSAoZCArIHIpJTE2IHwgMDtcbiAgICAgICAgICAgIGQgPSBNYXRoLmZsb29yKGQvMTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHIgPSAoZDIgKyByKSUxNiB8IDA7XG4gICAgICAgICAgICBkMiA9IE1hdGguZmxvb3IoZDIvMTYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYz09J3gnID8gciA6IChyJjB4N3wweDgpKS50b1N0cmluZygxNik7XG4gICAgfSk7XG4gICAgaWYobGVuZ3RoIT1udWxsKXtcbiAgICAgIHV1aWQgPSB1dWlkLnN1YnN0cigwLGxlbmd0aClcbiAgICB9XG4gICAgcmV0dXJuIHV1aWQ7XG4gIH1cbiAgXG59XG5cbnZhciBnZXRQYXJlbnRzID0gZnVuY3Rpb24gKGVsZW0sIHNlbGVjdG9yKSB7XG5cbi8vIFx0aWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4vLyBcdFx0RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XG4vLyBcdFx0XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHxcbi8vIFx0XHRcdEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuLy8gXHRcdFx0RWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbi8vIFx0XHRcdEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHxcbi8vIFx0XHRcdEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuLy8gXHRcdFx0ZnVuY3Rpb24ocykge1xuLy8gXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICh0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzKSxcbi8vIFx0XHRcdFx0XHRpID0gbWF0Y2hlcy5sZW5ndGg7XG4vLyBcdFx0XHRcdHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG4vLyBcdFx0XHRcdHJldHVybiBpID4gLTE7XG4vLyBcdFx0XHR9O1xuLy8gXHR9XG59XG5cbnZhciBtaXJyb3JEaXYsIGNvbXB1dGVkLCBzdHlsZSwgY29tcHV0ZWRQYXJlbnRFbGVtZW50O1xuXG52YXIgZ2V0Q2FyZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwb3NpdGlvbl9zdGFydCwgcG9zaXRpb25fZW5kKSB7XG4gIC8vIG1pcnJvcmVkIGRpdlxuICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgbGV0IGRvY3VtZW50X2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKSB8fCAnJztcbiAgaWYoZG9jdW1lbnRfaWQgPT0gJycpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgSURfTUlSUk9SID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTsgLy9kb2N1bWVudF9pZCArIG5hbWUgKyAgJy0tbWlycm9yLWRpdic7XG4gIG1pcnJvckRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKElEX01JUlJPUik7XG4gIHZhciBhZGRfY2xhc3Nfc2Nyb2xsID0gKGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YoJ2Zsb2F0aW5nLWxhYmVsJykgPT0gLTEpID8gZmFsc2UgOiB0cnVlO1xuXG4gIGlmICghbWlycm9yRGl2KSB7XG4gICAgbWlycm9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbWlycm9yRGl2LmlkID0gSURfTUlSUk9SOy8vZG9jdW1lbnRfaWQgK25hbWUrICctLW1pcnJvci1kaXYnO1xuICAgICAgbWlycm9yRGl2LmNsYXNzTmFtZSA9IChlbnZpcm9tZW50X3Byb2QpID8gJ21pcnJvcl9jb2xvciBtaXJyb3Jfc2Nyb2xsIG1pcnJvci13aWR0aC1zY3JvbGwnIDogJ21pcnJvci13aWR0aC1zY3JvbGwnO1xuICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtaXJyb3JEaXYpO1xuICAgIGVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsbWlycm9yRGl2KTtcbiAgfVxuXG4gIHZhciBzY3JvbGx3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSBlbGVtZW50LnNjcm9sbFdpZHRoO1xuXG4gIHN0eWxlID0gbWlycm9yRGl2LnN0eWxlO1xuICBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGNvbXB1dGVkUGFyZW50RWxlbWVudCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgbGV0IG1hcmdpbl90b3AgPSBwYXJzZUludChjb21wdXRlZFsnbWFyZ2luVG9wJ10pXG4gIGxldCBtYXJnaW5fbGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkWydtYXJnaW5MZWZ0J10pXG5cbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgIT09ICdJTlBVVCcpe1xuICAgIHN0eWxlLndvcmRXcmFwID0gJ2JyZWFrLXdvcmQnOyAgLy8gb25seSBmb3IgdGV4dGFyZWEtc1xuICAgIHN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICB9ZWxzZXtcbiAgICBzdHlsZS53aGl0ZVNwYWNlID0gJ3ByZSc7XG4gIH1cbiAgLy8gcG9zaXRpb24gb2ZmLXNjcmVlblxuICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ICAvLyByZXF1aXJlZCB0byByZXR1cm4gY29vcmRpbmF0ZXMgcHJvcGVybHlcbiAgXG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gZ2V0IFBvc2l0aW9uIGZyb20gZWxlbWVudFxuICBcbiAgXG4gIGxldCBzY3Jyb2xsVG9wX2Jyb3dzZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gIFxuICAvL3N0eWxlLnRvcCA9ICgocmVjdC50b3Arc2Nycm9sbFRvcF9icm93c2VyKS0xKSAtIChwYXJzZUludChjb21wdXRlZFsnbWFyZ2luVG9wJ10pIC0gcGFyc2VJbnQoY29tcHV0ZWRbJ2JvcmRlclRvcFdpZHRoJ10pICkgKyAncHgnLy9wYXJzZUludChjb21wdXRlZC5ib3JkZXJUb3BXaWR0aCkgKyAncHgnOyAvLyAgZWxlbWVudC5vZmZzZXRUb3AgKyBwYXJzZUludChjb21wdXRlZC5ib3JkZXJUb3BXaWR0aCkgKyAncHgnO1xuICAvL3N0eWxlLnRvcCA9IGNvbXB1dGVkUGFyZW50RWxlbWVudFsndG9wJ107XG4gIHN0eWxlLnRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wKydweCc7XG4gIC8vc3R5bGUubGVmdCA9IHJlY3QubGVmdCAtIChwYXJzZUludChjb21wdXRlZFsnbWFyZ2luTGVmdCddKSAtICBwYXJzZUludChjb21wdXRlZFsnYm9yZGVyTGVmdFdpZHRoJ10pICkgKyAncHgnLy9wYXJzZUludChjb21wdXRlZC5ib3JkZXJMZWZ0V2lkdGgpICsgJ3B4JyAgIC8vIG1hcmdpbl9sZWZ0K1wicHhcIjsvL1wiNDAwcHhcIjtcbiAgLy9zdHlsZS5sZWZ0ID0gIGNvbXB1dGVkUGFyZW50RWxlbWVudFsnbGVmdCddO1xuICBzdHlsZS5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0KydweCc7XG4gIHN0eWxlLndpZHRoID0gcmVjdC53aWR0aCsncHgnOy8vIC0gKHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlckxlZnRXaWR0aCkgKyBwYXJzZUludChjb21wdXRlZC5ib3JkZXJSaWdodFdpZHRoKSkgKyAncHgnICAgLy8gbWFyZ2luX2xlZnQrXCJweFwiOy8vXCI0MDBweFwiO1xuICBzdHlsZS5oZWlnaHQgPSByZWN0LmhlaWdodCsncHgnOy8vIC0gKHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlclRvcFdpZHRoKSArIHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlckJvdHRvbVdpZHRoKSkgKyAncHgnICAgLy8gbWFyZ2luX2xlZnQrXCJweFwiOy8vXCI0MDBweFwiO1xuICBzdHlsZS52aXNpYmlsaXR5ID0ndmlzaWJsZSdcbiAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYoWydsZWZ0JywndG9wJ10uaW5kZXhPZihwcm9wLnRvTG93ZXJDYXNlKCkpID09PSAtMSlcbiAgICBzdHlsZVtwcm9wXSA9IGNvbXB1dGVkW3Byb3BdO1xuICB9KTtcbiAgXG4gIHN0eWxlLm92ZXJmbG93WCA9J2F1dG8nO1xuICBzdHlsZS5vdmVyZmxvd1kgPSdoaWRkZW4nO1xuICBzdHlsZS5tYXJnaW4gPSAnMHB4J1xuICAvL3N0eWxlLnBhZGRpbmcgPSAnMHB4J1xuICBzdHlsZS5ib3JkZXIgPSBjb21wdXRlZFsnYm9yZGVyJ107XG4gIHN0eWxlLmJvcmRlckNvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgLyogXG4gIGlmKGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09J2lucHV0Jyl7XG4gICAgc3R5bGUub3ZlcmZsb3dYID0nYXV0byc7XG4gICAgc3R5bGUub3ZlcmZsb3dZID0naGlkZGVuJztcbiAgfWVsc2V7XG4gICAgc3R5bGUub3ZlcmZsb3c9XCJ2aXNpYmxlXCJcbiAgfSovXG4gIFxuICAvLyBzdHlsZS5wYWRkaW5nUmlnaHQgPSAocGFyc2VJbnQoc3R5bGUucGFkZGluZ1JpZ2h0KSArIHNjcm9sbHdpZHRoIC0gcGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyUmlnaHRXaWR0aCkpICsncHgnO1xuICBsZXQgY3Vyc29yX2NvbnRhaW5lciA9IG1pcnJvckRpdi5xdWVyeVNlbGVjdG9yQWxsKCcuY3Vyc29yLWNvbnRhaW5lcicpO1xuICBsZXQgc2VsZWN0b3JzX2J5X3VzZXJzID0gbWlycm9yRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zZWxlY3RvcnNfYnlfdXNlcnMnKTtcbiAgbGV0IHZhbHVlX2VsZW1lbnQgPSAoWydURVhUQVJFQScsJ0lOUFVUJ10uaW5kZXhPZihlbGVtZW50Lm5vZGVOYW1lKT09LTEpID9lbGVtZW50LmlubmVySFRNTCA6ZWxlbWVudC52YWx1ZTtcblxuICBtaXJyb3JEaXYudGV4dENvbnRlbnQgPSB2YWx1ZV9lbGVtZW50LnN1YnN0cmluZygwLCBwb3NpdGlvbl9zdGFydCk7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSU5QVVQnKVxuICAgIG1pcnJvckRpdi50ZXh0Q29udGVudCA9IG1pcnJvckRpdi50ZXh0Q29udGVudC5yZXBsYWNlKC9cXHMvZywgXCJcXHUwMGEwXCIpO1xuICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgc3Bhbi5pZCA9IGVsZW1lbnQubm9kZU5hbWUgKyAnc3Bhbl9zZWxlY3Rpb25zJztcbiAgbGV0IHZhbHVlX3NwYW4gPSB2YWx1ZV9lbGVtZW50LnN1YnN0cmluZyhwb3NpdGlvbl9zdGFydCxwb3NpdGlvbl9lbmQpIHx8ICcnXG4gIHNwYW4udGV4dENvbnRlbnQgPSB2YWx1ZV9zcGFuOyAgLy8gfHwgYmVjYXVzZSBhIGNvbXBsZXRlbHkgZW1wdHkgZmF1eCBzcGFuIGRvZXNuJ3QgcmVuZGVyIGF0IGFsbFxuICAvL3NwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJsaWdodGdyZXlcIjtcbiAgbWlycm9yRGl2LmFwcGVuZENoaWxkKHNwYW4pO1xuICBcbiAgaWYoY3Vyc29yX2NvbnRhaW5lcil7XG4gICAgICBjdXJzb3JfY29udGFpbmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkX2N1cnNvciwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgIG1pcnJvckRpdi5hcHBlbmRDaGlsZChjaGlsZF9jdXJzb3IpO1xuICAgIH0pXG4gIH1cbiAgXG4gIGlmKHNlbGVjdG9yc19ieV91c2Vycyl7XG4gICAgc2VsZWN0b3JzX2J5X3VzZXJzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkX3NlbGVjdGlvbiwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgIG1pcnJvckRpdi5hcHBlbmRDaGlsZChjaGlsZF9zZWxlY3Rpb24pO1xuICAgIH0pXG4gIH1cbiAgXG4gIGxldCB2YWx1ZV9lbmQgPSB2YWx1ZV9lbGVtZW50LnN1YnN0cmluZyhwb3NpdGlvbl9lbmQpICB8fCAnJztcbiAgdmFyIHNwYW5fZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBtaXJyb3JEaXYuYXBwZW5kQ2hpbGQoc3Bhbl9lbmQpO1xuICBzcGFuX2VuZC50ZXh0Q29udGVudCA9IHZhbHVlX2VuZDtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBnZXQgUG9zaXRpb24gZnJvbSBlbGVtZW50XG4gIHZhciBjb29yZGluYXRlcyA9IHtcbiAgICBzdGFydCA6IHtcbiAgICAgICAgdG9wOiBzcGFuLm9mZnNldFRvcCxcbiAgICAgICAgbGVmdDogIHNwYW4ub2Zmc2V0TGVmdFxuICAgIH0sXG4gICAgZW5kIDoge1xuICAgICAgICB0b3A6IHNwYW5fZW5kLm9mZnNldFRvcCwgLy8rIHBhcnNlSW50KGNvbXB1dGVkWydib3JkZXJUb3BXaWR0aCddKSxcbiAgICAgICAgbGVmdDogIHNwYW5fZW5kLm9mZnNldExlZnQgLy8gKyBwYXJzZUludChjb21wdXRlZFsnYm9yZGVyTGVmdFdpZHRoJ10pXG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjb29yZGluYXRlcztcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGUoZWwsc3R5bGVQcm9wKVxue1xuICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSlcbiAgICAgICAgdmFyIHkgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLG51bGwpLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wKTtcbiAgICByZXR1cm4geTtcbn1cblxuXG5mdW5jdGlvbiBnZXREb2N1bWVudChjb2xsZWN0aW9uLG1vZHVsZV9pZCl7XG4gIGNydWQucmVhZERvY3VtZW50KHtcbiAgICAnY29sbGVjdGlvbic6IGNvbGxlY3Rpb24sXG4gICAgJ2RvY3VtZW50X2lkJzogbW9kdWxlX2lkXG4gIH0pXG59XG5cbnNvY2tldC5saXN0ZW4oJ3JlYWREb2N1bWVudCcsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBsZXQgY3Vyc29yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmN1cnNvci1mbGFnW2RhdGEtZG9jdW1lbnRfaWQ9XCInK2RhdGFbJ2RvY3VtZW50X2lkJ10rJ1wiXScpXG4gICAgaWYgKGN1cnNvcilcbiAgICAgIGN1cnNvci5pbm5lckhUTUwgPSBkYXRhLnJlc3VsdFtjdXJzb3IuZ2V0QXR0cmlidXRlKCduYW1lJyldXG59KVxuXG5cbmZ1bmN0aW9uIGRyYXdfY3Vyc29yKGpzb24pe1xuICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcImRyYXcgQ3Vyc29yIFwiLGpzb25dLGRlYnVnKVxuICAgICAgICBsZXQgZWxlbWVudCA9IGpzb25bJ2VsZW1lbnQnXTtcbiAgICAgICAgbGV0IGFjdGl2YXRlX2N1cnNvciA9IChlbGVtZW50LmRhdGFzZXRbJ2N1cnNvcnMnXSk/ZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTp0cnVlO1xuICAgICAgICBpZihhY3RpdmF0ZV9jdXJzb3Ipe1xuICAgICAgICAgIGxldCBzdGFydCA9IGpzb25bJ3N0YXJ0UG9zaXRpb24nXVxuICAgICAgICAgIGxldCBlbmQgPSBqc29uWydlbmRQb3NpdG9uJ11cbiAgICAgICAgICBsZXQgc29ja2V0X2lkID0ganNvblsnY2xpZW50SWQnXVxuICAgICAgICAgIGxldCBkb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykgfHwgJyc7XG4gICAgICAgICAgaWYoZG9jdW1lbnRfaWQhPScnKXtcbiAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoXCJhY3Rpb24gZG9jdW1lbnRfaWQgXCIgKyBkb2N1bWVudF9pZCxkZWJ1ZylcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXSA9PSAndW5kZWZpbmVkJyB8fCBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddID09ICcnKVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ10gPSBDb2NyZWF0ZVV0aWxzQ3Vyc29yLmdlbmVyYXRlVVVJRChsZW5ndGhfdXVpZClcbiAgICAgICAgICAgIGxldCBjb29yZGluYXRlcyA9IGdldENhcmV0Q29vcmRpbmF0ZXMoZWxlbWVudCxzdGFydCxlbmQpO1xuICAgICAgICAgICAgaWYoIWNvb3JkaW5hdGVzKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgIGxldCBpZF9taXJyb3IgPSBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddOyAvL2RvY3VtZW50X2lkK25hbWUrJy0tbWlycm9yLWRpdidcbiAgICAgICAgICAgIGxldCBtaV9taXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpXG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uX3VzZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpZGVudGlmeSA9ICdfJytpZF9taXJyb3I7XG4gICAgICAgICAgICBsZXQgdXNlciA9ICh0eXBlb2YoanNvbikgIT0gJ3VuZGVmaW5lZCcgJiYganNvbi5oYXNPd25Qcm9wZXJ0eSgndXNlcicpKSA/IGpzb24udXNlciA6IGZhbHNlXG4gICAgICAgICAgICBsZXQgdXNlcl9pZCA9ICh0eXBlb2YoanNvbikgIT0gJ3VuZGVmaW5lZCcgJiYganNvbi5oYXNPd25Qcm9wZXJ0eSgndXNlcl9pZCcpICkgPyAgdXNlci51c2VyX2lkIDogZmFsc2VcbiAgICAgICAgICAgIGlmIChzb2NrZXRfaWQpe1xuICAgICAgICAgICAgICAgLy9pZihkYXRhICYmIGRhdGEuaGFzT3duUHJvcGVydHkoJ2lkX21pcnJvcicpKXtcbiAgICAgICAgICAgICAgICAgdmFyIGN1cnNvcmVzX290aGVyX2VsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3NvY2tldF8nK3NvY2tldF9pZCtpZGVudGlmeSlcbiAgICAgICAgICAgICAgICAgY3Vyc29yZXNfb3RoZXJfZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihjaGlsZF9jdXJzb3IsIGluZGV4LCBhcnJheSl7XG4gICAgICAgICAgICAgICAgICAgaWYoY2hpbGRfY3Vyc29yLnBhcmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpICE9IGlkX21pcnJvcil7XG4gICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFwicmVtb3ZlIG9sZCBjdXJzb3Igb3RoZXJzIGVsZW1lbnRzXCIsZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRfY3Vyc29yLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgIGN1cnNvciA9IG1pX21pcnJvci5xdWVyeVNlbGVjdG9yKCcuY3Vyc29yLWNvbnRhaW5lciNzb2NrZXRfJytzb2NrZXRfaWQraWRlbnRpZnkpO1xuICAgICAgICAgICAgICAgICBpZighY3Vyc29yICAmJiBqc29uLmhhc093blByb3BlcnR5KCd1c2VyJykpe1xuICAgICAgICAgICAgICAgICAgICBpZih1c2VyKXtcbiAgICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFwiQ3JlYXRlIEN1cnNvclwiLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJzb3JfdGVtcGxhdGUgPSAnPGRpdiBzdHlsZT1cImNvbG9yOmJsdWU7XCIgY2xhc3M9XCJjdXJzb3ItY29udGFpbmVyXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJzb2NrZXRfJytzb2NrZXRfaWQraWRlbnRpZnkrJ1wiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID48ZGl2IGNsYXNzPVwiY3Vyc29yXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicrdXNlci5jb2xvcisnXCI+PC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImN1cnNvci1mbGFnXCIgZGF0YS1jb2xsZWN0aW9uPVwidXNlcnNcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwibmFtZVwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdXNlcl9uYW1lPVwiJyt1c2VyLm5hbWUrJ1wiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdXNlcl9jb2xvcj1cIicrdXNlci5jb2xvcisnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zb2NrZXRfaWQ9XCInK3NvY2tldF9pZCsnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1pZF9taXJyb3I9XCInK2lkX21pcnJvcisnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1kb2N1bWVudF9pZD1cIicrdXNlcl9pZCsnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicrdXNlci5jb2xvcisnXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZz4nK3VzZXIubmFtZSsnPC9kaXY+PC9kaXY+JztcbiAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3IuaW5uZXJIVE1MID0gY3Vyc29yX3RlbXBsYXRlICsgbWlfbWlycm9yLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZih1c2VyX2lkKXtcbiAgICAgICAgICAgICAgICAgICAgIC8vIHNpIHRpZW5lIHVzZXJfaWQgYWN0dWFsaXphIGVsIG5vbWJyZSBkZWwgY3Vyc29yIHVzYW5kbyBjcnVkXG4gICAgICAgICAgICAgICAgICAgICAgY3J1ZC5yZWFkRG9jdW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbGxlY3Rpb24nIDogJ3VzZXJzJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAnZG9jdW1lbnRfaWQnOiB1c2VyX2lkXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3Vyc29yID0gbWlfbWlycm9yLnF1ZXJ5U2VsZWN0b3IoJy5jdXJzb3ItY29udGFpbmVyI3NvY2tldF8nK3NvY2tldF9pZCtpZGVudGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihjdXJzb3Ipe1xuICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcIlVwZGF0ZSBDdXJzb3JcIixjdXJzb3IsY29vcmRpbmF0ZXNdLGRlYnVnKVxuICAgICAgICAgICAgICBsZXQgZm9udF9zaXplID0gZ2V0U3R5bGUoZWxlbWVudCwnZm9udC1zaXplJylcbiAgICAgICAgICAgICAgZm9udF9zaXplID0gcGFyc2VGbG9hdChmb250X3NpemUuc3Vic3RyaW5nKDAsZm9udF9zaXplLmxlbmd0aC0yKSk7XG4gICAgICAgICAgICAgIGxldCBjdXJzb3JfaGVpZ2h0ID0gKCAoZm9udF9zaXplICogMTEyLjUpIC8gMTAwKVxuICAgICAgICAgICAgICBsZXQgbXlfY3Vyc29yID0gY3Vyc29yLnF1ZXJ5U2VsZWN0b3IoJy5jdXJzb3InKVxuICAgICAgICAgICAgICBjdXJzb3IuZGF0YXNldC5zdGFydCA9IHN0YXJ0XG4gICAgICAgICAgICAgIGN1cnNvci5kYXRhc2V0LmVuZCA9IGVuZFxuICAgICAgICAgICAgICBjdXJzb3IuZGF0YXNldC5zb2NrZXRfaWQgPSBzb2NrZXRfaWRcbiAgICAgICAgICAgICAgLypjdXJzb3IuZGF0YXNldC51c2VyX25hbWUgPSB1c2VyLm5hbWVcbiAgICAgICAgICAgICAgY3Vyc29yLmRhdGFzZXQudXNlcl9jb2xvciA9IHVzZXIuY29sb3IqL1xuICBcbiAgICAgICAgICAgICAgY3Vyc29yLnN0eWxlW1widG9wXCJdID0gY29vcmRpbmF0ZXMuZW5kLnRvcCtcInB4XCI7IFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY3Vyc29yLnN0eWxlW1wid2lkdGhcIl0gPSBcIjJweFwiOyAgLy8ycHhcbiAgICAgICAgICAgICAgbXlfY3Vyc29yLnN0eWxlW1wiaGVpZ2h0XCJdID0gY3Vyc29yX2hlaWdodCtcInB4XCI7IFxuICAgICAgICAgICAgICBjdXJzb3Iuc3R5bGVbXCJsZWZ0XCJdID0gY29vcmRpbmF0ZXMuZW5kLmxlZnQrXCJweFwiOyBcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vYWRkIHNlbGVjdGlvbnNcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWwtJytzb2NrZXRfaWQraWRlbnRpZnkpO1xuICAgICAgICAgICAgICAgIGlmKChzdGFydCAhPSBlbmQpICYmIHVzZXIgKXtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWwtJytzb2NrZXRfaWQraWRlbnRpZnkpXG4gICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZWN0aW9uX3VzZXIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nX3JpZ2h0ID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtcInBhZGRpbmdSaWdodFwiXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIuaWQgPSAnc2VsLScrc29ja2V0X2lkK2lkZW50aWZ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIuY2xhc3NOYW1lPSdzZWxlY3RvcnNfYnlfdXNlcnMnXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVfbWlycm9yID0gZ2V0Q29tcHV0ZWRTdHlsZShtaV9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlci5zdHlsZVtcInBvc2l0aW9uXCJdID0gXCJhYnNvbHV0ZVwiOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyLnN0eWxlW1widG9wXCJdID0gc3R5bGVfbWlycm9yLnBhZGRpbmdUb3A7IFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIuc3R5bGVbXCJsZWZ0XCJdID0gc3R5bGVfbWlycm9yLnBhZGRpbmdMZWZ0OyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyLnN0eWxlW1wicGFkZGluZy1yaWdodFwiXSA9IHNjcm9sbHdpZHRoK3BhZGRpbmdfcmlnaHQrXCJweFwiOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pX21pcnJvci5pbnNlcnRCZWZvcmUoc2VsZWN0aW9uX3VzZXIsIG1pX21pcnJvci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uX3NwYW5fYnlfdXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fc3Bhbl9ieV91c2VyLmlkID0gJ3NlbGVjdGlvbi0nK3NvY2tldF9pZCtpZGVudGlmeTtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fc3Bhbl9ieV91c2VyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHVzZXIuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlX2VsZW1lbnQgPSAoWydURVhUQVJFQScsJ0lOUFVUJ10uaW5kZXhPZihlbGVtZW50Lm5vZGVOYW1lKT09LTEpID9lbGVtZW50LmlubmVySFRNTCA6ZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlci50ZXh0Q29udGVudCA9IHZhbHVlX2VsZW1lbnQuc3Vic3RyaW5nKDAsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVfc3Bhbl9zZWxlY3Rpb24gPSB2YWx1ZV9lbGVtZW50LnN1YnN0cmluZyhzdGFydCxlbmQpIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZWxlY3Rpb24gXCIsdmFsdWVfc3Bhbl9zZWxlY3Rpb24sc3RhcnQsZW5kKVxuICAgICAgICAgICAgICAgICAgICAgIC8vc2VsZWN0aW9uX3NwYW5fYnlfdXNlci5zdHlsZS5vcGFjaXR5ID0gMC41O1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl9zcGFuX2J5X3VzZXIudGV4dENvbnRlbnQgPSB2YWx1ZV9zcGFuX3NlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlci5hcHBlbmRDaGlsZChzZWxlY3Rpb25fc3Bhbl9ieV91c2VyKVxuICAgICAgICAgICAgICAgIH0vL2VuZCBTZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgIGlmKHNlbGVjdGlvbl91c2VyKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfS8vZW5kIGlmIGRvY3VtZW50X2lkXG4gICAgICAgIH0vL2VuZCBhY3RpdmF0ZV9jdXJzb3JzXG59Ly9kcmF3X2N1cnNvclxuXG5mdW5jdGlvbiByZWZyZXNoX21pcnJvcihlbGVtZW50KXtcbiAgdmFyIGlkX21pcnJvciA9ICcnXG4gIGxldCBkb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykgfHwgJyc7XG4gIGlmKGRvY3VtZW50X2lkIT0nJyl7XG4gICAgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICBpZihlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddKVxuICAgICAgaWRfbWlycm9yID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXVxuICAgICAgZWxzZSBcbiAgICAgIHJldHVybjtcbiAgICAvL2NvbnNvbGUubG9nKFwiUmVmcmVzaCBcIixpZF9taXJyb3IpXG4gICAgdmFyIG1pX21pcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcilcbiAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcInJlZnJlc2hfbWlycm9yIFwiLG1pX21pcnJvcl0sZGVidWcpXG4gICAgdmFyIHNlbGVjdG9yX2VsZW1lbnQgPSBlbGVtZW50Lm5vZGVOYW1lK1wiW25hbWU9J1wiK25hbWUrXCInXVtkYXRhLWRvY3VtZW50X2lkPSdcIitkb2N1bWVudF9pZCtcIiddXCJcbiAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcInNlbGVjdG9yIC0+IFwiK3NlbGVjdG9yX2VsZW1lbnRdLGRlYnVnKVxuICAgIFxuICAgICAgaWYobWlfbWlycm9yKXtcbiAgICAgICAgY29tcHV0ZWQgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICBzdHlsZSA9IG1pX21pcnJvci5zdHlsZVxuICAgICAgICBzdHlsZS53aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSAocGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyTGVmdFdpZHRoKSArIHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlclJpZ2h0V2lkdGgpKSArICdweCdcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSAocGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyVG9wV2lkdGgpICsgcGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyQm90dG9tV2lkdGgpKSArICdweCdcbiAgICAgICAgdmFyIGN1cnNvcl9jb250YWluZXIgPSBtaV9taXJyb3IucXVlcnlTZWxlY3RvckFsbCgnLmN1cnNvci1jb250YWluZXInKTtcbiAgICAgICAgY3Vyc29yX2NvbnRhaW5lci5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZF9jdXJzb3IsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSRWRyYXcgY3Vyc29yXCIpXG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkX2N1cnNvci5xdWVyeVNlbGVjdG9yKCcuY3Vyc29yLWZsYWcnKTtcbiAgICAgICAgbGV0IGRhdGFzZXRfY2hpbGQgPSBjaGlsZC5kYXRhc2V0O1xuICAgICAgICBsZXQgZGF0YXNldCA9IGNoaWxkX2N1cnNvci5kYXRhc2V0O1xuICAgICAgICAgIGRyYXdfY3Vyc29yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbjpkYXRhc2V0LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvc2l0b246ZGF0YXNldC5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQgOiBkYXRhc2V0LnNvY2tldF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyOntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbG9yJzpkYXRhc2V0X2NoaWxkLnVzZXJfY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzpkYXRhc2V0LnVzZXJfbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICB9XG4gIH0vL2VuZCBkb2N1bWVudFxufS8vZW5kIHZlcmlmeSBcblxuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjYWxjdWxhdGVfbG9jYWxfY3Vyc29ycyhlbGVtZW50LGNvdW50KXtcbiAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFwiY291bnQgXCIrY291bnQsZGVidWcpXG4gICAgICAgICAgbGV0IG15X3N0YXJ0ID0gKCAhIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkgID8gZWxlbWVudC5zZWxlY3Rpb25TdGFydCA6IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic2VsZWN0aW9uX3N0YXJ0XCIpKTtcbiAgICAgICAgICAvL2xldCBteV9zdGFydCAgID0gZWxlbWVudC5zZWxlY3Rpb25TdGFydFxuICAgICAgICAgIGxldCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB8fCAnJztcbiAgICAgICAgICBsZXQgZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpIHx8ICcnO1xuICAgICAgICAgIGxldCBjb2xsZWN0aW9uID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpIHx8ICcnO1xuICAgICAgICAgIGxldCBzZWxlY3RvciA9ICdbZGF0YS1jb2xsZWN0aW9uPVwiJytjb2xsZWN0aW9uKydcIl1bZGF0YS1kb2N1bWVudF9pZD1cIicrZG9jdW1lbnRfaWQrJ1wiXVtuYW1lPVwiJytuYW1lKydcIl0nXG4gICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107IC8vbGV0IGlkX21pcnJvciA9IGRvY3VtZW50X2lkK25hbWUrJy0tbWlycm9yLWRpdic7XG4gICAgICAgICAgbGV0IG1pcnJvckRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcik7XG4gICAgICAgICAgbGV0IGN1cnNvcl9jb250YWluZXIgPSAobWlycm9yRGl2KSA/IG1pcnJvckRpdi5xdWVyeVNlbGVjdG9yQWxsKCcuY3Vyc29yLWNvbnRhaW5lcicpIDogbnVsbDtcbiAgICAgICAgICBpZihjdXJzb3JfY29udGFpbmVyKXtcbiAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lcnNfY3Vyc29ycyA9IFtdO1xuICAgICAgICAgICAgICBjdXJzb3JfY29udGFpbmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkX2N1cnNvciwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBwYXJzZUludChjaGlsZF9jdXJzb3IuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YXJ0JykpO1xuICAgICAgICAgICAgICAgICAgbGV0IHVzZXJfbmFtZSA9IGNoaWxkX2N1cnNvci5nZXRBdHRyaWJ1dGUoJ2RhdGEtdXNlcl9uYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoW1wibXlfc3RhcnQgbG9jYWxcIixteV9zdGFydCwnc3RhcnQgY3Vyc29yICcrdXNlcl9uYW1lK1wiID0gXCIsc3RhcnRdLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgaWYoc3RhcnQgPiBteV9zdGFydCAmJiBjb250YWluZXJzX2N1cnNvcnMuaW5kZXhPZih1c2VyX25hbWUpID09IC0xICl7XG4gICAgICAgICAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoXCJFcyBtYXlvclwiLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gcGFyc2VJbnQoY2hpbGRfY3Vyc29yLmdldEF0dHJpYnV0ZSgnZGF0YS1lbmQnKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3Nfc3RhcnQgPSBzdGFydCtjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc19lbmQgPSBlbmQrY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoWydwb3Nfc3RhcnQnLHBvc19zdGFydCwncG9zX2VuZCcscG9zX2VuZF0sZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhc2V0ID0gY2hpbGRfY3Vyc29yLnF1ZXJ5U2VsZWN0b3IoJy5jdXJzb3ItZmxhZycpLmRhdGFzZXRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsaWVudElkID0gZGF0YXNldC5zb2NrZXRfaWQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBqc29uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb246cG9zX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3NpdG9uOnBvc19lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudElkOmNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndXNlcic6e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbG9yJzpkYXRhc2V0LnVzZXJfY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6ZGF0YXNldC51c2VyX25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcInNlbnQgRHJhdyBDdXJzb3IgXCIsanNvbl0sZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGRyYXdfY3Vyc29yKGpzb24pO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJzX2N1cnNvcnMucHVzaCh1c2VyX25hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9taXJyb3JEaXYuYXBwZW5kQ2hpbGQoY2hpbGRfY3Vyc29yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q3Vyc29yRWwoZWxlbWVudCl7XG4gIGxldCBmb3JtdWxhcmlvID0gZ2V0UGFyZW50cyhlbGVtZW50LCdmb3JtJylcbiAgICAgICAgICBsZXQgcmVhbHRpbWUgPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1yZWFsdGltZScpID8gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVhbHRpbWUnKSA6ICd0cnVlJztcbiAgICAgICAgICBpZiggcmVhbHRpbWUgPT0ndHJ1ZScgfHwgIChmb3JtdWxhcmlvICYmIGZvcm11bGFyaW8uZ2V0QXR0cmlidXRlKCdkYXRhLXJlYWx0aW1lJykgPT0ndHJ1ZScgKSApe1xuICAgICAgICAgICAgaWYocmVhbHRpbWUgPT0nZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoW1wiSW5pdCBFdmVudHMgXCIsZWxlbWVudF0sZGVidWcpXG4gICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IGVsZW1lbnQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBjb29yZGluYXRlcyA9IGdldENhcmV0Q29vcmRpbmF0ZXMoZWxlbWVudCxzdGFydCxlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGV2ZW50LmlucHV0VHlwZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCdUZXh0JykubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Nhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYoY291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNhbGN1bGF0ZV9sb2NhbF9jdXJzb3JzKHRoaXMsY291bnQpXG4gICAgICAgICAgICAgICAgICB9LGZhbHNlKVxuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChbXCJNb3ZlIFNjcm9sbCBcIixlbGVtZW50XSx0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICAgICAgICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IG1pX21pcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICBpZihtaV9taXJyb3Ipe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlfbWlycm9yLnNjcm9sbFRvKGVsZW1lbnQuc2Nyb2xsTGVmdCxlbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9yZXNpemVcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3V0cHV0c2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50X211bHRpY3Vyc29ycy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50X2ZvciwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnRfZm9yLmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWRfbWlycm9yID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcIlJlc2l6ZSBpZF9taXJyb3IgLT4gXCIraWRfbWlycm9yXSxkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaV9taXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtaV9taXJyb3Ipe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3Iuc3R5bGVbXCJ3aWR0aFwiXSA9IGVsZW1lbnRfZm9yLm9mZnNldFdpZHRoK1wicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlfbWlycm9yLnN0eWxlW1wiaGVpZ2h0XCJdID0gZWxlbWVudF9mb3Iub2Zmc2V0SGVpZ2h0K1wicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgaXNGb2N1c2VkID0gKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnRfZm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92ZXJpZnlfY3Vyc29yKGVsZW1lbnRfZm9yLGlzRm9jdXNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRm9jdXNlZCA9IChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNGb2N1c2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENhcmV0Q29vcmRpbmF0ZXMoZWxlbWVudCxlbGVtZW50LnNlbGVjdGlvblN0YXJ0LGVsZW1lbnQuc2VsZWN0aW9uRW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoX21pcnJvcihlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzaXplT2JzZXJ2ZXIob3V0cHV0c2l6ZSkub2JzZXJ2ZShlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgLy9pZiAoZWxlbWVudC5ub2RlTmFtZSA9PSAnSU5QVVQnKXtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRvY3VtZW50X2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWlfbWlycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWlfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3Iuc2Nyb2xsVG8oZWxlbWVudC5zY3JvbGxMZWZ0LGVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JyxmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWRfbWlycm9yID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaV9taXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtaV9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pX21pcnJvci5zY3JvbGxUbyhlbGVtZW50LnNjcm9sbExlZnQsZWxlbWVudC5zY3JvbGxUb3ApO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJyxmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImtleWRvd24gTCxUID0+IFwiLGVsZW1lbnQuc2Nyb2xsTGVmdCxlbGVtZW50LnNjcm9sbFRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWRfbWlycm9yID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pX21pcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobWlfbWlycm9yKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3Iuc2Nyb2xsVG8oZWxlbWVudC5zY3JvbGxMZWZ0LGVsZW1lbnQuc2Nyb2xsVG9wKTsgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfbWlycm9yKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJrZXl1cCBMLFQgPT4gXCIsZWxlbWVudC5zY3JvbGxMZWZ0LGVsZW1lbnQuc2Nyb2xsVG9wKVxuICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWlfbWlycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWlfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3Iuc2Nyb2xsVG8oZWxlbWVudC5zY3JvbGxMZWZ0LGVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICB9Ly9lbmQgaWYgcmVhbHRpbWUgVFJVRVxufVxuXG52YXIgaW5pdGlhbGl6ZV9tdWx0aWN1cnNvciA9IGZ1bmN0aW9uKGVsZW1lbnRfbXVsdGljdXJzb3JzKXtcbiAgICAgIGVsZW1lbnRfbXVsdGljdXJzb3JzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgIGluaXRDdXJzb3JFbChlbGVtZW50KTtcbiAgICAgIH0pOyAvLyBlbGVtZW50X211bHRpY3Vyc29ycy5mb3JFYWNoXG59Ly9lbmQgaW5pdGlhbGl6ZV9tdWx0aWN1cnNvciBcblxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oZSl7IFxuICAvL2NvbnNvbGUubG9nKFwicmVzaXplIHdpbmRvd3NcIilcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbWlycm9yX2lkXScpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgIHJlZnJlc2hfbWlycm9yKGVsZW1lbnQpXG4gIH0pOyAvLyBlbGVtZW50X211bHRpY3Vyc29ycy5mb3JFYWNoXG59LCB0cnVlKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uKGUpeyBcbiAgLy9jb25zb2xlLmxvZyhcIlNjcm9sbCBcIilcbiAgLy9jb25zb2xlLmxvZyhcInNjcm9sbCB3aW5kb3dzXCIsZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKVxuICAvL2VsZW1lbnRfbXVsdGljdXJzb3JzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1taXJyb3JfaWRdJykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgcmVmcmVzaF9taXJyb3IoZWxlbWVudClcbiAgfSk7IC8vIGVsZW1lbnRfbXVsdGljdXJzb3JzLmZvckVhY2hcbiAgXG4gIFxufSwgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGluaXRDdXJzb3JFbGVtZW50cyhjb250YWluZXIpIHtcbiAgbGV0IG1haW5Db250YWluZXIgPSBjb250YWluZXIgfHwgd2luZG93O1xuICBcbiAgaWYgKCFtYWluQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIGxldCBlbGVtZW50cyA9IG1haW5Db250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtcmVhbHRpbWU9dHJ1ZV0nKTtcbiAgXG4gIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgIGluaXRDdXJzb3JFbChlbCk7XG4gIH0pXG59XG5cbmlmKGRlYnVnKVxuICBjb25zb2xlLmxvZyhcImVsZW1lbnRzIHRvIElOSVQgLT4gXCIsZWxlbWVudF9tdWx0aWN1cnNvcnMpXG5pbml0aWFsaXplX211bHRpY3Vyc29yKGVsZW1lbnRfbXVsdGljdXJzb3JzKTtcblxuLy8gQ29DcmVhdGVJbml0LnJlZ2lzdGVyX29sZCgnW2RhdGEtcmVhbHRpbWU9dHJ1ZV0nLGluaXRDdXJzb3JFbCk7XG4vLyBDb0NyZWF0ZUluaXQucmVnaXN0ZXIoJ0NvQ3JlYXRlQ3Vyc29yJywgd2luZG93LCBpbml0Q3Vyc29yRWxlbWVudHMpO1xuXG5vYnNlcnZlci5pbml0KHsgXG5cdG5hbWU6ICdDb0NyZWF0ZUN1cnNvcicsIFxuXHRvYnNlcnZlOiBbJ3N1YnRyZWUnLCAnY2hpbGRMaXN0J10sXG5cdGluY2x1ZGU6ICdbZGF0YS1jb2xsZWN0aW9uXVtkYXRhLWRvY3VtZW50X2lkXVtuYW1lXVtkYXRhLXJlYWx0aW1lPXRydWVdJywgXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikge1xuXHRcdGluaXRDdXJzb3JFbGVtZW50cyhtdXRhdGlvbi50YXJnZXQpXG5cdH1cbn0pO1xuXG5jb25zdCBDb0NyZWF0ZUN1cnNvcnMgPSB7IGRyYXdfY3Vyc29yLCByZWZyZXNoX21pcnJvciwgcmVjYWxjdWxhdGVfbG9jYWxfY3Vyc29ycyB9O1xuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVDdXJzb3JzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-cursors/src/index.js\n")},"../CoCreate-form/src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _src = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-observer/src */ \"../CoCreate-observer/src/index.js\"));\n\nvar _utils = _interopRequireDefault(__webpack_require__(/*! ../../../CoCreateJS/src/utils */ \"../../CoCreateJS/src/utils.js\"));\n\nvar _src2 = __webpack_require__(/*! ../../../CoCreateJS/src */ \"../../CoCreateJS/src/index.js\");\n\nvar _src3 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-action/src */ \"../CoCreate-action/src/index.js\"));\n\nvar _utils2 = _interopRequireDefault(__webpack_require__(/*! ./utils */ \"../CoCreate-form/src/utils.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import crdt from '../../CoCreate-crdt/src'\n// import text from '../../CoCreate-text/src'\nconst CoCreateForm = {\n  requestAttr: \"data-document_request\",\n  selectors: [],\n  modules: [],\n  init: function ({\n    name,\n    selector,\n    callback\n  }) {\n    this.modules.push({\n      name,\n      selector,\n      callback\n    });\n\n    if (selector) {\n      this.selectors.push(selector);\n    }\n  },\n  get: function () {\n    return {\n      selectors: this.selectors\n    };\n  },\n  checkID: function (element, attr = \"data-document_id\") {\n    let document_id = element.getAttribute(attr) || \"\";\n\n    if (document_id === \"\" || document_id === \"pending\" || !_utils.default.checkValue(document_id)) {\n      return false;\n    }\n\n    return true;\n  },\n  request: function ({\n    form,\n    element,\n    nameAttr,\n    value\n  }) {\n    if (!form && element) {\n      form = element.closest('form');\n    }\n\n    if (form) {\n      this.__requestDocumentIdOfForm(form);\n    } else if (element) {\n      nameAttr = nameAttr || \"name\";\n\n      this.__requestDocumentId(element, nameAttr, value);\n    }\n  },\n  initElement: function (container) {\n    const __container = container || document;\n\n    if (!__container.querySelectorAll) {\n      return;\n    }\n\n    let forms = __container.querySelectorAll('form');\n\n    if (forms.length === 0 && __container != document && __container.tagName === \"FORM\") {\n      forms = [__container];\n    }\n\n    forms.forEach(form => {\n      _utils2.default.setAttribute(form);\n\n      _utils2.default.disableAutoFill(form);\n    });\n  },\n  __init: function () {\n    const forms = document.querySelectorAll('form');\n\n    this.__initEvent();\n\n    forms.forEach(form => {\n      _utils2.default.setAttribute(form);\n    });\n  },\n  __initEvent: function () {\n    const self = this;\n\n    _src2.socket.listen('createDocument', function (data) {\n      const {\n        metadata\n      } = data;\n\n      self.__receivedDocumentId(data);\n\n      if (metadata == \"createDocument-action\") {//. dispatch EndAction\n      }\n    });\n\n    _src2.socket.listen('deleteDocument', function (data) {\n      const {\n        metadata\n      } = data;\n\n      if (metadata === \"deleteDocument-action\") {//.dispatch End Action\n      }\n    });\n\n    document.addEventListener('clicked-submitBtn', function (event) {\n      const {\n        element\n      } = event.detail;\n      self.modules.forEach(({\n        selector,\n        callback\n      }) => {\n        if (callback && element.matches(selector)) {\n          callback.call(null, element);\n        }\n      });\n    });\n  },\n  __deleteDocumentAction: function (btn) {\n    const collection = btn.getAttribute('data-collection');\n    const document_id = btn.getAttribute('data-document_id');\n\n    if (_utils.default.checkValue(collection) && _utils.default.checkValue(document_id)) {\n      _src2.crud.deleteDocument({\n        'collection': collection,\n        'document_id': document_id,\n        'metadata': 'deleteDocument-action'\n      });\n\n      document.dispatchEvent(new CustomEvent('deletedDocument', {\n        detail: {}\n      }));\n    }\n  },\n  __deleteDocumentsAction: function (btn) {\n    const collection = btn.getAttribute('data-collection');\n    const selector = btn.getAttribute('data-document_target');\n    if (!selector) return;\n    const selectedEls = document.querySelectorAll(selector);\n\n    if (_utils2.default.checkValue(collection)) {\n      selectedEls.forEach(el => {\n        const document_id = el.getAttribute('data-document_id');\n\n        if (_utils.default.checkValue(document_id)) {\n          _src2.crud.deleteDocument({\n            'collection': collection,\n            'document_id': document_id,\n            'metadata': ''\n          });\n        }\n      });\n      document.dispatchEvent(new CustomEvent('deletedDocuments', {\n        detail: {}\n      }));\n    }\n  },\n  __createDocumentAction: function (btn) {\n    const form = btn.closest(\"form\");\n    const self = this;\n\n    let collections = _utils2.default.getCOllections(form);\n\n    collections.forEach(collection => {\n      let data = _utils2.default.getFormData(form, \"\", collection);\n\n      if (Object.keys(data).length == 0 && data.constructor === Object) {\n        return;\n      }\n\n      if (_utils.default.checkValue(collection)) {\n        _src2.crud.createDocument({\n          'collection': collection,\n          'data': data,\n          'metadata': 'createDocument-action',\n          'element': 'empty'\n        });\n\n        document.dispatchEvent(new CustomEvent('createdDocument', {\n          detail: {}\n        }));\n      }\n    });\n  },\n  __saveDocumentAction: function (btn) {\n    const form = btn.closest(\"form\");\n\n    if (!_utils2.default.checkFormValidate(form)) {\n      alert('Values are not unique');\n      return;\n    }\n\n    const selectors = this.selectors || [];\n    const elements = form.querySelectorAll(selectors.join(','));\n    let request_document_id = false;\n\n    for (var i = 0; i < elements.length; i++) {\n      let el = elements[i];\n      const data_document_id = el.getAttribute('data-document_id');\n\n      if (el.getAttribute('data-save_value') == 'false') {\n        continue;\n      }\n\n      if (!data_document_id) {\n        if (el.getAttribute('name')) {\n          request_document_id = true;\n        }\n\n        continue;\n      }\n\n      if (input.isUsageY(el)) {\n        continue;\n      }\n\n      if (_utils2.default.isTemplateInput(el)) return;\n      var new_event = new CustomEvent(\"clicked-submitBtn\", {\n        bubbles: true,\n        detail: {\n          type: \"submitBtn\",\n          element: el\n        }\n      });\n      el.dispatchEvent(new_event);\n    }\n\n    if (request_document_id) {\n      this.requestDocumentIdOfForm(form);\n    }\n\n    document.dispatchEvent(new CustomEvent('savedDocument', {\n      detail: {}\n    }));\n  },\n  __requestDocumentId: function (element, nameAttr = \"name\", value = null) {\n    const collection = element.getAttribute('data-collection');\n    const name = element.getAttribute(nameAttr);\n    if (!collection || !name) return;\n\n    const request_id = _utils.default.generateUUID();\n\n    element.setAttribute(this.requestAttr, request_id);\n\n    _src2.crud.createDocument({\n      \"collection\": collection,\n      \"element\": request_id,\n      \"metadata\": \"\"\n    });\n  },\n  __requestDocumentIdOfForm: function (form) {\n    let self = this;\n    let elemens = form.querySelectorAll('[name], [data-pass_to]');\n    let collections = [];\n\n    for (var i = 0; i < elemens.length; i++) {\n      let el = elemens[i];\n\n      if (el.parentNode.classList.contains('template')) {\n        continue;\n      }\n\n      const collection = el.getAttribute(\"data-collection\") || el.getAttribute(\"data-pass_collection\") || \"\";\n\n      if (collection !== \"\" && !collections.includes(collection) && !self.checkID(el, 'data-document_id') && !self.checkID(el, 'data-pass_document_id')) {\n        const request_id = _utils.default.generateUUID();\n\n        collections.push(collection);\n        el.setAttribute(this.requestAttr, request_id); //. get Data\n\n        let data = _utils2.default.getFormData(form, \"\", collection);\n        /* FixME Create Document request */\n\n\n        _src2.crud.createDocument({\n          \"collection\": collection,\n          \"element\": request_id,\n          'data': data,\n          \"metadata\": \"\"\n        });\n      }\n    }\n  },\n  __setNewIdProcess: function (element, document_id, pass) {\n    if (!element) return;\n    element.removeAttribute(this.requestAttr);\n    const event_data = {\n      document_id: document_id\n    };\n\n    if (!pass && !this.checkID(element) && element.hasAttribute('name')) {\n      element.setAttribute('data-document_id', document_id);\n    }\n\n    if (pass && !this.checkID(element, 'data-pass_document_id') && element.hasAttribute('data-pass_to')) {\n      element.setAttribute('data-pass_document_id', document_id); // CoCreateLogic.storePassData(element)\n\n      if (element.parentNode.classList.contains('submitBtn')) {\n        element.click();\n      }\n    }\n\n    var event = new CustomEvent('set-document_id', {\n      detail: event_data\n    });\n    element.dispatchEvent(event);\n  },\n  __receivedDocumentId: function (data) {\n    if (!data['document_id']) {\n      return;\n    }\n\n    let element = document.querySelector(`[${this.requestAttr}=\"${data['element']}\"]`);\n    if (!element) return;\n    let self = this;\n    const form = element.tagName === \"FORM\" ? element : _utils2.default.getParents(element, 'form');\n    const collection = data['collection'];\n    const id = data['document_id'];\n\n    if (form && id) {\n      form.setAttribute('data-form_id', data['element']);\n      const elements = form.querySelectorAll(`[data-collection=${collection}], [data-pass_collection=${collection}]`);\n      elements.forEach(function (el) {\n        el.removeAttribute(self.requestAttr);\n        if (el.hasAttribute('name')) self.__setNewIdProcess(el, id);\n        if (el.hasAttribute('data-pass_to')) self.__setNewIdProcess(el, id, true);\n      });\n    } else if (element) {\n      this.__setNewIdProcess(element, id);\n    }\n  }\n};\n\nCoCreateForm.__init();\n\n_src2.core.registerInit(CoCreateForm.initElement, CoCreateForm);\n\n_src.default.init({\n  name: 'CoCreateForm',\n  observe: ['subtree', 'childList'],\n  include: 'form',\n  callback: function (mutation) {\n    CoCreateForm.initElement(mutation.target);\n  }\n});\n\n_src3.default.init({\n  action: \"createDocument\",\n  endEvent: \"createdDocument\",\n  callback: (btn, data) => {\n    CoCreateForm.__createDocumentAction(btn);\n  }\n});\n\n_src3.default.init({\n  action: \"deleteDocument\",\n  endEvent: \"deletedDocument\",\n  callback: (btn, data) => {\n    CoCreateForm.__deleteDocumentAction(btn);\n  }\n});\n\n_src3.default.init({\n  action: \"deleteDocuments\",\n  endEvent: \"deletedDocuments\",\n  callback: (btn, data) => {\n    CoCreateDocument.__deleteDocumentsAction(btn);\n  }\n});\n\n_src3.default.init({\n  action: \"saveDocument\",\n  endEvent: \"savedDocument\",\n  callback: (btn, data) => {\n    CoCreateForm.__saveDocumentAction(btn);\n  }\n});\n\nvar _default = CoCreateForm;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWZvcm0vc3JjL2luZGV4LmpzP2I3YzkiXSwibmFtZXMiOlsiQ29DcmVhdGVGb3JtIiwicmVxdWVzdEF0dHIiLCJzZWxlY3RvcnMiLCJtb2R1bGVzIiwiaW5pdCIsIm5hbWUiLCJzZWxlY3RvciIsImNhbGxiYWNrIiwicHVzaCIsImdldCIsImNoZWNrSUQiLCJlbGVtZW50IiwiYXR0ciIsImRvY3VtZW50X2lkIiwiZ2V0QXR0cmlidXRlIiwiY2N1dGlscyIsImNoZWNrVmFsdWUiLCJyZXF1ZXN0IiwiZm9ybSIsIm5hbWVBdHRyIiwidmFsdWUiLCJjbG9zZXN0IiwiX19yZXF1ZXN0RG9jdW1lbnRJZE9mRm9ybSIsIl9fcmVxdWVzdERvY3VtZW50SWQiLCJpbml0RWxlbWVudCIsImNvbnRhaW5lciIsIl9fY29udGFpbmVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9ybXMiLCJsZW5ndGgiLCJ0YWdOYW1lIiwiZm9yRWFjaCIsInV0aWxzIiwic2V0QXR0cmlidXRlIiwiZGlzYWJsZUF1dG9GaWxsIiwiX19pbml0IiwiX19pbml0RXZlbnQiLCJzZWxmIiwic29ja2V0IiwibGlzdGVuIiwiZGF0YSIsIm1ldGFkYXRhIiwiX19yZWNlaXZlZERvY3VtZW50SWQiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJkZXRhaWwiLCJtYXRjaGVzIiwiY2FsbCIsIl9fZGVsZXRlRG9jdW1lbnRBY3Rpb24iLCJidG4iLCJjb2xsZWN0aW9uIiwiY3J1ZCIsImRlbGV0ZURvY3VtZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiX19kZWxldGVEb2N1bWVudHNBY3Rpb24iLCJzZWxlY3RlZEVscyIsImVsIiwiX19jcmVhdGVEb2N1bWVudEFjdGlvbiIsImNvbGxlY3Rpb25zIiwiZ2V0Q09sbGVjdGlvbnMiLCJnZXRGb3JtRGF0YSIsIk9iamVjdCIsImtleXMiLCJjb25zdHJ1Y3RvciIsImNyZWF0ZURvY3VtZW50IiwiX19zYXZlRG9jdW1lbnRBY3Rpb24iLCJjaGVja0Zvcm1WYWxpZGF0ZSIsImFsZXJ0IiwiZWxlbWVudHMiLCJqb2luIiwicmVxdWVzdF9kb2N1bWVudF9pZCIsImkiLCJkYXRhX2RvY3VtZW50X2lkIiwiaW5wdXQiLCJpc1VzYWdlWSIsImlzVGVtcGxhdGVJbnB1dCIsIm5ld19ldmVudCIsImJ1YmJsZXMiLCJ0eXBlIiwicmVxdWVzdERvY3VtZW50SWRPZkZvcm0iLCJyZXF1ZXN0X2lkIiwiZ2VuZXJhdGVVVUlEIiwiZWxlbWVucyIsInBhcmVudE5vZGUiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImluY2x1ZGVzIiwiX19zZXROZXdJZFByb2Nlc3MiLCJwYXNzIiwicmVtb3ZlQXR0cmlidXRlIiwiZXZlbnRfZGF0YSIsImhhc0F0dHJpYnV0ZSIsImNsaWNrIiwicXVlcnlTZWxlY3RvciIsImdldFBhcmVudHMiLCJpZCIsImNvcmUiLCJyZWdpc3RlckluaXQiLCJvYnNlcnZlciIsIm9ic2VydmUiLCJpbmNsdWRlIiwibXV0YXRpb24iLCJ0YXJnZXQiLCJhY3Rpb24iLCJlbmRFdmVudCIsIkNvQ3JlYXRlRG9jdW1lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUlBO0FBQ0E7QUFJQSxNQUFNQSxZQUFZLEdBQUc7QUFFcEJDLGFBQVcsRUFBRSx1QkFGTztBQUdwQkMsV0FBUyxFQUFFLEVBSFM7QUFJcEJDLFNBQU8sRUFBRSxFQUpXO0FBTXBCQyxNQUFJLEVBQUUsVUFBUztBQUFDQyxRQUFEO0FBQU9DLFlBQVA7QUFBaUJDO0FBQWpCLEdBQVQsRUFBcUM7QUFFMUMsU0FBS0osT0FBTCxDQUFhSyxJQUFiLENBQWtCO0FBQ2pCSCxVQURpQjtBQUVqQkMsY0FGaUI7QUFHakJDO0FBSGlCLEtBQWxCOztBQU1BLFFBQUlELFFBQUosRUFBYztBQUNiLFdBQUtKLFNBQUwsQ0FBZU0sSUFBZixDQUFvQkYs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LFVBQVEsRUFBRSxDQUFDMkMsR0FBRCxFQUFNVCxJQUFOLEtBQWU7QUFDeEJ6QyxnQkFBWSxDQUFDaUQsc0JBQWIsQ0FBb0NDLEdBQXBDO0FBQ0E7QUFMVSxDQUFaOztBQVFBdUQsY0FBT3JHLElBQVAsQ0FBWTtBQUNYcUcsUUFBTSxFQUFFLGlCQURHO0FBRVhDLFVBQVEsRUFBRSxrQkFGQztBQUdYbkcsVUFBUSxFQUFFLENBQUMyQyxHQUFELEVBQU1ULElBQU4sS0FBZTtBQUN4QmtFLG9CQUFnQixDQUFDbkQsdUJBQWpCLENBQXlDTixHQUF6QztBQUNBO0FBTFUsQ0FBWjs7QUFRQXVELGNBQU9yRyxJQUFQLENBQVk7QUFDWHFHLFFBQU0sRUFBRSxjQURHO0FBRVhDLFVBQVEsRUFBRSxlQUZDO0FBR1huRyxVQUFRLEVBQUUsQ0FBQzJDLEdBQUQsRUFBTVQsSUFBTixLQUFlO0FBQ3hCekMsZ0JBQVksQ0FBQ21FLG9CQUFiLENBQWtDakIsR0FBbEM7QUFDQTtBQUxVLENBQVo7O2VBUWVsRCxZIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWZvcm0vc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG9ic2VydmVyIGZyb20gJy4uLy4uL0NvQ3JlYXRlLW9ic2VydmVyL3NyYydcbmltcG9ydCBjY3V0aWxzIGZyb20gJy4uLy4uLy4uL0NvQ3JlYXRlSlMvc3JjL3V0aWxzJztcbmltcG9ydCB7c29ja2V0LCBjcnVkLCBjb3JlfSBmcm9tICcuLi8uLi8uLi9Db0NyZWF0ZUpTL3NyYydcbmltcG9ydCBhY3Rpb24gZnJvbSAnLi4vLi4vQ29DcmVhdGUtYWN0aW9uL3NyYydcbmltcG9ydCB1dGlscyBmcm9tIFwiLi91dGlsc1wiIFxuXG5cblxuLy8gaW1wb3J0IGNyZHQgZnJvbSAnLi4vLi4vQ29DcmVhdGUtY3JkdC9zcmMnXG4vLyBpbXBvcnQgdGV4dCBmcm9tICcuLi8uLi9Db0NyZWF0ZS10ZXh0L3NyYydcblxuXG5cbmNvbnN0IENvQ3JlYXRlRm9ybSA9IHtcblx0XG5cdHJlcXVlc3RBdHRyOiBcImRhdGEtZG9jdW1lbnRfcmVxdWVzdFwiLFxuXHRzZWxlY3RvcnM6IFtdLFxuXHRtb2R1bGVzOiBbXSxcblxuXHRpbml0OiBmdW5jdGlvbih7bmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrfSkge1xuXHRcdFxuXHRcdHRoaXMubW9kdWxlcy5wdXNoKHtcblx0XHRcdG5hbWUsXG5cdFx0XHRzZWxlY3Rvcixcblx0XHRcdGNhbGxiYWNrXG5cdFx0fSk7XG5cdFx0XG5cdFx0aWYgKHNlbGVjdG9yKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcblx0XHR9XG5cdH0sXG5cdFxuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZWxlY3RvcnM6IHRoaXMuc2VsZWN0b3JzXG5cdFx0fVxuXHR9LFxuXHRcblx0Y2hlY2tJRDogZnVuY3Rpb24oZWxlbWVudCwgYXR0ciA9IFwiZGF0YS1kb2N1bWVudF9pZFwiKSB7XG5cdFx0bGV0IGRvY3VtZW50X2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cikgfHwgXCJcIjtcblx0XHRpZiAoZG9jdW1lbnRfaWQgPT09IFwiXCIgfHwgZG9jdW1lbnRfaWQgPT09IFwicGVuZGluZ1wiIHx8ICFjY3V0aWxzLmNoZWNrVmFsdWUoZG9jdW1lbnRfaWQpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRcblx0cmVxdWVzdDogZnVuY3Rpb24oe2Zvcm0sIGVsZW1lbnQsIG5hbWVBdHRyLCB2YWx1ZX0pIHtcblx0XHRcblx0XHRpZiAoIWZvcm0gJiYgZWxlbWVudCkge1xuXHRcdFx0Zm9ybSA9IGVsZW1lbnQuY2xvc2VzdCgnZm9ybScpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoZm9ybSkge1xuXHRcdFx0dGhpcy5fX3JlcXVlc3REb2N1bWVudElkT2ZGb3JtKGZvcm0pXG5cdFx0fSBlbHNlIGlmIChlbGVtZW50KSB7XG5cdFx0XHRuYW1lQXR0ciA9IG5hbWVBdHRyIHx8IFwibmFtZVwiXG5cdFx0XHR0aGlzLl9fcmVxdWVzdERvY3VtZW50SWQoZWxlbWVudCwgbmFtZUF0dHIsIHZhbHVlKTtcblx0XHR9XG5cdFx0XG5cdH0sXG5cdFxuXHRpbml0RWxlbWVudDogZnVuY3Rpb24oY29udGFpbmVyKSB7XG5cdFx0Y29uc3QgX19jb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnRcblx0XHRcblx0XHRpZiAoIV9fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0ICBmb3JtcyA9IF9fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2Zvcm0nKTtcblxuXHRcdGlmIChmb3Jtcy5sZW5ndGggPT09IDAgJiYgX19jb250YWluZXIgIT0gZG9jdW1lbnQgJiYgX19jb250YWluZXIudGFnTmFtZSA9PT0gXCJGT1JNXCIpIHtcblx0XHRcdGZvcm1zID0gW19fY29udGFpbmVyXTtcblx0XHR9XG5cdFx0XG5cdFx0Zm9ybXMuZm9yRWFjaCgoZm9ybSkgPT4ge1xuXHRcdFx0dXRpbHMuc2V0QXR0cmlidXRlKGZvcm0pXG5cdFx0XHR1dGlscy5kaXNhYmxlQXV0b0ZpbGwoZm9ybSk7XG5cdFx0fSlcblx0fSxcblx0XG5cdF9faW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0Y29uc3QgZm9ybXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdmb3JtJyk7XG5cdFx0dGhpcy5fX2luaXRFdmVudCgpO1xuXG5cdFx0Zm9ybXMuZm9yRWFjaCgoZm9ybSkgPT4ge1xuXHRcdFx0dXRpbHMuc2V0QXR0cmlidXRlKGZvcm0pXG5cdFx0fSlcblx0XHRcblx0fSxcblx0XG5cdF9faW5pdEV2ZW50OiBmdW5jdGlvbigpIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRzb2NrZXQubGlzdGVuKCdjcmVhdGVEb2N1bWVudCcsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdGNvbnN0IHttZXRhZGF0YX0gPSBkYXRhO1xuXHRcdFx0c2VsZi5fX3JlY2VpdmVkRG9jdW1lbnRJZChkYXRhKTtcblx0XHRcdGlmIChtZXRhZGF0YSA9PSBcImNyZWF0ZURvY3VtZW50LWFjdGlvblwiKSB7XG5cdFx0XHRcdC8vLiBkaXNwYXRjaCBFbmRBY3Rpb25cblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHRcdHNvY2tldC5saXN0ZW4oJ2RlbGV0ZURvY3VtZW50JywgZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0Y29uc3Qge21ldGFkYXRhfSA9IGRhdGFcblx0XHRcdGlmIChtZXRhZGF0YSA9PT0gXCJkZWxldGVEb2N1bWVudC1hY3Rpb25cIikge1xuXHRcdFx0XHQvLy5kaXNwYXRjaCBFbmQgQWN0aW9uXG5cdFx0XHR9XG5cdFx0fSlcdFxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrZWQtc3VibWl0QnRuJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGNvbnN0IHtlbGVtZW50fSA9IGV2ZW50LmRldGFpbDtcblxuXHRcdFx0c2VsZi5tb2R1bGVzLmZvckVhY2goKHtzZWxlY3RvciwgY2FsbGJhY2t9KSA9PiB7XG5cdFx0XHRcdGlmIChjYWxsYmFjayAmJiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChudWxsLCBlbGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9KVxuXHR9LFxuXG5cdF9fZGVsZXRlRG9jdW1lbnRBY3Rpb246IGZ1bmN0aW9uKGJ0bikge1xuXHRcdGNvbnN0IGNvbGxlY3Rpb24gPSBidG4uZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKTtcblx0XHRjb25zdCBkb2N1bWVudF9pZCA9IGJ0bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKVxuXHRcdGlmIChjY3V0aWxzLmNoZWNrVmFsdWUoY29sbGVjdGlvbikgJiYgY2N1dGlscy5jaGVja1ZhbHVlKGRvY3VtZW50X2lkKSkge1xuXHRcdFx0Y3J1ZC5kZWxldGVEb2N1bWVudCh7XG5cdFx0XHRcdCdjb2xsZWN0aW9uJzogY29sbGVjdGlvbiwgXG5cdFx0XHRcdCdkb2N1bWVudF9pZCc6IGRvY3VtZW50X2lkLFxuXHRcdFx0XHQnbWV0YWRhdGEnOiAnZGVsZXRlRG9jdW1lbnQtYWN0aW9uJyBcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZGVsZXRlZERvY3VtZW50Jywge1xuXHRcdFx0XHRkZXRhaWw6IHt9XG5cdFx0XHR9KSlcblx0XHR9XG5cdH0sXG5cdFxuXHRfX2RlbGV0ZURvY3VtZW50c0FjdGlvbjogZnVuY3Rpb24oYnRuKSB7XG5cdFx0Y29uc3QgY29sbGVjdGlvbiA9IGJ0bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpO1xuXHRcdGNvbnN0IHNlbGVjdG9yID0gYnRuLmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF90YXJnZXQnKTtcblx0XHRpZiAoIXNlbGVjdG9yKSByZXR1cm47XG5cdFx0XG5cdFx0Y29uc3Qgc2VsZWN0ZWRFbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxuXHRcdFxuXHRcdGlmICh1dGlscy5jaGVja1ZhbHVlKGNvbGxlY3Rpb24pKSB7XG5cdFx0XHRzZWxlY3RlZEVscy5mb3JFYWNoKChlbCkgPT4ge1xuXHRcdFx0XHRjb25zdCBkb2N1bWVudF9pZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpO1xuXHRcdFx0XHRpZiAoY2N1dGlscy5jaGVja1ZhbHVlKGRvY3VtZW50X2lkKSkge1xuXHRcdFx0XHRcdGNydWQuZGVsZXRlRG9jdW1lbnQoe1xuXHRcdFx0XHRcdFx0J2NvbGxlY3Rpb24nOiBjb2xsZWN0aW9uLFxuXHRcdFx0XHRcdFx0J2RvY3VtZW50X2lkJzogZG9jdW1lbnRfaWQsXG5cdFx0XHRcdFx0XHQnbWV0YWRhdGEnOiAnJ1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHRcblx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkZWxldGVkRG9jdW1lbnRzJywge1xuXHRcdFx0XHRkZXRhaWw6IHt9XG5cdFx0XHR9KSlcblx0XHR9XG5cdH0sXG5cdFxuXHRfX2NyZWF0ZURvY3VtZW50QWN0aW9uOiBmdW5jdGlvbihidG4pIHtcblx0XHRjb25zdCBmb3JtID0gYnRuLmNsb3Nlc3QoXCJmb3JtXCIpXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0bGV0IGNvbGxlY3Rpb25zID0gdXRpbHMuZ2V0Q09sbGVjdGlvbnMoZm9ybSlcblx0XHRcblx0XHRjb2xsZWN0aW9ucy5mb3JFYWNoKChjb2xsZWN0aW9uKSA9PiB7XG5cdFx0XHRsZXQgZGF0YSA9IHV0aWxzLmdldEZvcm1EYXRhKGZvcm0sIFwiXCIsIGNvbGxlY3Rpb24pO1xuXHRcdFx0XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoID09IDAgJiYgZGF0YS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChjY3V0aWxzLmNoZWNrVmFsdWUoY29sbGVjdGlvbikpIHtcblx0XHRcdFx0Y3J1ZC5jcmVhdGVEb2N1bWVudCh7XG5cdFx0XHRcdFx0J2NvbGxlY3Rpb24nOiBjb2xsZWN0aW9uLFxuXHRcdFx0XHRcdCdkYXRhJzogZGF0YSxcblx0XHRcdFx0XHQnbWV0YWRhdGEnOiAnY3JlYXRlRG9jdW1lbnQtYWN0aW9uJyAsXG5cdFx0XHRcdFx0J2VsZW1lbnQnOidlbXB0eSdcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjcmVhdGVkRG9jdW1lbnQnLCB7XG5cdFx0XHRcdFx0ZGV0YWlsOiB7fVxuXHRcdFx0XHR9KSlcblx0XHRcdH1cblx0XHR9KVxuXHR9LFxuXHRcblx0X19zYXZlRG9jdW1lbnRBY3Rpb246IGZ1bmN0aW9uKGJ0bikge1xuXHRcdGNvbnN0IGZvcm0gPSBidG4uY2xvc2VzdChcImZvcm1cIilcblxuXHRcdGlmICghdXRpbHMuY2hlY2tGb3JtVmFsaWRhdGUoZm9ybSkpIHtcblx0XHRcdGFsZXJ0KCdWYWx1ZXMgYXJlIG5vdCB1bmlxdWUnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0Y29uc3Qgc2VsZWN0b3JzID0gdGhpcy5zZWxlY3RvcnMgfHwgW107XG5cdFx0Y29uc3QgZWxlbWVudHMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzLmpvaW4oJywnKSk7XG5cdFx0XG5cdFx0bGV0IHJlcXVlc3RfZG9jdW1lbnRfaWQgPSBmYWxzZTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGNvbnN0IGRhdGFfZG9jdW1lbnRfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKTtcblxuXHRcdFx0aWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zYXZlX3ZhbHVlJykgPT0gJ2ZhbHNlJykge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkYXRhX2RvY3VtZW50X2lkKSB7XG5cdFx0XHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSkge1xuXHRcdFx0XHRcdHJlcXVlc3RfZG9jdW1lbnRfaWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoaW5wdXQuaXNVc2FnZVkoZWwpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodXRpbHMuaXNUZW1wbGF0ZUlucHV0KGVsKSkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgbmV3X2V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwiY2xpY2tlZC1zdWJtaXRCdG5cIiwge1xuXHRcdFx0XHRidWJibGVzOiB0cnVlLFxuXHRcdFx0XHRkZXRhaWw6IHsgXG5cdFx0XHRcdFx0dHlwZTogXCJzdWJtaXRCdG5cIiwgXG5cdFx0XHRcdFx0ZWxlbWVudDogZWwgXG5cdFx0XHRcdH19KTtcblx0XHRcdGVsLmRpc3BhdGNoRXZlbnQobmV3X2V2ZW50KTsgIFxuXHRcdH1cblx0XHRpZiAocmVxdWVzdF9kb2N1bWVudF9pZCkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0RG9jdW1lbnRJZE9mRm9ybShmb3JtKVxuXHRcdH1cblx0XHRcblx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc2F2ZWREb2N1bWVudCcsIHtcblx0XHRcdGRldGFpbDoge31cblx0XHR9KSlcblx0fSxcblx0XG5cdF9fcmVxdWVzdERvY3VtZW50SWQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWVBdHRyID0gXCJuYW1lXCIsIHZhbHVlID0gbnVsbCkge1xuXHRcdGNvbnN0IGNvbGxlY3Rpb24gPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJylcblx0XHRjb25zdCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZUF0dHIpXG5cdFx0XG5cdFx0aWYgKCFjb2xsZWN0aW9uIHx8ICFuYW1lKSByZXR1cm4gXG5cblx0XHRjb25zdCByZXF1ZXN0X2lkID0gY2N1dGlscy5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMucmVxdWVzdEF0dHIsIHJlcXVlc3RfaWQpO1xuXHRcdFxuXHRcdGNydWQuY3JlYXRlRG9jdW1lbnQoe1xuXHRcdFx0XCJjb2xsZWN0aW9uXCI6IGNvbGxlY3Rpb24sXG5cdFx0XHRcImVsZW1lbnRcIjogcmVxdWVzdF9pZCxcblx0XHRcdFwibWV0YWRhdGFcIjogXCJcIixcblx0XHR9KVxuXHR9LFxuXHRcdFxuXHRfX3JlcXVlc3REb2N1bWVudElkT2ZGb3JtOiBmdW5jdGlvbiAoZm9ybSkge1xuXHRcdFxuXHRcdGxldCBzZWxmID0gdGhpcztcblx0XHRsZXQgZWxlbWVucyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbCgnW25hbWVdLCBbZGF0YS1wYXNzX3RvXScpXG5cdFx0XG5cdFx0bGV0IGNvbGxlY3Rpb25zID0gW107XG5cblx0XHRmb3IgKHZhciAgaSA9IDA7IGkgPCBlbGVtZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgZWwgPSBlbGVtZW5zW2ldO1xuXHRcdFx0aWYgKGVsLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZW1wbGF0ZScpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgY29sbGVjdGlvbiA9IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtY29sbGVjdGlvblwiKSB8fCBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhc3NfY29sbGVjdGlvblwiKSB8fCBcIlwiO1x0XG5cdFx0XHRcblx0XHRcdGlmIChcblx0XHRcdFx0Y29sbGVjdGlvbiAhPT0gXCJcIiAmJiBcblx0XHRcdFx0IWNvbGxlY3Rpb25zLmluY2x1ZGVzKGNvbGxlY3Rpb24pICYmIFxuXHRcdFx0XHQoIXNlbGYuY2hlY2tJRChlbCwgJ2RhdGEtZG9jdW1lbnRfaWQnKSAmJiAhc2VsZi5jaGVja0lEKGVsLCAnZGF0YS1wYXNzX2RvY3VtZW50X2lkJykpXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3QgcmVxdWVzdF9pZCA9IGNjdXRpbHMuZ2VuZXJhdGVVVUlEKCk7XG5cdFx0XHRcdGNvbGxlY3Rpb25zLnB1c2goY29sbGVjdGlvbik7XG5cblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKHRoaXMucmVxdWVzdEF0dHIsIHJlcXVlc3RfaWQpO1xuXHRcdFx0XHQvLy4gZ2V0IERhdGFcblx0XHRcdFx0XG5cdFx0XHRcdGxldCBkYXRhID0gdXRpbHMuZ2V0Rm9ybURhdGEoZm9ybSwgXCJcIiwgY29sbGVjdGlvbik7XG5cdFx0XHRcdFxuXHRcdFx0XHQvKiBGaXhNRSBDcmVhdGUgRG9jdW1lbnQgcmVxdWVzdCAqL1x0XG5cdFx0XHRcdGNydWQuY3JlYXRlRG9jdW1lbnQoe1xuXHRcdFx0XHRcdFwiY29sbGVjdGlvblwiOiBjb2xsZWN0aW9uLFxuXHRcdFx0XHRcdFwiZWxlbWVudFwiOiByZXF1ZXN0X2lkLFxuXHRcdFx0XHRcdCdkYXRhJzogZGF0YSxcblx0XHRcdFx0XHRcIm1ldGFkYXRhXCI6IFwiXCIsXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9fc2V0TmV3SWRQcm9jZXNzOiBmdW5jdGlvbihlbGVtZW50LCBkb2N1bWVudF9pZCwgcGFzcykge1xuXHRcdGlmICghZWxlbWVudCkgcmV0dXJuO1xuXHRcdFxuICBcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5yZXF1ZXN0QXR0cik7XG5cdFx0Y29uc3QgZXZlbnRfZGF0YSA9IHtcblx0XHRcdGRvY3VtZW50X2lkOiBkb2N1bWVudF9pZCxcblx0XHR9XG5cblx0XHRpZiAoIXBhc3MgJiYgIXRoaXMuY2hlY2tJRChlbGVtZW50KSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbmFtZScpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcsIGRvY3VtZW50X2lkKTtcblx0ICBcdH1cblxuXHQgIFx0aWYgKHBhc3MgJiYgIXRoaXMuY2hlY2tJRChlbGVtZW50LCAnZGF0YS1wYXNzX2RvY3VtZW50X2lkJykgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcGFzc190bycpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1wYXNzX2RvY3VtZW50X2lkJywgZG9jdW1lbnRfaWQpO1xuXHRcdFx0Ly8gQ29DcmVhdGVMb2dpYy5zdG9yZVBhc3NEYXRhKGVsZW1lbnQpXG5cdFx0XHRcblx0XHRcdGlmIChlbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdzdWJtaXRCdG4nKSkge1xuXHRcdFx0XHRlbGVtZW50LmNsaWNrKCk7XG5cdFx0XHR9XG5cdCAgXHR9XG4gIFx0XG5cdFx0dmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzZXQtZG9jdW1lbnRfaWQnLCB7ZGV0YWlsOiBldmVudF9kYXRhfSlcblx0XHRlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG5cdH0sXG5cdFxuXHRfX3JlY2VpdmVkRG9jdW1lbnRJZDogZnVuY3Rpb24oZGF0YSkge1xuXHRcdGlmICghZGF0YVsnZG9jdW1lbnRfaWQnXSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxldCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgWyR7dGhpcy5yZXF1ZXN0QXR0cn09XCIke2RhdGFbJ2VsZW1lbnQnXX1cIl1gKTtcblx0XHRpZiAoIWVsZW1lbnQpIHJldHVybjtcblx0XHRsZXQgc2VsZiA9IHRoaXM7XG5cdFx0Y29uc3QgZm9ybSA9IChlbGVtZW50LnRhZ05hbWUgPT09IFwiRk9STVwiKSA/IGVsZW1lbnQgOiB1dGlscy5nZXRQYXJlbnRzKGVsZW1lbnQsICdmb3JtJyk7XG5cdFx0Y29uc3QgY29sbGVjdGlvbiA9IGRhdGFbJ2NvbGxlY3Rpb24nXTtcblx0XHRjb25zdCBpZCA9IGRhdGFbJ2RvY3VtZW50X2lkJ11cblx0XHRpZiAoZm9ybSAmJiBpZCkge1xuXHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZm9ybV9pZCcsIGRhdGFbJ2VsZW1lbnQnXSk7XG5cdFx0XHRjb25zdCBlbGVtZW50cyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtY29sbGVjdGlvbj0ke2NvbGxlY3Rpb259XSwgW2RhdGEtcGFzc19jb2xsZWN0aW9uPSR7Y29sbGVjdGlvbn1dYClcblx0XHRcdGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0ZWwucmVtb3ZlQXR0cmlidXRlKHNlbGYucmVxdWVzdEF0dHIpO1xuXHRcdFx0XHRpZiAoZWwuaGFzQXR0cmlidXRlKCduYW1lJykpIHNlbGYuX19zZXROZXdJZFByb2Nlc3MoZWwsIGlkKTtcblx0XHRcdFx0aWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1wYXNzX3RvJykpIHNlbGYuX19zZXROZXdJZFByb2Nlc3MoZWwsIGlkLCB0cnVlKTtcblx0XHRcdH0pXG5cdCAgXHRcblx0XHR9IGVsc2UgaWYgKGVsZW1lbnQpIHtcblx0XHRcdHRoaXMuX19zZXROZXdJZFByb2Nlc3MoZWxlbWVudCwgaWQpO1xuXHRcdH1cblx0fSxcbn1cblxuQ29DcmVhdGVGb3JtLl9faW5pdCgpO1xuY29yZS5yZWdpc3RlckluaXQoQ29DcmVhdGVGb3JtLmluaXRFbGVtZW50LCBDb0NyZWF0ZUZvcm0pO1xuXG5vYnNlcnZlci5pbml0KHsgXG5cdG5hbWU6ICdDb0NyZWF0ZUZvcm0nLCBcblx0b2JzZXJ2ZTogWydzdWJ0cmVlJywgJ2NoaWxkTGlzdCddLFxuXHRpbmNsdWRlOiAnZm9ybScsIFxuXHRjYWxsYmFjazogZnVuY3Rpb24obXV0YXRpb24pIHtcblx0XHRDb0NyZWF0ZUZvcm0uaW5pdEVsZW1lbnQobXV0YXRpb24udGFyZ2V0KVxuXHR9XG59KVxuXG5hY3Rpb24uaW5pdCh7XG5cdGFjdGlvbjogXCJjcmVhdGVEb2N1bWVudFwiLFxuXHRlbmRFdmVudDogXCJjcmVhdGVkRG9jdW1lbnRcIixcblx0Y2FsbGJhY2s6IChidG4sIGRhdGEpID0+IHtcblx0XHRDb0NyZWF0ZUZvcm0uX19jcmVhdGVEb2N1bWVudEFjdGlvbihidG4pXG5cdH0sXG59KVxuXG5hY3Rpb24uaW5pdCh7XG5cdGFjdGlvbjogXCJkZWxldGVEb2N1bWVudFwiLFxuXHRlbmRFdmVudDogXCJkZWxldGVkRG9jdW1lbnRcIixcblx0Y2FsbGJhY2s6IChidG4sIGRhdGEpID0+IHtcblx0XHRDb0NyZWF0ZUZvcm0uX19kZWxldGVEb2N1bWVudEFjdGlvbihidG4pXG5cdH0sXG59KVxuXG5hY3Rpb24uaW5pdCh7XG5cdGFjdGlvbjogXCJkZWxldGVEb2N1bWVudHNcIixcblx0ZW5kRXZlbnQ6IFwiZGVsZXRlZERvY3VtZW50c1wiLFxuXHRjYWxsYmFjazogKGJ0biwgZGF0YSkgPT4ge1xuXHRcdENvQ3JlYXRlRG9jdW1lbnQuX19kZWxldGVEb2N1bWVudHNBY3Rpb24oYnRuKVxuXHR9LFxufSlcblxuYWN0aW9uLmluaXQoe1xuXHRhY3Rpb246IFwic2F2ZURvY3VtZW50XCIsXG5cdGVuZEV2ZW50OiBcInNhdmVkRG9jdW1lbnRcIixcblx0Y2FsbGJhY2s6IChidG4sIGRhdGEpID0+IHtcblx0XHRDb0NyZWF0ZUZvcm0uX19zYXZlRG9jdW1lbnRBY3Rpb24oYnRuKVxuXHR9LFxufSlcblxuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVGb3JtOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-form/src/index.js\n")},"../CoCreate-form/src/utils.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\nconst Utils = {\n  disableAutoFill: function (element) {\n    if (element.tagName == \"TEXTAREA\") {\n      element.value = \"\";\n      element.setAttribute(\"autocomplete\", \"off\");\n    }\n\n    if (!element.hasAttribute(\"autocomplete\")) {\n      element.setAttribute('autocomplete', \"off\");\n    }\n  },\n  setAttribute: function (form) {\n    const collection = form.getAttribute('data-collection') || \"\";\n    const dataRealTime = form.getAttribute('data-realtime');\n    const document_id = form.getAttribute('data-document_id') || \"\";\n    let elements = form.querySelectorAll('[name], [data-pass_to]');\n    elements.forEach(function (el) {\n      if (el.parentNode.classList.contains('template')) {\n        return;\n      }\n\n      if (el.getAttribute('data-realtime') == null && dataRealTime) {\n        // if (!['INPUT', 'TEXTAREA'].indexOf(el.tagName)) {\n        el.setAttribute('data-realtime', dataRealTime); // }\n      }\n\n      if (el.getAttribute('name') && !el.hasAttribute('data-collection') && collection) {\n        el.setAttribute('data-collection', collection);\n      }\n\n      if (el.getAttribute('data-pass_to') && !el.hasAttribute('data-pass_collection') && collection) {\n        el.setAttribute('data-pass_collection', collection);\n      }\n\n      if (el.getAttribute('name') && !el.getAttribute('data-document_id') && document_id) {\n        el.setAttribute('data-document_id', document_id);\n      }\n\n      if (!el.hasAttribute(\"data-document_id\") && document_id != null) {\n        el.setAttribute('data-document_id', document_id);\n      }\n    });\n  },\n  checkFormValidate: function (form) {\n    if (typeof CoCreate.unique !== 'undefined') {\n      return CoCreate.unique.checkValidate(form);\n    }\n\n    return true;\n  },\n  isTemplateInput: function (input) {\n    if (input.classList.contains('template')) return true;\n    let node = input.parentNode;\n\n    while (node) {\n      if (node.classList && node.classList.contains('template')) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  },\n  getFormData: function (form, document_id, collection) {\n    let data = {};\n    if (!collection) return {};\n    const elements = form.querySelectorAll(`[name][data-collection='${collection}']`);\n    elements.forEach(el => {\n      let el_document_id = el.getAttribute('data-document_id') || \"\";\n      let name = el.getAttribute('name');\n      let value = el.value || el.getAttribute('value');\n      if (name === \"_id\") return;\n      if (!name || !value) return;\n\n      if (document_id == el_document_id) {\n        data[name] = el.value;\n      }\n    });\n    return data;\n  },\n  // getFormData: function(form, selectors) {\n  // \tconst self = this; \n  // \tconst elements = form.querySelectorAll(selectors.join(','));\n  // \tlet request_document_id = false;\n  // \tlet dataList = [];\n  // \telements.forEach(el => {\n  // \t\tlet collection = el.getAttribute('data-collection')\n  // \t\tlet document_id = el.getAttribute('data-document_id')\n  // \t\tlet name = el.getAttribute('name')\n  // \t\tif (el.getAttribute('data-save_value') == 'false') {\n  // \t\t\treturn;\n  // \t\t}\n  // \t\tif (!document_id && name) {\n  // \t\t\trequest_document_id = true;\n  // \t\t\treturn;\n  // \t\t}\n  // \t\tlet data = dataList.find(d => d.collection == collection && d.document_id == document_id);\n  // \t})\n  // },\n  getParents: function (element, selector = \"form\") {\n    if (!Element.prototype.matches) {\n      Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {\n        var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n            i = matches.length;\n\n        while (--i >= 0 && matches.item(i) !== this) {}\n\n        return i > -1;\n      };\n    }\n\n    for (; element && element !== document; element = element.parentNode) {\n      if (element.matches(selector)) return element;\n    }\n\n    return null;\n  },\n  setDocumentIDOfElement: function (element, document_id) {\n    let old_document_id = element.getAttribute('data-document_id');\n\n    if (!old_document_id || old_document_id == \"\" || old_document_id == \"pending\") {\n      element.setAttribute('data-document_id', document_id);\n    }\n  },\n  getCOllections: function (form) {\n    let collections = [];\n    if (!form) return collections;\n    let els = form.querySelectorAll('[name][data-collection]');\n    els.forEach(el => {\n      let tmpCollection = el.getAttribute('data-collection');\n\n      if (tmpCollection && !collections.includes(tmpCollection)) {\n        collections.push(tmpCollection);\n      }\n    });\n    return collections;\n  }\n};\nvar _default = Utils;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWZvcm0vc3JjL3V0aWxzLmpzPzJmZmUiXSwibmFtZXMiOlsiVXRpbHMiLCJkaXNhYmxlQXV0b0ZpbGwiLCJlbGVtZW50IiwidGFnTmFtZSIsInZhbHVlIiwic2V0QXR0cmlidXRlIiwiaGFzQXR0cmlidXRlIiwiZm9ybSIsImNvbGxlY3Rpb24iLCJnZXRBdHRyaWJ1dGUiLCJkYXRhUmVhbFRpbWUiLCJkb2N1bWVudF9pZCIsImVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInBhcmVudE5vZGUiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImNoZWNrRm9ybVZhbGlkYXRlIiwiQ29DcmVhdGUiLCJ1bmlxdWUiLCJjaGVja1ZhbGlkYXRlIiwiaXNUZW1wbGF0ZUlucHV0IiwiaW5wdXQiLCJub2RlIiwiZ2V0Rm9ybURhdGEiLCJkYXRhIiwiZWxfZG9jdW1lbnRfaWQiLCJuYW1lIiwiZ2V0UGFyZW50cyIsInNlbGVjdG9yIiwiRWxlbWVudCIsInByb3RvdHlwZSIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJzIiwiZG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiaSIsImxlbmd0aCIsIml0ZW0iLCJzZXREb2N1bWVudElET2ZFbGVtZW50Iiwib2xkX2RvY3VtZW50X2lkIiwiZ2V0Q09sbGVjdGlvbnMiLCJjb2xsZWN0aW9ucyIsImVscyIsInRtcENvbGxlY3Rpb24iLCJpbmNsdWRlcyIsInB1c2giXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE1BQU1BLEtBQUssR0FBRztBQUViQyxpQkFBZSxFQUFFLFVBQVNDLE9BQVQsRUFBa0I7QUFDbEMsUUFBSUEsT0FBTyxDQUFDQyxPQUFSLElBQW1CLFVBQXZCLEVBQW1DO0FBQ2xDRCxhQUFPLENBQUNFLEtBQVIsR0FBZ0IsRUFBaEI7QUFDQUYsYUFBTyxDQUFDRyxZQUFSLENBQXFCLGNBQXJCLEVBQW9DLEtBQXBDO0FBQ0E7O0FBQ0QsUUFBSSxDQUFDSCxPQUFPLENBQUNJLFlBQVIsQ0FBcUIsY0FBckIsQ0FBTCxFQUEyQztBQUMxQ0osYUFBTyxDQUFDRyxZQUFSLENBQXFCLGNBQXJCLEVBQXFDLEtBQXJDO0FBQ0E7QUFDRCxHQVZZO0FBWWJBLGNBQVksRUFBRSxVQUFTRSxJQUFULEVBQWU7QUFFNUIsVUFBTUMsVUFBVSxHQUFHRCxJQUFJLENBQUNFLFlBQUwsQ0FBa0IsaUJBQWxCLEtBQXdDLEVBQTNEO0FBQ0EsVUFBTUMsWUFBWSxHQUFHSCxJQUFJLENBQUNFLFlBQUwsQ0FBa0IsZUFBbEIsQ0FBckI7QUFDQSxVQUFNRSxXQUFXLEdBQUdKLElBQUksQ0FBQ0UsWUFBTCxDQUFrQixrQkFBbEIsS0FBeUMsRUFBN0Q7QUFDQSxRQUFJRyxRQUFRLEdBQUdMLElBQUksQ0FBQ00sZ0JBQUwsQ0FBc0Isd0JBQXRCLENBQWY7QUFHQUQsWUFBUSxDQUFDRSxPQUFULENBQWlCLFVBQVNDLEVBQVQsRUFBYTtBQUM3QixVQUFJQSxFQUFFLENBQUNDLFVBQUgsQ0FBY0MsU0FBZCxDQUF3QkMsUUFBeEIsQ0FBaUMsVUFBakMsQ0FBSixFQUFrRDtBQUNqRDtBQUNBOztBQUNELFVBQUlILEVBQUUsQ0FBQ04sWUFBSCxDQUFnQixlQUFoQixLQUFvQyxJQUFwQyxJQUE0Q0MsWUFBaEQsRUFBOEQ7QUFFN0Q7QUFDQUssVUFBRSxDQUFDVixZQUFILENBQWdCLGVBQWhCLEVBQWlDSyxZQUFqQyxFQUg2RCxDQUk3RDtBQUNBOztBQUNELFVBQUlLLEVBQUUsQ0FBQ04sWUFBSCxDQUFnQixNQUFoQixLQUEyQixDQUFDTSxFQUFFLENBQUNULFlBQUgsQ0FBZ0IsaUJBQWhCLENBQTVCLElBQWtFRSxVQUF0RSxFQUFrRjtBQUNqRk8sVUFBRSxDQUFDVixZQUFILENBQWdCLGlCQUFoQixFQUFtQ0csVUFBbkM7QUFDQTs7QUFFRCxVQUFJTyxFQUFFLENBQUNOLFlBQUgsQ0FBZ0IsY0FBaEIsS0FBbUMsQ0FBQ00sRUFBRSxDQUFDVCxZQUFILENBQWdCLHNCQUFoQixDQUFwQyxJQUFnRkUsVUFBcEYsRUFBZ0c7QUFDL0ZPLFVBQUUsQ0FBQ1YsWUFBSCxDQUFnQixzQkFBaEIsRUFBd0NHLFVBQXhDO0FBQ0E7O0FBRUQsVUFBSU8sRUFBRSxDQUFDTixZQUFILENBQWdCLE1BQWhCLEtBQTJCLENBQUNNLEVBQUUsQ0FBQ04sWUFBSCxDQUFnQixrQkFBaEIsQ0FBNUIsSUFBbUVFLFdBQXZFLEVBQW9GO0FBQ25GSSxVQUFFLENBQUNWLFlBQUgsQ0FBZ0Isa0JBQWhCLEVBQW9DTSxXQUFwQztBQUNBOztBQUNELFVBQUksQ0FBQ0ksRUFBRSxDQUFDVCxZQUFILENBQWdCLGtCQUFoQixDQUFELElBQXdDSyxXQUFXLElBQUksSUFBM0QsRUFBaUU7QUFDaEVJLFVBQUUsQ0FBQ1YsWUFBSCxDQUFnQixrQkFBaEIsRUFBb0NNLFdBQXBDO0FBQ0E7QUFFRCxLQXpCRDtBQTBCQSxHQTlDWTtBQWdEYlEsbUJBQWlCLEVBQUUsVUFBU1osSUFBVCxFQUFlO0FBRWpDLFFBQUksT0FBT2EsUUFBUSxDQUFDQyxNQUFoQixLQUEyQixXQUEvQixFQUE0QztBQUMzQyxhQUFPRCxRQUFRLENBQUNDLE1BQVQsQ0FBZ0JDLGFBQWhCLENBQThCZixJQUE5QixDQUFQO0FBQ0E7O0FBQ0QsV0FBTyxJQUFQO0FBQ0EsR0F0RFk7QUF3RGJnQixpQkFBZSxFQUFFLFVBQVVDLEtBQVYsRUFBaUI7QUFDakMsUUFBSUEsS0FBSyxDQUFDUCxTQUFOLENBQWdCQyxRQUFoQixDQUF5QixVQUF6QixDQUFKLEVBQTBDLE9BQU8sSUFBUDtBQUUxQyxRQUFJTyxJQUFJLEdBQUdELEtBQUssQ0FBQ1IsVUFBakI7O0FBQ0EsV0FBT1MsSUFBUCxFQUFhO0FBQ1osVUFBSUEsSUFBSSxDQUFDUixTQUFMLElBQWtCUSxJQUFJLENBQUNSLFNBQUwsQ0FBZUMsUUFBZixDQUF3QixVQUF4QixDQUF0QixFQUEyRDtBQUMxRCxlQUFPLElBQVA7QUFDQTs7QUFDRE8sVUFBSSxHQUFHQSxJQUFJLENBQUNULFVBQVo7QUFDQTs7QUFFRCxXQUFPLEtBQVA7QUFDQSxHQXBFWTtBQXNFYlUsYUFBVyxFQUFFLFVBQVNuQixJQUFULEVBQWVJLFdBQWYsRUFBNEJILFVBQTVCLEVBQXdDO0FBQ3BELFFBQUltQixJQUFJLEdBQUcsRUFBWDtBQUNBLFFBQUksQ0FBQ25CLFVBQUwsRUFBaUIsT0FBTyxFQUFQO0FBRWpCLFVBQU1JLFFBQVEsR0FBR0wsSUFBSSxDQUFDTSxnQkFBTCxDQUF1QiwyQkFBMEJMLFVBQVcsSUFBNUQsQ0FBakI7QUFDQUksWUFBUSxDQUFDRSxPQUFULENBQWtCQyxFQUFELElBQVE7QUFDeEIsVUFBSWEsY0FBYyxHQUFHYixFQUFFLENBQUNOLFlBQUgsQ0FBZ0Isa0JBQWhCLEtBQXVDLEVBQTVEO0FBQ0EsVUFBSW9CLElBQUksR0FBR2QsRUFBRSxDQUFDTixZQUFILENBQWdCLE1BQWhCLENBQVg7QUFDQSxVQUFJTCxLQUFLLEdBQUdXLEVBQUUsQ0FBQ1gsS0FBSCxJQUFZVyxFQUFFLENBQUNOLFlBQUgsQ0FBZ0IsT0FBaEIsQ0FBeEI7QUFDQSxVQUFJb0IsSUFBSSxLQUFLLEtBQWIsRUFBb0I7QUFDcEIsVUFBSSxDQUFDQSxJQUFELElBQVMsQ0FBQ3pCLEtBQWQsRUFBcUI7O0FBQ3JCLFVBQUlPLFdBQVcsSUFBSWlCLGNBQW5CLEVBQW1DO0FBQ2xDRCxZQUFJLENBQUNFLElBQUQsQ0FBSixHQUFhZCxFQUFFLENBQUNYLEtBQWhCO0FBQ0E7QUFDRCxLQVREO0FBVUEsV0FBT3VCLElBQVA7QUFDQSxHQXRGWTtBQXVGYjtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBRyxZQUFVLEVBQUUsVUFBUzVCLE9BQVQsRUFBa0I2QixRQUFRLEdBQUcsTUFBN0IsRUFBcUM7QUFDaEQsUUFBSSxDQUFDQyxPQUFPLENBQUNDLFNBQVIsQ0FBa0JDLE9BQXZCLEVBQWdDO0FBQy9CRixhQUFPLENBQUNDLFNBQVIsQ0FBa0JDLE9BQWxCLEdBQTRCRixPQUFPLENBQUNDLFNBQVIsQ0FBa0JFLGVBQWxCLElBQXFDSCxPQUFPLENBQUNDLFNBQVIsQ0FBa0JHLGtCQUF2RCxJQUE2RUosT0FBTyxDQUFDQyxTQUFSLENBQWtCSSxpQkFBL0YsSUFBb0hMLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkssZ0JBQXRJLElBQTBKTixPQUFPLENBQUNDLFNBQVIsQ0FBa0JNLHFCQUE1SyxJQUU1QixVQUFTQyxDQUFULEVBQVk7QUFDWCxZQUFJTixPQUFPLEdBQUcsQ0FBQyxLQUFLTyxRQUFMLElBQWlCLEtBQUtDLGFBQXZCLEVBQXNDN0IsZ0JBQXRDLENBQXVEMkIsQ0FBdkQsQ0FBZDtBQUFBLFlBQXlFRyxDQUFDLEdBQUdULE9BQU8sQ0FBQ1UsTUFBckY7O0FBQ0EsZUFBTyxFQUFFRCxDQUFGLElBQU8sQ0FBUCxJQUFZVCxPQUFPLENBQUNXLElBQVIsQ0FBYUYsQ0FBYixNQUFvQixJQUF2QyxFQUE2QyxDQUFFOztBQUMvQyxlQUFPQSxDQUFDLEdBQUcsQ0FBQyxDQUFaO0FBQ0EsT0FORDtBQU9BOztBQUVELFdBQVF6QyxPQUFPLElBQUlBLE9BQU8sS0FBS3VDLFFBQS9CLEVBQXlDdkMsT0FBTyxHQUFHQSxPQUFPLENBQUNjLFVBQTNELEVBQXdFO0FBQ3ZFLFVBQUtkLE9BQU8sQ0FBQ2dDLE9BQVIsQ0FBaUJILFFBQWpCLENBQUwsRUFBbUMsT0FBTzdCLE9BQVA7QUFDbkM7O0FBQ0QsV0FBTyxJQUFQO0FBQ0EsR0FqSVk7QUFtSWI0Qyx3QkFBc0IsRUFBRSxVQUFTNUMsT0FBVCxFQUFrQlMsV0FBbEIsRUFBK0I7QUFDdEQsUUFBSW9DLGVBQWUsR0FBRzdDLE9BQU8sQ0FBQ08sWUFBUixDQUFxQixrQkFBckIsQ0FBdEI7O0FBQ0EsUUFBSSxDQUFDc0MsZUFBRCxJQUFvQkEsZUFBZSxJQUFJLEVBQXZDLElBQTZDQSxlQUFlLElBQUksU0FBcEUsRUFBK0U7QUFDOUU3QyxhQUFPLENBQUNHLFlBQVIsQ0FBcUIsa0JBQXJCLEVBQXlDTSxXQUF6QztBQUNBO0FBQ0QsR0F4SVk7QUEwSWJxQyxnQkFBYyxFQUFFLFVBQVN6QyxJQUFULEVBQWU7QUFDOUIsUUFBSTBDLFdBQVcsR0FBRyxFQUFsQjtBQUNBLFFBQUksQ0FBQzFDLElBQUwsRUFBVyxPQUFPMEMsV0FBUDtBQUVYLFFBQUlDLEdBQUcsR0FBRzNDLElBQUksQ0FBQ00sZ0JBQUwsQ0FBc0IseUJBQXRCLENBQVY7QUFDQXFDLE9BQUcsQ0FBQ3BDLE9BQUosQ0FBYUMsRUFBRCxJQUFRO0FBQ25CLFVBQUlvQyxhQUFhLEdBQUdwQyxFQUFFLENBQUNOLFlBQUgsQ0FBZ0IsaUJBQWhCLENBQXBCOztBQUNBLFVBQUkwQyxhQUFhLElBQUksQ0FBQ0YsV0FBVyxDQUFDRyxRQUFaLENBQXFCRCxhQUFyQixDQUF0QixFQUEyRDtBQUMxREYsbUJBQVcsQ0FBQ0ksSUFBWixDQUFpQkYsYUFBakI7QUFDQTtBQUNELEtBTEQ7QUFNQSxXQUFPRixXQUFQO0FBQ0E7QUF0SlksQ0FBZDtlQXlKZWpELEsiLCJmaWxlIjoiLi4vQ29DcmVhdGUtZm9ybS9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IFV0aWxzID0ge1xuXG5cdGRpc2FibGVBdXRvRmlsbDogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGlmIChlbGVtZW50LnRhZ05hbWUgPT0gXCJURVhUQVJFQVwiKSB7XG5cdFx0XHRlbGVtZW50LnZhbHVlID0gXCJcIjtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIsXCJvZmZcIilcblx0XHR9XG5cdFx0aWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImF1dG9jb21wbGV0ZVwiKSkge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScsIFwib2ZmXCIpO1xuXHRcdH1cblx0fSxcblxuXHRzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKGZvcm0pIHtcblx0XHRcblx0XHRjb25zdCBjb2xsZWN0aW9uID0gZm9ybS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpIHx8IFwiXCI7IFxuXHRcdGNvbnN0IGRhdGFSZWFsVGltZSA9IGZvcm0uZ2V0QXR0cmlidXRlKCdkYXRhLXJlYWx0aW1lJyk7XG5cdFx0Y29uc3QgZG9jdW1lbnRfaWQgPSBmb3JtLmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpIHx8IFwiXCI7XG5cdFx0bGV0IGVsZW1lbnRzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdbbmFtZV0sIFtkYXRhLXBhc3NfdG9dJylcblx0XHRcblx0XHRcdFx0XHRcblx0XHRlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRpZiAoZWwucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3RlbXBsYXRlJykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWFsdGltZScpID09IG51bGwgJiYgZGF0YVJlYWxUaW1lKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpZiAoIVsnSU5QVVQnLCAnVEVYVEFSRUEnXS5pbmRleE9mKGVsLnRhZ05hbWUpKSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1yZWFsdGltZScsIGRhdGFSZWFsVGltZSk7XG5cdFx0XHRcdC8vIH1cblx0XHRcdH1cblx0XHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSAmJiAhZWwuaGFzQXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKSAmJiBjb2xsZWN0aW9uKSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJywgY29sbGVjdGlvbik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFzc190bycpICYmICFlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcGFzc19jb2xsZWN0aW9uJykgJiYgIGNvbGxlY3Rpb24pIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLXBhc3NfY29sbGVjdGlvbicsIGNvbGxlY3Rpb24pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoZWwuZ2V0QXR0cmlidXRlKCduYW1lJykgJiYgIWVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpICYmIGRvY3VtZW50X2lkKSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcsIGRvY3VtZW50X2lkKVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFlbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWRvY3VtZW50X2lkXCIpICYmIGRvY3VtZW50X2lkICE9IG51bGwpIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJywgZG9jdW1lbnRfaWQpXG5cdFx0XHR9XG5cblx0XHR9KVxuXHR9LFxuXG5cdGNoZWNrRm9ybVZhbGlkYXRlOiBmdW5jdGlvbihmb3JtKSB7XG5cdFx0XG5cdFx0aWYgKHR5cGVvZiBDb0NyZWF0ZS51bmlxdWUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gQ29DcmVhdGUudW5pcXVlLmNoZWNrVmFsaWRhdGUoZm9ybSlcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdFxuXHRpc1RlbXBsYXRlSW5wdXQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHRcdGlmIChpbnB1dC5jbGFzc0xpc3QuY29udGFpbnMoJ3RlbXBsYXRlJykpIHJldHVybiB0cnVlO1xuXHRcdFxuXHRcdGxldCBub2RlID0gaW5wdXQucGFyZW50Tm9kZTtcblx0XHR3aGlsZSAobm9kZSkge1xuXHRcdFx0aWYgKG5vZGUuY2xhc3NMaXN0ICYmIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZW1wbGF0ZScpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0bm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRcblx0Z2V0Rm9ybURhdGE6IGZ1bmN0aW9uKGZvcm0sIGRvY3VtZW50X2lkLCBjb2xsZWN0aW9uKSB7XG5cdFx0bGV0IGRhdGEgPSB7fTtcblx0XHRpZiAoIWNvbGxlY3Rpb24pIHJldHVybiB7fVxuXHRcdFxuXHRcdGNvbnN0IGVsZW1lbnRzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKGBbbmFtZV1bZGF0YS1jb2xsZWN0aW9uPScke2NvbGxlY3Rpb259J11gKVxuXHRcdGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRsZXQgZWxfZG9jdW1lbnRfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKSB8fCBcIlwiXG5cdFx0XHRsZXQgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpXG5cdFx0XHRsZXQgdmFsdWUgPSBlbC52YWx1ZSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcblx0XHRcdGlmIChuYW1lID09PSBcIl9pZFwiKSByZXR1cm47XG5cdFx0XHRpZiAoIW5hbWUgfHwgIXZhbHVlKSByZXR1cm47XG5cdFx0XHRpZiAoZG9jdW1lbnRfaWQgPT0gZWxfZG9jdW1lbnRfaWQpIHtcblx0XHRcdFx0ZGF0YVtuYW1lXSA9IGVsLnZhbHVlXG5cdFx0XHR9XG5cdFx0fSlcblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblx0Ly8gZ2V0Rm9ybURhdGE6IGZ1bmN0aW9uKGZvcm0sIHNlbGVjdG9ycykge1xuXHQvLyBcdGNvbnN0IHNlbGYgPSB0aGlzOyBcblx0Ly8gXHRjb25zdCBlbGVtZW50cyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcnMuam9pbignLCcpKTtcblx0XHRcblx0Ly8gXHRsZXQgcmVxdWVzdF9kb2N1bWVudF9pZCA9IGZhbHNlO1xuXHQvLyBcdGxldCBkYXRhTGlzdCA9IFtdO1xuXHRcdFxuXHRcdFxuXHQvLyBcdGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHQvLyBcdFx0bGV0IGNvbGxlY3Rpb24gPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpXG5cdC8vIFx0XHRsZXQgZG9jdW1lbnRfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKVxuXHQvLyBcdFx0bGV0IG5hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuXHRcdFx0XG5cdC8vIFx0XHRpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNhdmVfdmFsdWUnKSA9PSAnZmFsc2UnKSB7XG5cdC8vIFx0XHRcdHJldHVybjtcblx0Ly8gXHRcdH1cblx0XHRcdFxuXHQvLyBcdFx0aWYgKCFkb2N1bWVudF9pZCAmJiBuYW1lKSB7XG5cdC8vIFx0XHRcdHJlcXVlc3RfZG9jdW1lbnRfaWQgPSB0cnVlO1xuXHQvLyBcdFx0XHRyZXR1cm47XG5cdC8vIFx0XHR9XG5cdFx0XHRcblx0Ly8gXHRcdGxldCBkYXRhID0gZGF0YUxpc3QuZmluZChkID0+IGQuY29sbGVjdGlvbiA9PSBjb2xsZWN0aW9uICYmIGQuZG9jdW1lbnRfaWQgPT0gZG9jdW1lbnRfaWQpO1xuXHRcdFx0XHRcblx0Ly8gXHR9KVxuXHQvLyB9LFxuXHRcblx0Z2V0UGFyZW50czogZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IgPSBcImZvcm1cIikge1xuXHRcdGlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuXHRcdFx0RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XHRFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yIHx8XHRFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRcdFxuXHRcdFx0ZnVuY3Rpb24ocykge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICh0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzKSwgaSA9IG1hdGNoZXMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID49IDAgJiYgbWF0Y2hlcy5pdGVtKGkpICE9PSB0aGlzKSB7fVxuXHRcdFx0XHRyZXR1cm4gaSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0XG5cdFx0Zm9yICggOyBlbGVtZW50ICYmIGVsZW1lbnQgIT09IGRvY3VtZW50OyBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBlbGVtZW50Lm1hdGNoZXMoIHNlbGVjdG9yICkgKSByZXR1cm4gZWxlbWVudDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cdFxuXHRzZXREb2N1bWVudElET2ZFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBkb2N1bWVudF9pZCkge1xuXHRcdGxldCBvbGRfZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpO1xuXHRcdGlmICghb2xkX2RvY3VtZW50X2lkIHx8IG9sZF9kb2N1bWVudF9pZCA9PSBcIlwiIHx8IG9sZF9kb2N1bWVudF9pZCA9PSBcInBlbmRpbmdcIikge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnLCBkb2N1bWVudF9pZCk7XG5cdFx0fVxuXHR9LFxuXHRcblx0Z2V0Q09sbGVjdGlvbnM6IGZ1bmN0aW9uKGZvcm0pIHtcblx0XHRsZXQgY29sbGVjdGlvbnMgPSBbXTtcblx0XHRpZiAoIWZvcm0pIHJldHVybiBjb2xsZWN0aW9ucztcblxuXHRcdGxldCBlbHMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tuYW1lXVtkYXRhLWNvbGxlY3Rpb25dJyk7XG5cdFx0ZWxzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRsZXQgdG1wQ29sbGVjdGlvbiA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJylcblx0XHRcdGlmICh0bXBDb2xsZWN0aW9uICYmICFjb2xsZWN0aW9ucy5pbmNsdWRlcyh0bXBDb2xsZWN0aW9uKSkge1xuXHRcdFx0XHRjb2xsZWN0aW9ucy5wdXNoKHRtcENvbGxlY3Rpb24pXG5cdFx0XHR9IFxuXHRcdH0pXG5cdFx0cmV0dXJuIGNvbGxlY3Rpb25zO1xuXHR9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBVdGlsczsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-form/src/utils.js\n")},"../CoCreate-input/src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _src = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-observer/src */ \"../CoCreate-observer/src/index.js\"));\n\nvar _src2 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-form/src */ \"../CoCreate-form/src/index.js\"));\n\nvar _utils = _interopRequireDefault(__webpack_require__(/*! ../../../CoCreateJS/src/utils */ \"../../CoCreateJS/src/utils.js\"));\n\nvar _src3 = __webpack_require__(/*! ../../../CoCreateJS/src */ \"../../CoCreateJS/src/index.js\");\n\nvar _src4 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-crdt/src */ \"../CoCreate-crdt/src/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import CoCreateText from '../../CoCreate-text/src'\n// import CoCreateCursors from '../../CoCreate-cursors/src'\nconst CoCreateInput = {\n  selector: \"input, textarea, select\",\n  init: function () {\n    let inputs = document.querySelectorAll(this.selector);\n    const self = this;\n    inputs.forEach(input => {\n      const collection = input.getAttribute('data-collection');\n\n      if (_utils.default.isJsonString(collection)) {\n        return;\n      }\n\n      if (_utils.default.isUsageY(input)) {\n        return;\n      }\n\n      if (_src.default.getInitialized(input)) {\n        return;\n      }\n\n      _src.default.setInitialized(input, \"input\");\n\n      self.__initEvents(input);\n    });\n  },\n  initElement: function (container) {\n    let mainContainer = container || document;\n\n    if (!mainContainer.querySelectorAll) {\n      return;\n    }\n\n    const _this = this;\n\n    let inputs = mainContainer.querySelectorAll(this.selector);\n    inputs.forEach(input => {\n      if (_src.default.getInitialized(input, \"input\")) {\n        return;\n      }\n\n      _src.default.setInitialized(input, \"input\");\n\n      const collection = input.getAttribute('data-collection');\n      const id = input.getAttribute('data-document_id');\n\n      if (_utils.default.isJsonString(collection)) {\n        return;\n      }\n\n      if (_utils.default.isUsageY(input)) {\n        return;\n      }\n\n      if (id && collection) {\n        _src3.crud.readDocument({\n          collection: collection,\n          document_id: id\n        });\n      }\n\n      _this.__initEvents(input);\n    });\n  },\n  save: function (input) {\n    const value = this.getValue(input);\n    const collection = input.getAttribute('data-collection') || 'module_activity';\n    const document_id = input.getAttribute('data-document_id');\n    const name = input.getAttribute('name');\n\n    _src3.crud.updateDocument({\n      collection,\n      document_id,\n      data: {\n        [name]: value\n      } // broadcast_sender: false\n\n    });\n  },\n  render: function (data, allTags) {\n    let inputs = document.querySelectorAll(this.selector);\n\n    let _this = this;\n\n    inputs.forEach(input => {\n      if (!allTags) {\n        if (_utils.default.isUsageY(input)) return;\n      }\n\n      if (_utils.default.isUsageY(input)) return;\n      const collection = input.getAttribute('data-collection');\n      const id = input.getAttribute('data-document_id');\n      const name = input.getAttribute('name');\n      const data_fetch_value = input.getAttribute('data-fetch_value');\n      if (data_fetch_value === \"false\" || !_utils.default.isReadValue(input)) return;\n\n      if (data['collection'] == collection && data['document_id'] == id && name in data.data) {\n        _this.setValue(input, data['data'][name]); // fetch value event\n\n\n        input.dispatchEvent(new Event(\"updated_by_fetch\"));\n        input.dispatchEvent(new CustomEvent('CoCreateInput-run', {\n          eventType: 'rendered',\n          item: input\n        }));\n      }\n    });\n  },\n  getValue: function (input) {\n    let value = input.value;\n    let prefix = input.getAttribute('data-prefix_value') || \"\";\n    let suffix = input.getAttribute('data-suffix_value') || \"\";\n\n    if (input.type === \"checkbox\") {\n      value = input.checked;\n    } else if (input.type === \"number\") {\n      value = Number(value);\n    } else if (input.type === \"password\") {\n      value = this.__encryptPassword(value);\n    }\n\n    if (typeof value == \"string\") {\n      value = prefix + value + suffix;\n    }\n\n    return value;\n  },\n  setValue: function (input, value) {\n    if (input.type == 'checkbox') {\n      input.checked = value;\n    } else if (input.type === 'radio') {\n      input.value == value ? input.checked = true : input.checked = false;\n    }\n\n    if (input.type === 'password') {\n      value = this.__decryptPassword(value);\n    }\n\n    input.value = value;\n\n    if (CoCreate.floatingLabel) {\n      CoCreate.floatingLabel.update(input, value);\n    }\n\n    input.dispatchEvent(new CustomEvent('CoCreateInput-setvalue', {\n      eventType: 'rendered'\n    }));\n  },\n  __initEvents: function (input) {\n    let _this = this;\n\n    const self = this;\n    input.addEventListener('set-document_id', function () {\n      if (CoCreate.crdt) {\n        _src4.default.init({\n          collection: input.getAttribute('data-collection'),\n          document_id: input.getAttribute('data-document_id'),\n          name: input.getAttribute('name'),\n          element: input\n        });\n      }\n\n      self.save(this);\n    });\n    input.addEventListener('input', function (e) {\n      if (_utils.default.isRealTime(this)) {\n        self.save(this);\n      }\n    });\n    input.addEventListener('change', function (e) {\n      if (this.tagName == 'SELECT' && _utils.default.isRealTime(this)) {\n        self.save(this);\n      }\n    });\n\n    _src3.socket.listen('updateDocument', function (data) {\n      self.render(data);\n    });\n\n    _src3.socket.listen('connect', function (data) {\n      self.__getReqeust();\n    });\n\n    _src3.socket.listen('readDocument', function (data) {\n      self.render(data);\n    });\n\n    const collection = input.getAttribute('data-collection');\n    const document_id = input.getAttribute('data-document_id');\n\n    if (_utils.default.checkValue(collection) && _utils.default.checkValue(document_id) && CoCreate.crdt) {\n      _src4.default.init({\n        collection: collection,\n        document_id: document_id,\n        name: input.getAttribute('name'),\n        element: input\n      });\n    }\n  },\n  __getReqeust: function (container) {\n    let fetch_container = container || document;\n    let inputs = fetch_container.querySelectorAll(this.selector);\n    let requestData = [];\n    inputs.forEach(input => {\n      if (_utils.default.isUsageY(input)) return;\n      const collection = input.getAttribute('data-collection');\n      const id = input.getAttribute('data-document_id');\n\n      if (id && !requestData.some(d => d['collection'] === collection && d['document_id'] === id)) {\n        requestData.push({\n          'collection': collection,\n          'document_id': id\n        });\n      }\n    });\n    return requestData;\n  },\n  __encryptPassword: function (str) {\n    var encodedString = btoa(str);\n    return encodedString;\n  },\n  __decryptPassword: function (str) {\n    if (!str) {\n      return \"\";\n    }\n\n    var decode_str = atob(str);\n    return decode_str;\n  }\n};\nCoCreateInput.init();\n\n_src.default.init({\n  name: 'CoCreateInput',\n  observe: ['subtree', 'childList'],\n  include: '[data-collection][data-document_id][name]',\n  callback: function (mutation) {\n    CoCreateInput.initElement(mutation.target);\n  }\n});\n\n_src2.default.init({\n  name: 'CoCreateInput',\n  selector: \"input, textarea, select\",\n  callback: function (el) {\n    CoCreate.input.save(el);\n  }\n});\n\nvar _default = CoCreateInput;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLWlucHV0L3NyYy9pbmRleC5qcz82NzA2Il0sIm5hbWVzIjpbIkNvQ3JlYXRlSW5wdXQiLCJzZWxlY3RvciIsImluaXQiLCJpbnB1dHMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzZWxmIiwiZm9yRWFjaCIsImlucHV0IiwiY29sbGVjdGlvbiIsImdldEF0dHJpYnV0ZSIsInV0aWxzIiwiaXNKc29uU3RyaW5nIiwiaXNVc2FnZVkiLCJvYnNlcnZlciIsImdldEluaXRpYWxpemVkIiwic2V0SW5pdGlhbGl6ZWQiLCJfX2luaXRFdmVudHMiLCJpbml0RWxlbWVudCIsImNvbnRhaW5lciIsIm1haW5Db250YWluZXIiLCJfdGhpcyIsImlkIiwiY3J1ZCIsInJlYWREb2N1bWVudCIsImRvY3VtZW50X2lkIiwic2F2ZSIsInZhbHVlIiwiZ2V0VmFsdWUiLCJuYW1lIiwidXBkYXRlRG9jdW1lbnQiLCJkYXRhIiwicmVuZGVyIiwiYWxsVGFncyIsImRhdGFfZmV0Y2hfdmFsdWUiLCJpc1JlYWRWYWx1ZSIsInNldFZhbHVlIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJldmVudFR5cGUiLCJpdGVtIiwicHJlZml4Iiwic3VmZml4IiwidHlwZSIsImNoZWNrZWQiLCJOdW1iZXIiLCJfX2VuY3J5cHRQYXNzd29yZCIsIl9fZGVjcnlwdFBhc3N3b3JkIiwiQ29DcmVhdGUiLCJmbG9hdGluZ0xhYmVsIiwidXBkYXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNyZHQiLCJlbGVtZW50IiwiZSIsImlzUmVhbFRpbWUiLCJ0YWdOYW1lIiwic29ja2V0IiwibGlzdGVuIiwiX19nZXRSZXFldXN0IiwiY2hlY2tWYWx1ZSIsImZldGNoX2NvbnRhaW5lciIsInJlcXVlc3REYXRhIiwic29tZSIsImQiLCJwdXNoIiwic3RyIiwiZW5jb2RlZFN0cmluZyIsImJ0b2EiLCJkZWNvZGVfc3RyIiwiYXRvYiIsIm9ic2VydmUiLCJpbmNsdWRlIiwiY2FsbGJhY2siLCJtdXRhdGlvbiIsInRhcmdldCIsImZvcm0iLCJlbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBLE1BQU1BLGFBQWEsR0FBRztBQUVyQkMsVUFBUSxFQUFFLHlCQUZXO0FBSXJCQyxNQUFJLEVBQUUsWUFBVztBQUVoQixRQUFJQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsS0FBS0osUUFBL0IsQ0FBYjtBQUNBLFVBQU1LLElBQUksR0FBRyxJQUFiO0FBRUFILFVBQU0sQ0FBQ0ksT0FBUCxDQUFnQkMsS0FBRCxJQUFXO0FBRXpCLFlBQU1DLFVBQVUsR0FBR0QsS0FBSyxDQUFDRSxZQUFOLENBQW1CLGlCQUFuQixDQUFuQjs7QUFDQSxVQUFJQyxlQUFNQyxZQUFOLENBQW1CSCxVQUFuQixDQUFKLEVBQW9DO0FBQ25DO0FBQ0E7O0FBRUQsVUFBSUUsZUFBTUUsUUFBTixDQUFlTCxLQUFmLENBQUosRUFBMkI7QUFDMUI7QUFDQTs7QUFDRCxVQUFJTSxhQUFTQyxjQUFULENBQXdCUCxLQUF4QixDQUFKLEVBQW9DO0FBQ25DO0FBQ0E7O0FBQ0RNLG1CQUFTRSxjQUFULENBQXdCUixLQUF4QixFQUErQixPQUEvQjs7QUFDQUYsVUFBSSxDQUFDVyxZQUFMLENBQWtCVCxLQUFsQjtBQUVBLEtBaEJEO0FBaUJBLEdBMUJvQjtBQTRCckJVLGFBQVcsRUFBRSxVQUFTQyxTQUFULEVBQW9CO0FBRWhDLFFBQUlDLGFBQWEsR0FBR0QsU0FBUyxJQUFJZixRQUFqQzs7QUFDQSxRQUFJLENBQUNnQixhQUFhLENBQUNmLGdCQUFuQixFQUFxQztBQUNwQztBQUNBOztBQUVELFVBQU1nQixLQUFLLEdBQUcsSUFBZDs7QUFDQSxRQUFJbEIsTUFBTSxHQUFHaUIsYUFBYSxDQUFDZixnQkFBZCxDQUErQixLQUFLSixRQUFwQyxDQUFiO0FBRUFF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RSxVQUFTb0IsR0FBVCxFQUFjO0FBQ2hDLFFBQUlDLGFBQWEsR0FBR0MsSUFBSSxDQUFDRixHQUFELENBQXhCO0FBQ0EsV0FBT0MsYUFBUDtBQUNBLEdBbFBvQjtBQW9QckJwQixtQkFBaUIsRUFBRSxVQUFVbUIsR0FBVixFQUFlO0FBQ2pDLFFBQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQ1QsYUFBTyxFQUFQO0FBQ0E7O0FBRUQsUUFBSUcsVUFBVSxHQUFHQyxJQUFJLENBQUNKLEdBQUQsQ0FBckI7QUFDQSxXQUFPRyxVQUFQO0FBQ0E7QUEzUG9CLENBQXRCO0FBK1BBdEUsYUFBYSxDQUFDRSxJQUFkOztBQUVBWSxhQUFTWixJQUFULENBQWM7QUFDYjJCLE1BQUksRUFBRSxlQURPO0FBRWIyQyxTQUFPLEVBQUUsQ0FBQyxTQUFELEVBQVksV0FBWixDQUZJO0FBR2JDLFNBQU8sRUFBRSwyQ0FISTtBQUliQyxVQUFRLEVBQUUsVUFBU0MsUUFBVCxFQUFtQjtBQUM1QjNFLGlCQUFhLENBQUNrQixXQUFkLENBQTBCeUQsUUFBUSxDQUFDQyxNQUFuQztBQUNBO0FBTlksQ0FBZDs7QUFTQUMsY0FBSzNFLElBQUwsQ0FBVTtBQUNUMkIsTUFBSSxFQUFFLGVBREc7QUFFVDVCLFVBQVEsRUFBRSx5QkFGRDtBQUdUeUUsVUFBUSxFQUFFLFVBQVNJLEVBQVQsRUFBYTtBQUN0QjdCLFlBQVEsQ0FBQ3pDLEtBQVQsQ0FBZWtCLElBQWYsQ0FBb0JvRCxFQUFwQjtBQUNBO0FBTFEsQ0FBVjs7ZUFRZTlFLGEiLCJmaWxlIjoiLi4vQ29DcmVhdGUtaW5wdXQvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG9ic2VydmVyIGZyb20gJy4uLy4uL0NvQ3JlYXRlLW9ic2VydmVyL3NyYydcbmltcG9ydCBmb3JtIGZyb20gJy4uLy4uL0NvQ3JlYXRlLWZvcm0vc3JjJ1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uLy4uLy4uL0NvQ3JlYXRlSlMvc3JjL3V0aWxzJztcbmltcG9ydCB7c29ja2V0LCBjcnVkfSBmcm9tICcuLi8uLi8uLi9Db0NyZWF0ZUpTL3NyYyc7XG5pbXBvcnQgY3JkdCBmcm9tICcuLi8uLi9Db0NyZWF0ZS1jcmR0L3NyYydcbi8vIGltcG9ydCBDb0NyZWF0ZVRleHQgZnJvbSAnLi4vLi4vQ29DcmVhdGUtdGV4dC9zcmMnXG4vLyBpbXBvcnQgQ29DcmVhdGVDdXJzb3JzIGZyb20gJy4uLy4uL0NvQ3JlYXRlLWN1cnNvcnMvc3JjJ1xuXG5jb25zdCBDb0NyZWF0ZUlucHV0ID0ge1xuXHRcblx0c2VsZWN0b3I6IFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcIixcblx0XG5cdGluaXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0bGV0IGlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZWxlY3Rvcik7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0XG5cdFx0aW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG5cdFx0XHRcblx0XHRcdGNvbnN0IGNvbGxlY3Rpb24gPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpXG5cdFx0XHRpZiAodXRpbHMuaXNKc29uU3RyaW5nKGNvbGxlY3Rpb24pKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHV0aWxzLmlzVXNhZ2VZKGlucHV0KSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XHRcblx0XHRcdGlmIChvYnNlcnZlci5nZXRJbml0aWFsaXplZChpbnB1dCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b2JzZXJ2ZXIuc2V0SW5pdGlhbGl6ZWQoaW5wdXQsIFwiaW5wdXRcIik7XG5cdFx0XHRzZWxmLl9faW5pdEV2ZW50cyhpbnB1dCk7XG5cblx0XHR9KVxuXHR9LFxuXHRcblx0aW5pdEVsZW1lbnQ6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuXHRcdFxuXHRcdGxldCBtYWluQ29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50O1xuXHRcdGlmICghbWFpbkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnN0IF90aGlzID0gdGhpcztcblx0XHRsZXQgaW5wdXRzID0gbWFpbkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3IpO1xuXHRcdFxuXHRcdGlucHV0cy5mb3JFYWNoKChpbnB1dCk9PiB7XG5cdFx0XHRpZiAob2JzZXJ2ZXIuZ2V0SW5pdGlhbGl6ZWQoaW5wdXQsIFwiaW5wdXRcIikpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b2JzZXJ2ZXIuc2V0SW5pdGlhbGl6ZWQoaW5wdXQsIFwiaW5wdXRcIilcblx0XHRcdFxuXHRcdFx0Y29uc3QgY29sbGVjdGlvbiA9IGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJylcblx0XHRcdGNvbnN0IGlkID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJylcblx0XHRcdGlmICh1dGlscy5pc0pzb25TdHJpbmcoY29sbGVjdGlvbikpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodXRpbHMuaXNVc2FnZVkoaW5wdXQpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGlkICYmIGNvbGxlY3Rpb24pIHtcblx0XHRcdFx0Y3J1ZC5yZWFkRG9jdW1lbnQoe1xuXHRcdFx0XHRcdGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG5cdFx0XHRcdFx0ZG9jdW1lbnRfaWQ6IGlkXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRfdGhpcy5fX2luaXRFdmVudHMoaW5wdXQpO1xuXHRcdFx0XG5cblx0XHR9KVxuXHR9LFxuXHRcblx0c2F2ZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdFx0XG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGlucHV0KTtcblx0XHRjb25zdCBjb2xsZWN0aW9uID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKSB8fCAnbW9kdWxlX2FjdGl2aXR5J1xuXHRcdFxuXHRcdGNvbnN0IGRvY3VtZW50X2lkID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJylcblx0XHRjb25zdCBuYW1lID0gaW5wdXQuZ2V0QXR0cmlidXRlKCduYW1lJylcblx0XHRjcnVkLnVwZGF0ZURvY3VtZW50KHtcblx0XHRcdGNvbGxlY3Rpb24sXG5cdFx0XHRkb2N1bWVudF9pZCxcblx0XHRcdGRhdGE6IHtcblx0XHRcdFx0W25hbWVdOiB2YWx1ZVxuXHRcdFx0fSxcblx0XHRcdC8vIGJyb2FkY2FzdF9zZW5kZXI6IGZhbHNlXG5cdFx0fSlcblx0fSxcblx0XG5cblx0XG5cdHJlbmRlcjogZnVuY3Rpb24gKGRhdGEsIGFsbFRhZ3MpIHtcblx0XHRsZXQgaW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNlbGVjdG9yKVxuXHRcdGxldCBfdGhpcyA9IHRoaXM7XG5cdFx0XG5cdFx0aW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG5cdFx0XHRpZiAoIWFsbFRhZ3MpIHtcblx0XHRcdFx0aWYgKHV0aWxzLmlzVXNhZ2VZKGlucHV0KSkgcmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHV0aWxzLmlzVXNhZ2VZKGlucHV0KSkgcmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBjb2xsZWN0aW9uID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKVxuXHRcdFx0Y29uc3QgaWQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKVxuXHRcdFx0Y29uc3QgbmFtZSA9IGlucHV0LmdldEF0dHJpYnV0ZSgnbmFtZScpXG5cdFx0XHRjb25zdCBkYXRhX2ZldGNoX3ZhbHVlID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWZldGNoX3ZhbHVlJyk7XG5cdFx0XHRcblx0XHRcdGlmIChkYXRhX2ZldGNoX3ZhbHVlID09PSBcImZhbHNlXCIgfHwgIXV0aWxzLmlzUmVhZFZhbHVlKGlucHV0KSkgcmV0dXJuO1xuXHRcdFx0XG5cdFx0XHRpZiAoZGF0YVsnY29sbGVjdGlvbiddID09IGNvbGxlY3Rpb24gJiYgZGF0YVsnZG9jdW1lbnRfaWQnXSA9PSBpZCAmJiAobmFtZSBpbiBkYXRhLmRhdGEpKSB7XG5cdFx0XHRcdF90aGlzLnNldFZhbHVlKGlucHV0LCBkYXRhWydkYXRhJ11bbmFtZV0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZmV0Y2ggdmFsdWUgZXZlbnRcblx0XHRcdFx0aW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJ1cGRhdGVkX2J5X2ZldGNoXCIpKTsgXG5cdFx0XHRcdFxuXHRcdFx0XHRpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnQ29DcmVhdGVJbnB1dC1ydW4nLCB7XG5cdFx0XHRcdFx0ZXZlbnRUeXBlOiAncmVuZGVyZWQnLFxuXHRcdFx0XHRcdGl0ZW06IGlucHV0LFxuXHRcdFx0XHRcdFxuXHRcdFx0XHR9KSlcblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHR9LFxuXHRcblx0Z2V0VmFsdWU6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0bGV0IHZhbHVlID0gaW5wdXQudmFsdWU7XG5cblx0XHRsZXQgcHJlZml4ID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLXByZWZpeF92YWx1ZScpIHx8IFwiXCI7XG5cdFx0bGV0IHN1ZmZpeCA9IGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1zdWZmaXhfdmFsdWUnKSB8fCBcIlwiO1xuXHRcdFxuXHRcdGlmIChpbnB1dC50eXBlID09PSBcImNoZWNrYm94XCIpIHtcblx0XHRcdHZhbHVlID0gaW5wdXQuY2hlY2tlZFxuXHRcdH0gXG5cdFx0ZWxzZSBpZiAoaW5wdXQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0dmFsdWUgPSBOdW1iZXIodmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGlucHV0LnR5cGUgPT09IFwicGFzc3dvcmRcIikge1xuXHRcdFx0dmFsdWUgPSB0aGlzLl9fZW5jcnlwdFBhc3N3b3JkKHZhbHVlKVxuXHRcdH1cblx0XHRcblx0XHRpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhbHVlID0gcHJlZml4ICsgdmFsdWUgKyBzdWZmaXg7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0XG5cdHNldFZhbHVlOiBmdW5jdGlvbihpbnB1dCwgdmFsdWUpIHtcblx0XHRpZiAoaW5wdXQudHlwZSA9PSAnY2hlY2tib3gnKSB7XG5cdFx0XHRpbnB1dC5jaGVja2VkID0gdmFsdWU7XG5cdFx0fSBcblx0XHRlbHNlIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG5cdFx0XHRpbnB1dC52YWx1ZSA9PSB2YWx1ZSA/IGlucHV0LmNoZWNrZWQgPSB0cnVlIDogaW5wdXQuY2hlY2tlZCA9IGZhbHNlXG5cdFx0fVxuXHRcdFxuXHRcdGlmIChpbnB1dC50eXBlID09PSAncGFzc3dvcmQnKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX19kZWNyeXB0UGFzc3dvcmQodmFsdWUpO1xuXHRcdH1cblx0XHRcblx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlO1xuXG5cdFx0aWYgKENvQ3JlYXRlLmZsb2F0aW5nTGFiZWwpIHtcblx0XHRcdENvQ3JlYXRlLmZsb2F0aW5nTGFiZWwudXBkYXRlKGlucHV0LCB2YWx1ZSlcblx0XHR9XG5cdFx0XG5cdFx0aW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ0NvQ3JlYXRlSW5wdXQtc2V0dmFsdWUnLCB7IGV2ZW50VHlwZTogJ3JlbmRlcmVkJ30pKVxuXHR9LFxuXHRcblx0X19pbml0RXZlbnRzOiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdFxuXHRcdGxldCBfdGhpcyA9IHRoaXM7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0XG5cdFx0aW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignc2V0LWRvY3VtZW50X2lkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcblx0XHRcdGlmIChDb0NyZWF0ZS5jcmR0KSB7XG5cdFx0XHRcdGNyZHQuaW5pdCh7XG5cdFx0XHRcdFx0Y29sbGVjdGlvbjogaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKSxcblx0XHRcdFx0XHRkb2N1bWVudF9pZDogaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJyksXG5cdFx0XHRcdFx0bmFtZTogaW5wdXQuZ2V0QXR0cmlidXRlKCduYW1lJyksXG5cdFx0XHRcdFx0ZWxlbWVudDogaW5wdXRcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdHNlbGYuc2F2ZSh0aGlzKVxuXHRcdH0pXG5cdFx0XG5cdFx0aW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAodXRpbHMuaXNSZWFsVGltZSh0aGlzKSkge1xuXHRcdFx0XHRzZWxmLnNhdmUodGhpcylcblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHRcdGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmICh0aGlzLnRhZ05hbWUgPT0gJ1NFTEVDVCcgJiYgdXRpbHMuaXNSZWFsVGltZSh0aGlzKSkge1xuXHRcdFx0XHRzZWxmLnNhdmUodGhpcylcblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHRcdHNvY2tldC5saXN0ZW4oJ3VwZGF0ZURvY3VtZW50JywgZnVuY3Rpb24oZGF0YSkge1xuXHRcdCAgICBzZWxmLnJlbmRlcihkYXRhKTtcblx0XHR9KVxuXHRcdFxuXHRcdHNvY2tldC5saXN0ZW4oJ2Nvbm5lY3QnLCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRzZWxmLl9fZ2V0UmVxZXVzdCgpXG5cdFx0fSlcblx0XHRcblx0XHRzb2NrZXQubGlzdGVuKCdyZWFkRG9jdW1lbnQnLCBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICBcdHNlbGYucmVuZGVyKGRhdGEpO1xuXHRcdH0pXG5cdFx0Y29uc3QgY29sbGVjdGlvbiA9IGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJylcblx0XHRjb25zdCBkb2N1bWVudF9pZCA9IGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpXG5cdFx0XG5cdFx0aWYgKHV0aWxzLmNoZWNrVmFsdWUoY29sbGVjdGlvbikgJiYgdXRpbHMuY2hlY2tWYWx1ZShkb2N1bWVudF9pZCkgJiYgQ29DcmVhdGUuY3JkdCkge1xuXHRcdFx0Y3JkdC5pbml0KHtcblx0XHRcdFx0Y29sbGVjdGlvbjogY29sbGVjdGlvbixcblx0XHRcdFx0ZG9jdW1lbnRfaWQ6IGRvY3VtZW50X2lkLFxuXHRcdFx0XHRuYW1lOiBpbnB1dC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSxcblx0XHRcdFx0ZWxlbWVudDogaW5wdXRcblx0XHRcdH0pXG5cdFx0XHRcblx0XHR9XG5cdH0sXG5cdFxuXHRfX2dldFJlcWV1c3Q6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuXHRcdFxuXHRcdGxldCBmZXRjaF9jb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQ7XG5cdFx0bGV0IGlucHV0cyA9IGZldGNoX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3IpXG5cdFx0bGV0IHJlcXVlc3REYXRhID0gW107XG5cblx0XHRpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcblx0XHRcdGlmICh1dGlscy5pc1VzYWdlWShpbnB1dCkpIHJldHVybjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgY29sbGVjdGlvbiA9IGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJylcblx0XHRcdGNvbnN0IGlkID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJylcblx0XHRcdFxuXHRcdFx0aWYgKGlkICYmICFyZXF1ZXN0RGF0YS5zb21lKChkKSA9PiBkWydjb2xsZWN0aW9uJ10gPT09IGNvbGxlY3Rpb24gJiYgZFsnZG9jdW1lbnRfaWQnXSA9PT0gaWQpKSB7XG5cdFx0XHRcdHJlcXVlc3REYXRhLnB1c2goeyBcblx0XHRcdFx0XHQnY29sbGVjdGlvbic6IGNvbGxlY3Rpb24sIFxuXHRcdFx0XHRcdCdkb2N1bWVudF9pZCc6IGlkIFxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0cmV0dXJuIHJlcXVlc3REYXRhO1xuXHR9LFxuXHRcblx0X19lbmNyeXB0UGFzc3dvcmQ6IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBlbmNvZGVkU3RyaW5nID0gYnRvYShzdHIpO1xuXHRcdHJldHVybiBlbmNvZGVkU3RyaW5nO1xuXHR9LFxuXHRcblx0X19kZWNyeXB0UGFzc3dvcmQ6IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRpZiAoIXN0cikge1xuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBkZWNvZGVfc3RyID0gYXRvYihzdHIpO1xuXHRcdHJldHVybiBkZWNvZGVfc3RyO1xuXHR9XG5cdFxufVxuXG5Db0NyZWF0ZUlucHV0LmluaXQoKTtcblxub2JzZXJ2ZXIuaW5pdCh7IFxuXHRuYW1lOiAnQ29DcmVhdGVJbnB1dCcsIFxuXHRvYnNlcnZlOiBbJ3N1YnRyZWUnLCAnY2hpbGRMaXN0J10sXG5cdGluY2x1ZGU6ICdbZGF0YS1jb2xsZWN0aW9uXVtkYXRhLWRvY3VtZW50X2lkXVtuYW1lXScsIFxuXHRjYWxsYmFjazogZnVuY3Rpb24obXV0YXRpb24pIHtcblx0XHRDb0NyZWF0ZUlucHV0LmluaXRFbGVtZW50KG11dGF0aW9uLnRhcmdldClcblx0fVxufSlcblxuZm9ybS5pbml0KHtcblx0bmFtZTogJ0NvQ3JlYXRlSW5wdXQnLFxuXHRzZWxlY3RvcjogXCJpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdFwiLFxuXHRjYWxsYmFjazogZnVuY3Rpb24oZWwpIHtcblx0XHRDb0NyZWF0ZS5pbnB1dC5zYXZlKGVsKTtcblx0fVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlSW5wdXQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-input/src/index.js\n")},"../CoCreate-observer/src/index.js":(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n// window.addEventListener("load", () => {\n\n/*\nCoCreate.observer.init({ \n\tname: \'CoCreateFetchInit\', // no usage, just to provide for console debugging \n\tobserve: [\'subtree\', \'childList\',\'attributes\'], // the same parameters of options in #https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n\tattributes: [\'data-fetch_collection\'], // it doesn\'t count added nodes or remove nodes\n\tinclude: ".classname", // a selector to select only elements that matches\n\texclude: ".classname", // a selector to exclude elements from processing\n\tcallback: function(mutation) { // a function which gets a mutation object according to #https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord\n\t\tCoCreateFetch.initElement(mutation.target)\n\t}\n})\n*/\n\n/**\n * description\n * \n * @param {String} [name] - an optional name to provide for debugging console\n * @param {Array} observe - a list of mutation type to be observerd, a mix of possible `attributes`, `childList` or `subtree`\n * ... and other params can be here \n * \n * @return null\n */\nwindow.counter = 0;\nwindow.counter2 = 0;\n\nif (!Element.prototype.matches) {\n  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {\n    var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n        i = matches.length;\n\n    while (--i >= 0 && matches.item(i) !== this) {}\n\n    return i > -1;\n  };\n}\n\nconst CoCreateObserver = {\n  initTasks: new Map(),\n  attrTasks: new Map(),\n  rules: new Map(),\n  rulesArray: [],\n  __init: function () {\n    const self = this;\n    const observer = new MutationObserver((mutationsList, observer) => self.__callback(mutationsList, observer)); // setTimeout(()=>{\n\n    observer.observe(document.body, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: false,\n      attributeOldValue: true,\n      characterData: true\n    });\n  },\n  // init: function(data) {\n  //   this.add(data);\n  // },\n  init: function ({\n    observe,\n    include,\n    exclude,\n    attributes,\n    name,\n    callback\n  }) {\n    if (observe.some(x => x == "childList")) {\n      this.initTasks.set(callback, {\n        observe,\n        include,\n        exclude,\n        attributes,\n        name\n      });\n    }\n\n    if (observe.some(x => x == "attributes")) {\n      this.attrTasks.set(callback, {\n        observe,\n        include,\n        exclude,\n        attributes,\n        name\n      });\n    }\n  },\n  remove: function (callback) {\n    this.initTasks.delete(callback);\n    this.attrTasks.delete(callback);\n  },\n  addRule: function ({\n    include,\n    exclude,\n    name\n  }) {\n    this.rules.set(name, {\n      include,\n      exclude\n    });\n    this.rulesArray = Array.from(this.rules);\n  },\n  removeRule: function ({\n    name\n  }) {\n    this.rules.delete(name);\n    this.rulesArray = Array.from(this.rules);\n  },\n  __callback: function (mutationsList, observer) {\n    // console.log(this)\n    for (let mutation of mutationsList) {\n      if (mutation.type == "childList" && mutation.addedNodes.length > 0) {\n        //. run init functions\n        this.__initCallback(mutation);\n      }\n\n      if (mutation.type == "attributes") {\n        //. run attributes functions\n        this.__attrCallback(mutation);\n      }\n    }\n  },\n  __initCallback: function (mutation) {\n    let addedNodes = Array.from(mutation.addedNodes);\n    this.initTasks.forEach(({\n      observe,\n      include,\n      exclude,\n      attributes,\n      name\n    }, callback) => {\n      mutation.addedNodes.forEach(el => {\n        if (!el.tagName) return;\n\n        if (include && !(el.matches(include) || el.querySelector(include))) {\n          return;\n        }\n\n        if (exclude && (el.matches(exclude) || el.querySelector(exclude))) {\n          return;\n        }\n\n        if (el.created) return;\n        callback.apply(null, [{\n          type: mutation.type,\n          target: el\n        }]);\n      });\n    });\n    addedNodes.map(el => el.created = true);\n  },\n  __attrCallback: function (mutation) {\n    for (let [name, {\n      include,\n      exclude\n    }] of this.rulesArray) {\n      if (include && !mutation.target.matches(include)) return;\n      if (exclude && mutation.target.matches(exclude)) return;\n    }\n\n    this.attrTasks.forEach(({\n      observe,\n      include,\n      exclude,\n      attributes,\n      name\n    }, callback) => {\n      if (attributes && mutation.attributeName && !attributes.includes(mutation.attributeName)) {\n        return;\n      }\n\n      if (include && !mutation.target.matches(include)) return;\n      if (exclude && mutation.target.matches(exclude)) return;\n\n      if (mutation.attributeName) {\n        let newValue = mutation.target.getAttribute(mutation.attributeName);\n\n        if (newValue != mutation.oldValue) {\n          callback.apply(null, [mutation]);\n        }\n      }\n    });\n  },\n  setInitialized: function (element, type) {\n    // element.setAttribute(`initialized_${type}`, "true");\n    type = type || "";\n    let key = "co_initialized_" + type;\n    element[key] = true;\n  },\n  getInitialized: function (element, type) {\n    type = type || "";\n    let key = "co_initialized_" + type;\n\n    if (!element[key]) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n};\n\nCoCreateObserver.__init();\n\nvar _default = CoCreateObserver;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlLW9ic2VydmVyL3NyYy9pbmRleC5qcz9jZGYyIl0sIm5hbWVzIjpbIndpbmRvdyIsImNvdW50ZXIiLCJjb3VudGVyMiIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwicyIsImRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpIiwibGVuZ3RoIiwiaXRlbSIsIkNvQ3JlYXRlT2JzZXJ2ZXIiLCJpbml0VGFza3MiLCJNYXAiLCJhdHRyVGFza3MiLCJydWxlcyIsInJ1bGVzQXJyYXkiLCJfX2luaXQiLCJzZWxmIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zTGlzdCIsIl9fY2FsbGJhY2siLCJvYnNlcnZlIiwiYm9keSIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiY2hhcmFjdGVyRGF0YSIsImF0dHJpYnV0ZU9sZFZhbHVlIiwiaW5pdCIsImluY2x1ZGUiLCJleGNsdWRlIiwibmFtZSIsImNhbGxiYWNrIiwic29tZSIsIngiLCJzZXQiLCJyZW1vdmUiLCJkZWxldGUiLCJhZGRSdWxlIiwiQXJyYXkiLCJmcm9tIiwicmVtb3ZlUnVsZSIsIm11dGF0aW9uIiwidHlwZSIsImFkZGVkTm9kZXMiLCJfX2luaXRDYWxsYmFjayIsIl9fYXR0ckNhbGxiYWNrIiwiZm9yRWFjaCIsImVsIiwidGFnTmFtZSIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVkIiwiYXBwbHkiLCJ0YXJnZXQiLCJtYXAiLCJhdHRyaWJ1dGVOYW1lIiwiaW5jbHVkZXMiLCJuZXdWYWx1ZSIsImdldEF0dHJpYnV0ZSIsIm9sZFZhbHVlIiwic2V0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RUFBRSxVQUFTQyxPQUFULEVBQWtCbEIsSUFBbEIsRUFBd0I7QUFDeEM7QUFDQUEsUUFBSSxHQUFHQSxJQUFJLElBQUksRUFBZjtBQUNBLFFBQUltQixHQUFHLEdBQUcsb0JBQW9CbkIsSUFBOUI7QUFDQWtCLFdBQU8sQ0FBQ0MsR0FBRCxDQUFQLEdBQWUsSUFBZjtBQUNBLEdBckh1QjtBQXVIeEJDLGdCQUFjLEVBQUUsVUFBU0YsT0FBVCxFQUFrQmxCLElBQWxCLEVBQXdCO0FBQ3ZDQSxRQUFJLEdBQUdBLElBQUksSUFBSSxFQUFmO0FBQ0EsUUFBSW1CLEdBQUcsR0FBRyxvQkFBb0JuQixJQUE5Qjs7QUFDQSxRQUFJLENBQUNrQixPQUFPLENBQUNDLEdBQUQsQ0FBWixFQUFtQjtBQUNsQixhQUFPLEtBQVA7QUFDQSxLQUZELE1BRU87QUFDTixhQUFPLElBQVA7QUFDQTtBQUNEO0FBL0h1QixDQUF6Qjs7QUFrSUFyRCxnQkFBZ0IsQ0FBQ00sTUFBakI7O2VBR2VOLGdCIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLW9ic2VydmVyL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG5cbi8qXG5Db0NyZWF0ZS5vYnNlcnZlci5pbml0KHsgXG5cdG5hbWU6ICdDb0NyZWF0ZUZldGNoSW5pdCcsIC8vIG5vIHVzYWdlLCBqdXN0IHRvIHByb3ZpZGUgZm9yIGNvbnNvbGUgZGVidWdnaW5nIFxuXHRvYnNlcnZlOiBbJ3N1YnRyZWUnLCAnY2hpbGRMaXN0JywnYXR0cmlidXRlcyddLCAvLyB0aGUgc2FtZSBwYXJhbWV0ZXJzIG9mIG9wdGlvbnMgaW4gI2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NdXRhdGlvbk9ic2VydmVyL29ic2VydmVcblx0YXR0cmlidXRlczogWydkYXRhLWZldGNoX2NvbGxlY3Rpb24nXSwgLy8gaXQgZG9lc24ndCBjb3VudCBhZGRlZCBub2RlcyBvciByZW1vdmUgbm9kZXNcblx0aW5jbHVkZTogXCIuY2xhc3NuYW1lXCIsIC8vIGEgc2VsZWN0b3IgdG8gc2VsZWN0IG9ubHkgZWxlbWVudHMgdGhhdCBtYXRjaGVzXG5cdGV4Y2x1ZGU6IFwiLmNsYXNzbmFtZVwiLCAvLyBhIHNlbGVjdG9yIHRvIGV4Y2x1ZGUgZWxlbWVudHMgZnJvbSBwcm9jZXNzaW5nXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikgeyAvLyBhIGZ1bmN0aW9uIHdoaWNoIGdldHMgYSBtdXRhdGlvbiBvYmplY3QgYWNjb3JkaW5nIHRvICNodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTXV0YXRpb25SZWNvcmRcblx0XHRDb0NyZWF0ZUZldGNoLmluaXRFbGVtZW50KG11dGF0aW9uLnRhcmdldClcblx0fVxufSlcbiovXG5cblxuLyoqXG4gKiBkZXNjcmlwdGlvblxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gYW4gb3B0aW9uYWwgbmFtZSB0byBwcm92aWRlIGZvciBkZWJ1Z2dpbmcgY29uc29sZVxuICogQHBhcmFtIHtBcnJheX0gb2JzZXJ2ZSAtIGEgbGlzdCBvZiBtdXRhdGlvbiB0eXBlIHRvIGJlIG9ic2VydmVyZCwgYSBtaXggb2YgcG9zc2libGUgYGF0dHJpYnV0ZXNgLCBgY2hpbGRMaXN0YCBvciBgc3VidHJlZWBcbiAqIC4uLiBhbmQgb3RoZXIgcGFyYW1zIGNhbiBiZSBoZXJlIFxuICogXG4gKiBAcmV0dXJuIG51bGxcbiAqL1xuXG53aW5kb3cuY291bnRlciA9IDA7XG53aW5kb3cuY291bnRlcjIgPSAwO1xuaWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4gIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPVxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBtYXRjaGVzID0gKHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHMpLFxuICAgICAgICBpID0gbWF0Y2hlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoLS1pID49IDAgJiYgbWF0Y2hlcy5pdGVtKGkpICE9PSB0aGlzKSB7fVxuICAgICAgcmV0dXJuIGkgPiAtMTtcbiAgICB9O1xufVxuXG5jb25zdCBDb0NyZWF0ZU9ic2VydmVyID0ge1xuICBpbml0VGFza3M6IG5ldyBNYXAoKSxcbiAgYXR0clRhc2tzOiBuZXcgTWFwKCksXG4gIHJ1bGVzOiBuZXcgTWFwKCksXG4gIHJ1bGVzQXJyYXk6IFtdLFxuXG4gIF9faW5pdDogZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zTGlzdCwgb2JzZXJ2ZXIpID0+IHNlbGYuX19jYWxsYmFjayhtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikpO1xuICAgIFxuICAgIC8vIHNldFRpbWVvdXQoKCk9PntcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIFxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IGZhbHNlLFxuICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgIH1cbiAgICApO1xuICB9LFxuICBcbiAgLy8gaW5pdDogZnVuY3Rpb24oZGF0YSkge1xuICAvLyAgIHRoaXMuYWRkKGRhdGEpO1xuICAvLyB9LFxuICBcbiAgaW5pdDogZnVuY3Rpb24oeyBvYnNlcnZlLCBpbmNsdWRlLCBleGNsdWRlLCBhdHRyaWJ1dGVzLCBuYW1lLCBjYWxsYmFjayB9KSB7XG4gICAgaWYgKG9ic2VydmUuc29tZSh4ID0+IHggPT0gXCJjaGlsZExpc3RcIikpIHtcbiAgICAgIHRoaXMuaW5pdFRhc2tzLnNldChjYWxsYmFjaywgeyBvYnNlcnZlLCBpbmNsdWRlLCBleGNsdWRlLCBhdHRyaWJ1dGVzLCBuYW1lIH0pO1xuICAgIH1cbiAgICBcbiAgICBpZiAob2JzZXJ2ZS5zb21lKHggPT4gIHggPT0gXCJhdHRyaWJ1dGVzXCIpKSB7XG4gICAgICB0aGlzLmF0dHJUYXNrcy5zZXQoY2FsbGJhY2ssIHsgb2JzZXJ2ZSwgaW5jbHVkZSwgZXhjbHVkZSwgYXR0cmlidXRlcywgbmFtZSB9KTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLmluaXRUYXNrcy5kZWxldGUoY2FsbGJhY2spXG4gICAgdGhpcy5hdHRyVGFza3MuZGVsZXRlKGNhbGxiYWNrKVxuICB9LFxuICBcbiAgYWRkUnVsZTogZnVuY3Rpb24oeyBpbmNsdWRlLCBleGNsdWRlLCBuYW1lIH0pIHtcbiAgICB0aGlzLnJ1bGVzLnNldChuYW1lLCB7aW5jbHVkZSwgZXhjbHVkZX0pO1xuICAgIHRoaXMucnVsZXNBcnJheSA9IEFycmF5LmZyb20odGhpcy5ydWxlcyk7XG4gIH0sXG4gIFxuICByZW1vdmVSdWxlOiBmdW5jdGlvbiAoe25hbWV9KSB7XG4gICAgdGhpcy5ydWxlcy5kZWxldGUobmFtZSk7XG4gICAgdGhpcy5ydWxlc0FycmF5ID0gQXJyYXkuZnJvbSh0aGlzLnJ1bGVzKTtcbiAgfSxcbiAgXG4gIF9fY2FsbGJhY2s6IGZ1bmN0aW9uKG11dGF0aW9uc0xpc3QsIG9ic2VydmVyKSB7XG4gICAgLy8gY29uc29sZS5sb2codGhpcylcbiAgICBmb3IgKGxldCBtdXRhdGlvbiBvZiBtdXRhdGlvbnNMaXN0KSB7XG4gICAgICBpZiAobXV0YXRpb24udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG11dGF0aW9uLmFkZGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLy4gcnVuIGluaXQgZnVuY3Rpb25zXG4gICAgICAgIHRoaXMuX19pbml0Q2FsbGJhY2sobXV0YXRpb24pICAgIFxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAobXV0YXRpb24udHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAvLy4gcnVuIGF0dHJpYnV0ZXMgZnVuY3Rpb25zXG4gICAgICAgIHRoaXMuX19hdHRyQ2FsbGJhY2sobXV0YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXG4gIF9faW5pdENhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikge1xuICAgIGxldCBhZGRlZE5vZGVzID0gQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKTtcbiAgICBcbiAgICB0aGlzLmluaXRUYXNrcy5mb3JFYWNoKCh7b2JzZXJ2ZSwgaW5jbHVkZSwgZXhjbHVkZSwgYXR0cmlidXRlcywgbmFtZX0sIGNhbGxiYWNrKSA9PiB7XG5cbiAgICAgIG11dGF0aW9uLmFkZGVkTm9kZXMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgaWYgKCFlbC50YWdOYW1lKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBpZiAoaW5jbHVkZSAmJiAhKGVsLm1hdGNoZXMoaW5jbHVkZSkgfHwgZWwucXVlcnlTZWxlY3RvcihpbmNsdWRlKSkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBcbiAgICAgICAgaWYgKGV4Y2x1ZGUgJiYgKGVsLm1hdGNoZXMoZXhjbHVkZSkgfHwgZWwucXVlcnlTZWxlY3RvcihleGNsdWRlKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChlbC5jcmVhdGVkKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbe3R5cGU6IG11dGF0aW9uLnR5cGUsIHRhcmdldDogZWx9XSk7XG4gICAgICB9KVxuICAgIH0pO1xuICAgIFxuICAgIGFkZGVkTm9kZXMubWFwKGVsID0+IGVsLmNyZWF0ZWQgPSB0cnVlKTtcbiAgfSxcbiAgXG4gIF9fYXR0ckNhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbikge1xuICAgIGZvciAobGV0IFtuYW1lLCB7IGluY2x1ZGUsIGV4Y2x1ZGUgfV0gb2YgdGhpcy5ydWxlc0FycmF5KSB7XG4gICAgICBpZiAoaW5jbHVkZSAmJiAhbXV0YXRpb24udGFyZ2V0Lm1hdGNoZXMoaW5jbHVkZSkpIHJldHVybjtcbiAgICAgIGlmIChleGNsdWRlICYmIG11dGF0aW9uLnRhcmdldC5tYXRjaGVzKGV4Y2x1ZGUpKSByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXR0clRhc2tzLmZvckVhY2goKHtvYnNlcnZlLCBpbmNsdWRlLCBleGNsdWRlLCBhdHRyaWJ1dGVzLCBuYW1lfSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmIChhdHRyaWJ1dGVzICYmIG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgJiYgIWF0dHJpYnV0ZXMuaW5jbHVkZXMobXV0YXRpb24uYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGUgJiYgIW11dGF0aW9uLnRhcmdldC5tYXRjaGVzKGluY2x1ZGUpKSByZXR1cm47XG4gICAgICBpZiAoZXhjbHVkZSAmJiBtdXRhdGlvbi50YXJnZXQubWF0Y2hlcyhleGNsdWRlKSkgcmV0dXJuO1xuXG4gICAgICBpZiAobXV0YXRpb24uYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSBtdXRhdGlvbi50YXJnZXQuZ2V0QXR0cmlidXRlKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT0gbXV0YXRpb24ub2xkVmFsdWUpIHtcbiAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbbXV0YXRpb25dKTtcbiAgICAgICAgfVxuICAgICAgfSAgICAgIFxuICAgICAgXG4gICAgfSlcbiAgfSxcbiAgXG4gIHNldEluaXRpYWxpemVkOiBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG5cdFx0Ly8gZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGluaXRpYWxpemVkXyR7dHlwZX1gLCBcInRydWVcIik7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJcIjtcblx0XHRsZXQga2V5ID0gXCJjb19pbml0aWFsaXplZF9cIiArIHR5cGU7XG5cdFx0ZWxlbWVudFtrZXldID0gdHJ1ZTtcblx0fSxcblx0XG5cdGdldEluaXRpYWxpemVkOiBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJcIjtcblx0XHRsZXQga2V5ID0gXCJjb19pbml0aWFsaXplZF9cIiArIHR5cGU7XG5cdFx0aWYgKCFlbGVtZW50W2tleV0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG59XG5cbkNvQ3JlYXRlT2JzZXJ2ZXIuX19pbml0KCk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVPYnNlcnZlcjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-observer/src/index.js\n')},"./src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _src = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-observer/src */ \"../CoCreate-observer/src/index.js\"));\n\nvar _src2 = __webpack_require__(/*! ../../../CoCreateJS/src */ \"../../CoCreateJS/src/index.js\");\n\nvar _src3 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-input/src */ \"../CoCreate-input/src/index.js\"));\n\nvar _src4 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-action/src */ \"../CoCreate-action/src/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst CoCreateOrganization = {\n  masterDB: '5ae0cfac6fb8c4e656fdaf92',\n  // '5ae0cfac6fb8c4e656fdaf92' /** masterDB **/,\n  init: function () {\n    if (config.organization_Id) {\n      this.masterDB = config.organization_Id;\n    }\n\n    const self = this;\n\n    _src2.socket.listen('createOrg', function (data) {\n      self.setDocumentId('organizations', data.document_id);\n      document.dispatchEvent(new CustomEvent('createdOrg', {\n        detail: data\n      }));\n    });\n\n    _src2.socket.listen('createUser', function (data) {\n      self.setDocumentId('users', data.document_id);\n      document.dispatchEvent(new CustomEvent('createdUser', {\n        detail: data\n      }));\n    });\n  },\n  createOrg: function (btn) {\n    let form = btn.closest(\"form\");\n    if (!form) return;\n    let elements = form.querySelectorAll(\"[data-collection='organizations'][name]\");\n    let data = {}; //. get form data\n\n    elements.forEach(el => {\n      let name = el.getAttribute('name');\n      let value = _src3.default.getValue(el) || el.getAttribute('value');\n      if (!name || !value) return;\n\n      if (el.getAttribute('data-type') == 'array') {\n        value = [value];\n      }\n\n      data[name] = value;\n    });\n    const room = config.organization_Id;\n\n    _src2.socket.send('createOrg', {\n      apiKey: config.apiKey,\n      securityKey: config.securityKey,\n      organization_id: config.organization_Id,\n      db: this.masterDB,\n      collection: 'organizations',\n      data: data\n    }, room);\n  },\n  setDocumentId: function (collection, id) {\n    let orgIdElements = document.querySelectorAll(`[data-collection='${collection}']`);\n\n    if (orgIdElements && orgIdElements.length > 0) {\n      orgIdElements.forEach(el => {\n        if (!el.getAttribute('data-document_id')) {\n          el.setAttribute('data-document_id', id);\n        }\n\n        if (el.getAttribute('name') == \"_id\") {\n          el.value = id;\n        }\n      });\n    }\n  },\n  createUser: function (btn, reqData) {\n    let form = btn.closest(\"form\");\n    if (!form) return;\n    let org_id = \"\";\n    let elements = form.querySelectorAll(\"[data-collection='users'][name]\");\n    let orgIdElement = form.querySelector(\"input[data-collection='organizations'][name='_id']\");\n\n    if (orgIdElement) {\n      org_id = orgIdElement.value;\n    }\n\n    let data = {}; //. get form data\n\n    elements.forEach(el => {\n      let name = el.getAttribute('name');\n      let value = _src3.default.getValue(el) || el.getAttribute('value');\n      if (!name || !value) return;\n\n      if (el.getAttribute('data-type') == 'array') {\n        value = [value];\n      }\n\n      data[name] = value;\n    });\n    data['current_org'] = org_id;\n    data['connected_orgs'] = [org_id];\n    data['organization_id'] = org_id || config.organization_Id;\n    const room = config.organization_Id;\n\n    _src2.socket.send('createUser', {\n      apiKey: config.apiKey,\n      securityKey: config.securityKey,\n      organization_id: config.organization_Id,\n      db: this.masterDB,\n      collection: 'users',\n      data: data,\n      copyDB: org_id\n    }, room);\n  }\n};\nCoCreateOrganization.init();\n\n_src4.default.init({\n  action: \"createOrg\",\n  endEvent: \"createdOrg\",\n  callback: (btn, data) => {\n    CoCreateOrganization.createOrg(btn);\n  }\n});\n\n_src4.default.init({\n  action: \"createUser\",\n  endEvent: \"createdUser\",\n  callback: (btn, data) => {\n    CoCreateOrganization.createUser(btn);\n  }\n});\n\nvar _default = CoCreateOrganization;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOlsiQ29DcmVhdGVPcmdhbml6YXRpb24iLCJtYXN0ZXJEQiIsImluaXQiLCJjb25maWciLCJvcmdhbml6YXRpb25fSWQiLCJzZWxmIiwic29ja2V0IiwibGlzdGVuIiwiZGF0YSIsInNldERvY3VtZW50SWQiLCJkb2N1bWVudF9pZCIsImRvY3VtZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiY3JlYXRlT3JnIiwiYnRuIiwiZm9ybSIsImNsb3Nlc3QiLCJlbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJuYW1lIiwiZ2V0QXR0cmlidXRlIiwidmFsdWUiLCJpbnB1dCIsImdldFZhbHVlIiwicm9vbSIsInNlbmQiLCJhcGlLZXkiLCJzZWN1cml0eUtleSIsIm9yZ2FuaXphdGlvbl9pZCIsImRiIiwiY29sbGVjdGlvbiIsImlkIiwib3JnSWRFbGVtZW50cyIsImxlbmd0aCIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZVVzZXIiLCJyZXFEYXRhIiwib3JnX2lkIiwib3JnSWRFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImNvcHlEQiIsImFjdGlvbiIsImVuZEV2ZW50IiwiY2FsbGJhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBLE1BQU1BLG9CQUFvQixHQUFHO0FBQzVCQyxVQUFRLEVBQUUsMEJBRGtCO0FBQ1U7QUFDdENDLE1BQUksRUFBRSxZQUFXO0FBRWhCLFFBQUlDLE1BQU0sQ0FBQ0MsZUFBWCxFQUE0QjtBQUMzQixXQUFLSCxRQUFMLEdBQWdCRSxNQUFNLENBQUNDLGVBQXZCO0FBQ0E7O0FBQ0QsVUFBTUMsSUFBSSxHQUFHLElBQWI7O0FBQ0FDLGlCQUFPQyxNQUFQLENBQWMsV0FBZCxFQUEyQixVQUFTQyxJQUFULEVBQWU7QUFD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Q3pCQyxZQUFNLEVBQUUzQixNQUFNLENBQUMyQixNQURVO0FBRXpCQyxpQkFBVyxFQUFFNUIsTUFBTSxDQUFDNEIsV0FGSztBQUd6QkMscUJBQWUsRUFBRTdCLE1BQU0sQ0FBQ0MsZUFIQztBQUl6QjZCLFFBQUUsRUFBRSxLQUFLaEMsUUFKZ0I7QUFLekJpQyxnQkFBVSxFQUFFLE9BTGE7QUFNekIxQixVQUFJLEVBQUVBLElBTm1CO0FBT3pCb0MsWUFBTSxFQUFFSDtBQVBpQixLQUExQixFQVFHYixJQVJIO0FBU0E7QUF2RzJCLENBQTdCO0FBMkdBNUIsb0JBQW9CLENBQUNFLElBQXJCOztBQUVBMkMsY0FBTzNDLElBQVAsQ0FBWTtBQUNYMkMsUUFBTSxFQUFFLFdBREc7QUFFWEMsVUFBUSxFQUFFLFlBRkM7QUFHWEMsVUFBUSxFQUFFLENBQUMvQixHQUFELEVBQU1SLElBQU4sS0FBZTtBQUN4QlIsd0JBQW9CLENBQUNlLFNBQXJCLENBQStCQyxHQUEvQjtBQUNBO0FBTFUsQ0FBWjs7QUFRQTZCLGNBQU8zQyxJQUFQLENBQVk7QUFDWDJDLFFBQU0sRUFBRSxZQURHO0FBRVhDLFVBQVEsRUFBRSxhQUZDO0FBR1hDLFVBQVEsRUFBRSxDQUFDL0IsR0FBRCxFQUFNUixJQUFOLEtBQWU7QUFDeEJSLHdCQUFvQixDQUFDdUMsVUFBckIsQ0FBZ0N2QixHQUFoQztBQUNBO0FBTFUsQ0FBWjs7ZUFRZWhCLG9CIiwiZmlsZSI6Ii4vc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG9ic2VydmVyIGZyb20gJy4uLy4uL0NvQ3JlYXRlLW9ic2VydmVyL3NyYydcbmltcG9ydCB7c29ja2V0fSBmcm9tICcuLi8uLi8uLi9Db0NyZWF0ZUpTL3NyYyc7XG5pbXBvcnQgaW5wdXQgZnJvbSAnLi4vLi4vQ29DcmVhdGUtaW5wdXQvc3JjJ1xuaW1wb3J0IGFjdGlvbiBmcm9tICcuLi8uLi9Db0NyZWF0ZS1hY3Rpb24vc3JjJ1xuXG5jb25zdCBDb0NyZWF0ZU9yZ2FuaXphdGlvbiA9IHtcblx0bWFzdGVyREI6ICc1YWUwY2ZhYzZmYjhjNGU2NTZmZGFmOTInLCAvLyAnNWFlMGNmYWM2ZmI4YzRlNjU2ZmRhZjkyJyAvKiogbWFzdGVyREIgKiovLFxuXHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcblx0XHRpZiAoY29uZmlnLm9yZ2FuaXphdGlvbl9JZCkge1xuXHRcdFx0dGhpcy5tYXN0ZXJEQiA9IGNvbmZpZy5vcmdhbml6YXRpb25fSWQ7XG5cdFx0fVxuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdHNvY2tldC5saXN0ZW4oJ2NyZWF0ZU9yZycsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHNlbGYuc2V0RG9jdW1lbnRJZCgnb3JnYW5pemF0aW9ucycsIGRhdGEuZG9jdW1lbnRfaWQpO1xuXHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2NyZWF0ZWRPcmcnLCB7XG5cdFx0XHRcdGRldGFpbDogZGF0YVxuXHRcdFx0fSkpXG5cdFx0fSlcblx0XHRcblx0XHRzb2NrZXQubGlzdGVuKCdjcmVhdGVVc2VyJywgZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0c2VsZi5zZXREb2N1bWVudElkKCd1c2VycycsIGRhdGEuZG9jdW1lbnRfaWQpO1xuXHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2NyZWF0ZWRVc2VyJywge1xuXHRcdFx0XHRkZXRhaWw6IGRhdGFcblx0XHRcdH0pKVxuXHRcdH0pXG5cdH0sXG5cdFxuXHRjcmVhdGVPcmc6IGZ1bmN0aW9uKGJ0bikge1xuXHRcdGxldCBmb3JtID0gYnRuLmNsb3Nlc3QoXCJmb3JtXCIpO1xuXHRcdGlmICghZm9ybSkgcmV0dXJuO1xuXHRcdFxuXHRcdGxldCBlbGVtZW50cyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWNvbGxlY3Rpb249J29yZ2FuaXphdGlvbnMnXVtuYW1lXVwiKTtcblx0XHRcblx0XHRsZXQgZGF0YSA9IHt9O1xuXHRcdC8vLiBnZXQgZm9ybSBkYXRhXG5cdFx0ZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRsZXQgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpXG5cdFx0XHRsZXQgdmFsdWUgPSBpbnB1dC5nZXRWYWx1ZShlbCkgfHwgZWwuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG5cdFx0XHRpZiAoIW5hbWUgfHwgIXZhbHVlKSByZXR1cm47XG5cdFx0XHRpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKSA9PSAnYXJyYXknKSB7XG5cdFx0XHRcdHZhbHVlID0gW3ZhbHVlXTtcblx0XHRcdH1cblx0XHRcdGRhdGFbbmFtZV0gPSB2YWx1ZTtcblx0XHR9KVxuXHRcdGNvbnN0IHJvb20gPSBjb25maWcub3JnYW5pemF0aW9uX0lkO1xuXHRcdFxuXHRcdHNvY2tldC5zZW5kKCdjcmVhdGVPcmcnLCB7XG5cdFx0XHRhcGlLZXk6IGNvbmZpZy5hcGlLZXksXG5cdFx0XHRzZWN1cml0eUtleTogY29uZmlnLnNlY3VyaXR5S2V5LFxuXHRcdFx0b3JnYW5pemF0aW9uX2lkOiBjb25maWcub3JnYW5pemF0aW9uX0lkLFxuXHRcdFx0ZGI6IHRoaXMubWFzdGVyREIsXG5cdFx0XHRjb2xsZWN0aW9uOiAnb3JnYW5pemF0aW9ucycsXG5cdFx0XHRkYXRhOiBkYXRhXG5cdFx0fSwgcm9vbSk7XG5cdH0sXG5cdFxuXHRzZXREb2N1bWVudElkOiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpZCkge1xuXHRcdGxldCBvcmdJZEVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtY29sbGVjdGlvbj0nJHtjb2xsZWN0aW9ufSddYCk7XG5cdFx0aWYgKG9yZ0lkRWxlbWVudHMgJiYgb3JnSWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRvcmdJZEVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRcdGlmICghZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykpIHtcblx0XHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnLCBpZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpID09IFwiX2lkXCIpIHtcblx0XHRcdFx0XHRlbC52YWx1ZSA9IGlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH1cblx0fSxcblxuXHRjcmVhdGVVc2VyOiBmdW5jdGlvbihidG4sIHJlcURhdGEpIHtcblx0XHRsZXQgZm9ybSA9IGJ0bi5jbG9zZXN0KFwiZm9ybVwiKTtcblx0XHRpZiAoIWZvcm0pIHJldHVybjtcblx0XHRsZXQgb3JnX2lkID0gXCJcIjtcblx0XHRsZXQgZWxlbWVudHMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1jb2xsZWN0aW9uPSd1c2VycyddW25hbWVdXCIpO1xuXHRcdGxldCBvcmdJZEVsZW1lbnQgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFtkYXRhLWNvbGxlY3Rpb249J29yZ2FuaXphdGlvbnMnXVtuYW1lPSdfaWQnXVwiKTtcblx0XHRcblx0XHRpZiAob3JnSWRFbGVtZW50KSB7XG5cdFx0XHRvcmdfaWQgPSBvcmdJZEVsZW1lbnQudmFsdWU7XG5cdFx0fVxuXHRcdGxldCBkYXRhID0ge307XG5cdFx0Ly8uIGdldCBmb3JtIGRhdGFcblx0XHRlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcblx0XHRcdGxldCBuYW1lID0gZWwuZ2V0QXR0cmlidXRlKCduYW1lJylcblx0XHRcdGxldCB2YWx1ZSA9IGlucHV0LmdldFZhbHVlKGVsKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcblx0XHRcdGlmICghbmFtZSB8fCAhdmFsdWUpIHJldHVybjtcblx0XHRcdFxuXHRcdFx0aWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJykgPT0gJ2FycmF5Jykge1xuXHRcdFx0XHR2YWx1ZSA9IFt2YWx1ZV07XG5cdFx0XHR9XG5cdFx0XHRkYXRhW25hbWVdID0gdmFsdWU7XG5cdFx0fSlcblx0XHRkYXRhWydjdXJyZW50X29yZyddID0gb3JnX2lkO1xuXHRcdGRhdGFbJ2Nvbm5lY3RlZF9vcmdzJ10gPSBbb3JnX2lkXTtcblx0XHRkYXRhWydvcmdhbml6YXRpb25faWQnXSA9IG9yZ19pZCB8fCBjb25maWcub3JnYW5pemF0aW9uX0lkO1xuXHRcdFxuXHRcdGNvbnN0IHJvb20gPSBjb25maWcub3JnYW5pemF0aW9uX0lkO1xuXG5cdFx0c29ja2V0LnNlbmQoJ2NyZWF0ZVVzZXInLCB7XG5cdFx0XHRhcGlLZXk6IGNvbmZpZy5hcGlLZXksXG5cdFx0XHRzZWN1cml0eUtleTogY29uZmlnLnNlY3VyaXR5S2V5LFxuXHRcdFx0b3JnYW5pemF0aW9uX2lkOiBjb25maWcub3JnYW5pemF0aW9uX0lkLFxuXHRcdFx0ZGI6IHRoaXMubWFzdGVyREIsXG5cdFx0XHRjb2xsZWN0aW9uOiAndXNlcnMnLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdGNvcHlEQjogb3JnX2lkXG5cdFx0fSwgcm9vbSk7XG5cdH0sXG5cdFxufVxuXG5Db0NyZWF0ZU9yZ2FuaXphdGlvbi5pbml0KCk7XG5cbmFjdGlvbi5pbml0KHtcblx0YWN0aW9uOiBcImNyZWF0ZU9yZ1wiLFxuXHRlbmRFdmVudDogXCJjcmVhdGVkT3JnXCIsXG5cdGNhbGxiYWNrOiAoYnRuLCBkYXRhKSA9PiB7XG5cdFx0Q29DcmVhdGVPcmdhbml6YXRpb24uY3JlYXRlT3JnKGJ0bilcblx0fSxcbn0pXG5cbmFjdGlvbi5pbml0KHtcblx0YWN0aW9uOiBcImNyZWF0ZVVzZXJcIixcblx0ZW5kRXZlbnQ6IFwiY3JlYXRlZFVzZXJcIixcblx0Y2FsbGJhY2s6IChidG4sIGRhdGEpID0+IHtcblx0XHRDb0NyZWF0ZU9yZ2FuaXphdGlvbi5jcmVhdGVVc2VyKGJ0bilcblx0fSxcbn0pXG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlT3JnYW5pemF0aW9uOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n")},"../../CoCreateJS/src/common-fun.js":(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.getCommonParams = getCommonParams;\nexports.getCommonParamsExtend = getCommonParamsExtend;\nexports.generateSocketClient = generateSocketClient;\n\nfunction getCommonParams() {\n  return {\n    "apiKey": config.apiKey,\n    "securityKey": config.securityKey,\n    "organization_id": config.organization_Id\n  };\n}\n\nfunction getCommonParamsExtend(info) {\n  return {\n    "apiKey": info.apiKey || config.apiKey,\n    "securityKey": info.securityKey || config.securityKey,\n    "organization_id": info.organization_id || config.organization_Id\n  };\n}\n\nfunction generateSocketClient(namespace, room) {\n  let ns = namespace || config.organization_Id;\n  let rr = room || \'\';\n\n  if (rr) {\n    return `${ns}/${rr}`;\n  } else {\n    return ns;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlSlMvc3JjL2NvbW1vbi1mdW4uanM/Yjg5ZiJdLCJuYW1lcyI6WyJnZXRDb21tb25QYXJhbXMiLCJjb25maWciLCJhcGlLZXkiLCJzZWN1cml0eUtleSIsIm9yZ2FuaXphdGlvbl9JZCIsImdldENvbW1vblBhcmFtc0V4dGVuZCIsImluZm8iLCJvcmdhbml6YXRpb25faWQiLCJnZW5lcmF0ZVNvY2tldENsaWVudCIsIm5hbWVzcGFjZSIsInJvb20iLCJucyIsInJyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxTQUFTQSxlQUFULEdBQ0E7QUFDRSxTQUFPO0FBQ0wsY0FBb0JDLE1BQU0sQ0FBQ0MsTUFEdEI7QUFFTCxtQkFBb0JELE1BQU0sQ0FBQ0UsV0FGdEI7QUFHTCx1QkFBb0JGLE1BQU0sQ0FBQ0c7QUFIdEIsR0FBUDtBQUtEOztBQUVELFNBQVNDLHFCQUFULENBQStCQyxJQUEvQixFQUNBO0FBQ0UsU0FBTztBQUNMLGNBQW9CQSxJQUFJLENBQUNKLE1BQUwsSUFBZUQsTUFBTSxDQUFDQyxNQURyQztBQUVMLG1CQUFvQkksSUFBSSxDQUFDSCxXQUFMLElBQW9CRixNQUFNLENBQUNFLFdBRjFDO0FBR0wsdUJBQW9CRyxJQUFJLENBQUNDLGVBQUwsSUFBd0JOLE1BQU0sQ0FBQ0c7QUFIOUMsR0FBUDtBQUtEOztBQUVELFNBQVNJLG9CQUFULENBQStCQyxTQUEvQixFQUEwQ0MsSUFBMUMsRUFDQTtBQUNFLE1BQUlDLEVBQUUsR0FBR0YsU0FBUyxJQUFJUixNQUFNLENBQUNHLGVBQTdCO0FBQ0EsTUFBSVEsRUFBRSxHQUFHRixJQUFJLElBQUksRUFBakI7O0FBQ0EsTUFBSUUsRUFBSixFQUFRO0FBQ04sV0FBUSxHQUFFRCxFQUFHLElBQUdDLEVBQUcsRUFBbkI7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPRCxFQUFQO0FBQ0Q7QUFDRiIsImZpbGUiOiIuLi8uLi9Db0NyZWF0ZUpTL3NyYy9jb21tb24tZnVuLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0Q29tbW9uUGFyYW1zKCkgXG57XG4gIHJldHVybiB7XG4gICAgXCJhcGlLZXlcIjogICAgICAgICAgIGNvbmZpZy5hcGlLZXksXG4gICAgXCJzZWN1cml0eUtleVwiOiAgICAgIGNvbmZpZy5zZWN1cml0eUtleSxcbiAgICBcIm9yZ2FuaXphdGlvbl9pZFwiOiAgY29uZmlnLm9yZ2FuaXphdGlvbl9JZCxcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb21tb25QYXJhbXNFeHRlbmQoaW5mbykgXG57XG4gIHJldHVybiB7XG4gICAgXCJhcGlLZXlcIjogICAgICAgICAgIGluZm8uYXBpS2V5IHx8IGNvbmZpZy5hcGlLZXksXG4gICAgXCJzZWN1cml0eUtleVwiOiAgICAgIGluZm8uc2VjdXJpdHlLZXkgfHwgY29uZmlnLnNlY3VyaXR5S2V5LFxuICAgIFwib3JnYW5pemF0aW9uX2lkXCI6ICBpbmZvLm9yZ2FuaXphdGlvbl9pZCB8fCBjb25maWcub3JnYW5pemF0aW9uX0lkLFxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU29ja2V0Q2xpZW50IChuYW1lc3BhY2UsIHJvb20pIFxue1xuICBsZXQgbnMgPSBuYW1lc3BhY2UgfHwgY29uZmlnLm9yZ2FuaXphdGlvbl9JZFxuICBsZXQgcnIgPSByb29tIHx8ICcnO1xuICBpZiAocnIpIHtcbiAgICByZXR1cm4gYCR7bnN9LyR7cnJ9YFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBucztcbiAgfVxufVxuXG5leHBvcnQge2dldENvbW1vblBhcmFtcywgZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kLCBnZW5lcmF0ZVNvY2tldENsaWVudH07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/common-fun.js\n')},"../../CoCreateJS/src/core.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = core;\n// ***********   define variables end ***************** /// \nconst CoCreateCore = {\n  socketInitFuncs: [],\n  moduleSelectors: [],\n  socket: null,\n  host: 'server.cocreate.app',\n  setSocket: function (socket) {\n    this.socket = socket;\n  },\n  init: function (host, namespace) {\n    if (host) {\n      this.host = host;\n    }\n\n    this.__setConfig();\n\n    this.createGeneralSocket(host, namespace || config.organization_Id);\n    this.initSocketListener();\n    this.createUserSocket(host);\n  },\n  __setConfig: function () {\n    let orgId = window.localStorage.getItem('organization_id');\n    let securityKey = window.localStorage.getItem('securityKey');\n    let apiKey = window.localStorage.getItem('apiKey');\n    if (orgId) config['organization_Id'] = orgId;\n    if (apiKey) config['apiKey'] = apiKey;\n    if (securityKey) config['securityKey'] = securityKey;\n  },\n  initSocketListener: function () {\n    const self = this;\n    this.socket.listen('connect', function (data, room) {\n      if (room == self.socket.getGlobalScope()) {\n        self.socketInitFuncs.forEach(func => {\n          func.initFunc.call(func.instance);\n        });\n      }\n    });\n    this.socket.listen('readDocument', function (data) {\n      const metadata = data.metadata; // if (metadata && metadata.type == 'crdt') {\n      //   self.initRenderCrdtData(data);\n      // } else {\n      //   // self.renderModules(data)\n      // }\n\n      return data;\n    });\n    this.socket.listen('updateDocument', function (data) {// self.renderModules(data)\n    });\n    this.socket.listen('deletedDocument', function (data) {\n      console.log(data);\n    });\n    this.socket.listen('sendMessage', function (data) {\n      console.log(data);\n    });\n    this.listenMessage('downloadFileInfo', function (data) {\n      self.socket.saveFileName = data.file_name;\n    });\n  },\n  createUserSocket: function (host) {\n    var user_id = window.localStorage.getItem('user_id');\n\n    if (user_id) {\n      this.socket.create({\n        namespace: 'users',\n        room: user_id,\n        host: host\n      });\n    }\n  },\n  createGeneralSocket: function (host, namespace) {\n    if (namespace) {\n      this.socket.create({\n        namespace: namespace,\n        room: null,\n        host: host\n      });\n      this.socket.setGlobalScope(namespace);\n    } else {\n      this.socket.create({\n        namespace: null,\n        room: null,\n        host: host\n      });\n    }\n  },\n  registerInit: function (initFunc, instance) {\n    this.socketInitFuncs.push({\n      initFunc,\n      instance: instance || window\n    });\n  },\n  // registerSelector: function(selector) {\n  //   if (this.moduleSelectors.indexOf(selector) === -1) {\n  //     this.moduleSelectors.push(selector);\n  //   }\n  // },\n  // getSelectors: function(selector) {\n  //   return this.moduleSelectors.join(\",\");\n  // },\n  listenMessage: function (message, fun) {\n    this.socket.listen(message, fun);\n  },\n  createSocket: function (config) {\n    this.socket.create(config);\n  },\n  destroySocket: function (config) {\n    const {\n      namespace,\n      room\n    } = config;\n    const key = this.socket.getKey(namespace, room);\n    let socket = this.socket.sockets.get(key);\n\n    if (!socket) {\n      return;\n    }\n\n    this.socket.destroy(socket, key);\n  }\n};\n\nfunction core(socket) {\n  CoCreateCore.setSocket(socket);\n  return CoCreateCore;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlSlMvc3JjL2NvcmUuanM/Y2QxYSJdLCJuYW1lcyI6WyJDb0NyZWF0ZUNvcmUiLCJzb2NrZXRJbml0RnVuY3MiLCJtb2R1bGVTZWxlY3RvcnMiLCJzb2NrZXQiLCJob3N0Iiwic2V0U29ja2V0IiwiaW5pdCIsIm5hbWVzcGFjZSIsIl9fc2V0Q29uZmlnIiwiY3JlYXRlR2VuZXJhbFNvY2tldCIsImNvbmZpZyIsIm9yZ2FuaXphdGlvbl9JZCIsImluaXRTb2NrZXRMaXN0ZW5lciIsImNyZWF0ZVVzZXJTb2NrZXQiLCJvcmdJZCIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZWN1cml0eUtleSIsImFwaUtleSIsInNlbGYiLCJsaXN0ZW4iLCJkYXRhIiwicm9vbSIsImdldEdsb2JhbFNjb3BlIiwiZm9yRWFjaCIsImZ1bmMiLCJpbml0RnVuYyIsImNhbGwiLCJpbnN0YW5jZSIsIm1ldGFkYXRhIiwiY29uc29sZSIsImxvZyIsImxpc3Rlbk1lc3NhZ2UiLCJzYXZlRmlsZU5hbWUiLCJmaWxlX25hbWUiLCJ1c2VyX2lkIiwiY3JlYXRlIiwic2V0R2xvYmFsU2NvcGUiLCJyZWdpc3RlckluaXQiLCJwdXNoIiwibWVzc2FnZSIsImZ1biIsImNyZWF0ZVNvY2tldCIsImRlc3Ryb3lTb2NrZXQiLCJrZXkiLCJnZXRLZXkiLCJzb2NrZXRzIiwiZ2V0IiwiZGVzdHJveSIsImNvcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBRUEsTUFBTUEsWUFBWSxHQUFHO0FBQ25CQyxpQkFBZSxFQUFFLEVBREU7QUFFbkJDLGlCQUFlLEVBQUUsRUFGRTtBQUduQkMsUUFBTSxFQUFFLElBSFc7QUFJbkJDLE1BQUksRUFBRSxxQkFKYTtBQU1uQkMsV0FBUyxFQUFFLFVBQVNGLE1BQVQsRUFBaUI7QUFDMUIsU0FBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0QsR0FSa0I7QUFXbkJHLE1BQUksRUFBRSxVQUFTRixJQUFULEVBQWVHLFNBQWYsRUFBMEI7QUFDOUIsUUFBSUgsSUFBSixFQUFVO0FBQ1IsV0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0Q7O0FBRUQsU0FBS0ksV0FBTDs7QUFDQSxTQUFLQyxtQkFBTCxDQUF5QkwsSUFBekIsRUFBK0JHLFNBQVMsSUFBSUcsTUFBTSxDQUFDQyxlQUFuRDtBQUNBLFNBQUtDLGtCQUFMO0FBQ0EsU0FBS0MsZ0JBQUwsQ0FBc0JULElBQXRCO0FBQ0QsR0FwQmtCO0FBc0JuQkksYUFBVyxFQUFFLFlBQVc7QUFDeEIsUUFBSU0sS0FBSyxHQUFHQyxNQUFNLENBQUNDLFlBQVAsQ0FBb0JDLE9BQXBCLENBQTRCLGlCQUE1QixDQUFaO0FBQ0EsUUFBSUMsV0FBVyxHQUFHSCxNQUFNLENBQUNDLFlBQVAsQ0FBb0JDLE9BQXBCLENBQTRCLGFBQTVCLENBQWxCO0FBQ0EsUUFBSUUsTUFBTSxHQUFHSixNQUFNLENBQUNDLFlBQVAsQ0FBb0JDLE9BQXBCLENBQTRCLFFBQTVCLENBQWI7QUFFQSxRQUFJSCxLQUFKLEVBQWtCSixNQUFNLENBQUMsaUJBQUQsQ0FBTixHQUE0QkksS0FBNUI7QUFDbEIsUUFBSUssTUFBSixFQUFrQlQsTUFBTSxDQUFDLFFBQUQsQ0FBTixHQUFtQlMsTUFBbkI7QUFDbEIsUUFBSUQsV0FBSixFQUFrQlIsTUFBTSxDQUFDLGFBQUQsQ0FBTixHQUF3QlEsV0FBeEI7QUFDakIsR0E5QmtCO0FBZ0NuQk4sb0JBQWtCLEVBQUUsWUFBVztBQUM3QixVQUFNUSxJQUFJLEdBQUcsSUFBYjtBQUVBLFNBQUtqQixNQUFMLENBQVlrQixNQUFaLENBQW1CLFNBQW5CLEVBQThCLFVBQVVDLElBQVYsRUFBZ0JDLElBQWhCLEVBQXNCO0FBRWxELFVBQUlBLElBQUksSUFBSUgsSUFBSSxDQUFDakIsTUFBTCxDQUFZcUIsY0FBWixFQUFaLEVBQTBDO0FBQ3hDSixZQUFJLENBQUNuQixlQUFMLENBQXFCd0IsT0FBckIsQ0FBOEJDLElBQUQsSUFBVTtBQUNyQ0EsY0FBSSxDQUFDQyxRQUFMLENBQWNDLElBQWQsQ0FBbUJGLElBQUksQ0FBQ0csUUFBeEI7QUFDRCxTQUZEO0FBR0Q7QUFDRixLQVBEO0FBU0EsU0FBSzFCLE1BQUwsQ0FBWWtCLE1BQVosQ0FBbUIsY0FBbkIsRUFBbUMsVUFBU0MsSUFBVCxFQUFjO0FBQy9DLFlBQU1RLFFBQVEsR0FBR1IsSUFBSSxDQUFDUSxRQUF0QixDQUQrQyxDQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGFBQU9SLElBQVA7QUFDRCxLQVJEO0FBVUEsU0FBS25CLE1BQUwsQ0FBWWtCLE1BQVosQ0FBbUIsZ0JBQW5CLEVBQXFDLFVBQVNDLElBQVQsRUFBZSxDQUNsRDtBQUNELEtBRkQ7QUFJQSxTQUFLbkIsTUFBTCxDQUFZa0IsTUFBWixDQUFtQixpQkFBbkIsRUFBc0MsVUFBU0MsSUFBVCxFQUFlO0FBQ25EUyxhQUFPLENBQUNDLEdBQVIsQ0FBWVYsSUFBWjtBQUNELEtBRkQ7QUFJQSxTQUFLbkIsTUFBTCxDQUFZa0IsTUFBWixDQUFtQixhQUFuQixFQUFrQyxVQUFTQyxJQUFULEVBQWU7QUFDL0NTLGFBQU8sQ0FBQ0MsR0FBUixDQUFZVixJQUFaO0FBQ0QsS0FGRDtBQUlBLFNBQUtXLGFBQUwsQ0FBbUIsa0JBQW5CLEVBQXVDLFVBQVNYLElBQVQsRUFBZTtBQUNwREYsVUFBSSxDQUFDakIsTUFBTCxDQUFZK0IsWUFBWixHQUEyQlosSUFBSSxDQUFDYSxTQUFoQztBQUNELEtBRkQ7QUFJRCxHQXRFa0I7QUF3RW5CdEIsa0JBQWdCLEVBQUUsVUFBU1QsSUFBVCxFQUFlO0FBQy9CLFFBQUlnQyxPQUFPLEdBQUdyQixNQUFNLENBQUNDLFlBQVAsQ0FBb0JDLE9BQXBCLENBQTRCLFNBQTVCLENBQWQ7O0FBQ0EsUUFBSW1CLE9BQUosRUFBYTtBQUNYLFdBQUtqQyxNQUFMLENBQVlrQyxNQUFaLENBQW1CO0FBQ2pCOUIsaUJBQVMsRUFBRSxPQURNO0FBRWpCZ0IsWUFBSSxFQUFFYSxPQUZXO0FBR2pCaEMsWUFBSSxFQUFFQTtBQUhXLE9BQW5CO0FBS0Q7QUFDRixHQWpGa0I7QUFtRm5CSyxxQkFBbUIsRUFBRSxVQUFTTCxJQUFULEVBQWVHLFNBQWYsRUFBMEI7QUFDN0MsUUFBSUEsU0FBSixFQUFlO0FBQ2QsV0FBS0osTUFBTCxDQUFZa0MsTUFBWixDQUFtQjtBQUNqQjlCLGlCQUFTLEVBQUVBLFNBRE07QUFFakJnQixZQUFJLEVBQUUsSUFGVztBQUdqQm5CLFlBQUksRUFBRUE7QUFIVyxPQUFuQjtBQUtBLFdBQUtELE1BQUwsQ0FBWW1DLGNBQVosQ0FBMkIvQixTQUEzQjtBQUNBLEtBUEQsTUFPTztBQUNOLFdBQUtKLE1BQUwsQ0FBWWtDLE1BQVosQ0FBbUI7QUFDakI5QixpQkFBUyxFQUFFLElBRE07QUFFakJnQixZQUFJLEVBQUUsSUFGVztBQUdqQm5CLFlBQUksRUFBRUE7QUFIVyxPQUFuQjtBQUtBO0FBQ0YsR0FsR2tCO0FBb0duQm1DLGNBQVksRUFBRSxVQUFTWixRQUFULEVBQW1CRSxRQUFuQixFQUE2QjtBQUN6QyxTQUFLNUIsZUFBTCxDQUFxQnVDLElBQXJCLENBQTBCO0FBQ3hCYixjQUR3QjtBQUV4QkUsY0FBUSxFQUFHQSxRQUFRLElBQUlkO0FBRkMsS0FBMUI7QUFJRCxHQXpHa0I7QUEwR25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQWtCLGVBQWEsRUFBRSxVQUFTUSxPQUFULEVBQWtCQyxHQUFsQixFQUF1QjtBQUNwQyxTQUFLdkMsTUFBTCxDQUFZa0IsTUFBWixDQUFtQm9CLE9BQW5CLEVBQTRCQyxHQUE1QjtBQUNELEdBdEhrQjtBQXdIcEJDLGNBQVksRUFBRSxVQUFTakMsTUFBVCxFQUFpQjtBQUM3QixTQUFLUCxNQUFMLENBQVlrQyxNQUFaLENBQW1CM0IsTUFBbkI7QUFDRCxHQTFIbUI7QUE0SHBCa0MsZUFBYSxFQUFFLFVBQVNsQyxNQUFULEVBQWlCO0FBQzlCLFVBQU07QUFBQ0gsZUFBRDtBQUFZZ0I7QUFBWixRQUFvQmIsTUFBMUI7QUFDQSxVQUFNbUMsR0FBRyxHQUFHLEtBQUsxQyxNQUFMLENBQVkyQyxNQUFaLENBQW1CdkMsU0FBbkIsRUFBOEJnQixJQUE5QixDQUFaO0FBQ0EsUUFBSXBCLE1BQU0sR0FBRyxLQUFLQSxNQUFMLENBQVk0QyxPQUFaLENBQW9CQyxHQUFwQixDQUF3QkgsR0FBeEIsQ0FBYjs7QUFFQSxRQUFJLENBQUMxQyxNQUFMLEVBQWE7QUFDWDtBQUNEOztBQUNELFNBQUtBLE1BQUwsQ0FBWThDLE9BQVosQ0FBb0I5QyxNQUFwQixFQUE0QjBDLEdBQTVCO0FBQ0Q7QUFySW1CLENBQXJCOztBQXdJZSxTQUFTSyxJQUFULENBQWMvQyxNQUFkLEVBQXNCO0FBQ25DSCxjQUFZLENBQUNLLFNBQWIsQ0FBdUJGLE1BQXZCO0FBQ0EsU0FBT0gsWUFBUDtBQUNEIiwiZmlsZSI6Ii4uLy4uL0NvQ3JlYXRlSlMvc3JjL2NvcmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAqKioqKioqKioqKiAgIGRlZmluZSB2YXJpYWJsZXMgZW5kICoqKioqKioqKioqKioqKioqIC8vLyBcblxuY29uc3QgQ29DcmVhdGVDb3JlID0ge1xuICBzb2NrZXRJbml0RnVuY3M6IFtdLFxuICBtb2R1bGVTZWxlY3RvcnM6IFtdLFxuICBzb2NrZXQ6IG51bGwsXG4gIGhvc3Q6ICdzZXJ2ZXIuY29jcmVhdGUuYXBwJyxcbiAgXG4gIHNldFNvY2tldDogZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gIH0sXG5cbiAgXG4gIGluaXQ6IGZ1bmN0aW9uKGhvc3QsIG5hbWVzcGFjZSkge1xuICAgIGlmIChob3N0KSB7XG4gICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9fc2V0Q29uZmlnKClcbiAgICB0aGlzLmNyZWF0ZUdlbmVyYWxTb2NrZXQoaG9zdCwgbmFtZXNwYWNlIHx8IGNvbmZpZy5vcmdhbml6YXRpb25fSWQpO1xuICAgIHRoaXMuaW5pdFNvY2tldExpc3RlbmVyKCk7XG4gICAgdGhpcy5jcmVhdGVVc2VyU29ja2V0KGhvc3QpO1xuICB9LFxuICBcbiAgX19zZXRDb25maWc6IGZ1bmN0aW9uKCkge1xuXHRcdGxldCBvcmdJZCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnb3JnYW5pemF0aW9uX2lkJyk7XG5cdFx0bGV0IHNlY3VyaXR5S2V5ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzZWN1cml0eUtleScpO1xuXHRcdGxldCBhcGlLZXkgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FwaUtleScpO1xuXHRcdFxuXHRcdGlmIChvcmdJZCkgICAgICAgIGNvbmZpZ1snb3JnYW5pemF0aW9uX0lkJ10gPSBvcmdJZFxuXHRcdGlmIChhcGlLZXkpICAgICAgIGNvbmZpZ1snYXBpS2V5J10gPSBhcGlLZXlcblx0XHRpZiAoc2VjdXJpdHlLZXkpICBjb25maWdbJ3NlY3VyaXR5S2V5J10gPSBzZWN1cml0eUtleTtcbiAgfSxcbiAgXG4gIGluaXRTb2NrZXRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgdGhpcy5zb2NrZXQubGlzdGVuKCdjb25uZWN0JywgZnVuY3Rpb24gKGRhdGEsIHJvb20pIHtcbiAgICAgIFxuICAgICAgaWYgKHJvb20gPT0gc2VsZi5zb2NrZXQuZ2V0R2xvYmFsU2NvcGUoKSkge1xuICAgICAgICBzZWxmLnNvY2tldEluaXRGdW5jcy5mb3JFYWNoKChmdW5jKSA9PiB7XG4gICAgICAgICAgZnVuYy5pbml0RnVuYy5jYWxsKGZ1bmMuaW5zdGFuY2UpO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgdGhpcy5zb2NrZXQubGlzdGVuKCdyZWFkRG9jdW1lbnQnLCBmdW5jdGlvbihkYXRhKXtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gZGF0YS5tZXRhZGF0YTtcbiAgICAgIC8vIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS50eXBlID09ICdjcmR0Jykge1xuICAgICAgLy8gICBzZWxmLmluaXRSZW5kZXJDcmR0RGF0YShkYXRhKTtcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIC8vIHNlbGYucmVuZGVyTW9kdWxlcyhkYXRhKVxuICAgICAgLy8gfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSlcbiAgICBcbiAgICB0aGlzLnNvY2tldC5saXN0ZW4oJ3VwZGF0ZURvY3VtZW50JywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgLy8gc2VsZi5yZW5kZXJNb2R1bGVzKGRhdGEpXG4gICAgfSlcbiAgICBcbiAgICB0aGlzLnNvY2tldC5saXN0ZW4oJ2RlbGV0ZWREb2N1bWVudCcsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgIH0pXG4gICAgXG4gICAgdGhpcy5zb2NrZXQubGlzdGVuKCdzZW5kTWVzc2FnZScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgIH0pXG4gICAgXG4gICAgdGhpcy5saXN0ZW5NZXNzYWdlKCdkb3dubG9hZEZpbGVJbmZvJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgc2VsZi5zb2NrZXQuc2F2ZUZpbGVOYW1lID0gZGF0YS5maWxlX25hbWU7XG4gICAgfSlcbiAgICBcbiAgfSxcbiAgXG4gIGNyZWF0ZVVzZXJTb2NrZXQ6IGZ1bmN0aW9uKGhvc3QpIHtcbiAgICB2YXIgdXNlcl9pZCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcl9pZCcpO1xuICAgIGlmICh1c2VyX2lkKSB7XG4gICAgICB0aGlzLnNvY2tldC5jcmVhdGUoe1xuICAgICAgICBuYW1lc3BhY2U6ICd1c2VycycsXG4gICAgICAgIHJvb206IHVzZXJfaWQsXG4gICAgICAgIGhvc3Q6IGhvc3RcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICBcbiAgY3JlYXRlR2VuZXJhbFNvY2tldDogZnVuY3Rpb24oaG9zdCwgbmFtZXNwYWNlKSB7XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgIFx0dGhpcy5zb2NrZXQuY3JlYXRlKHtcbiAgICBcdCAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIFxuICAgIFx0ICByb29tOiBudWxsLFxuICAgIFx0ICBob3N0OiBob3N0XG4gICAgXHR9KTtcbiAgICBcdHRoaXMuc29ja2V0LnNldEdsb2JhbFNjb3BlKG5hbWVzcGFjZSk7XG4gICAgfSBlbHNlIHtcbiAgICBcdHRoaXMuc29ja2V0LmNyZWF0ZSh7XG4gICAgXHQgIG5hbWVzcGFjZTogbnVsbCwgXG4gICAgXHQgIHJvb206IG51bGwsXG4gICAgXHQgIGhvc3Q6IGhvc3RcbiAgICBcdH0pO1xuICAgIH1cbiAgfSxcbiAgXG4gIHJlZ2lzdGVySW5pdDogZnVuY3Rpb24oaW5pdEZ1bmMsIGluc3RhbmNlKSB7XG4gICAgdGhpcy5zb2NrZXRJbml0RnVuY3MucHVzaCh7XG4gICAgICBpbml0RnVuYyxcbiAgICAgIGluc3RhbmNlIDogaW5zdGFuY2UgfHwgd2luZG93XG4gICAgfSk7XG4gIH0sXG4gIC8vIHJlZ2lzdGVyU2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIC8vICAgaWYgKHRoaXMubW9kdWxlU2VsZWN0b3JzLmluZGV4T2Yoc2VsZWN0b3IpID09PSAtMSkge1xuICAvLyAgICAgdGhpcy5tb2R1bGVTZWxlY3RvcnMucHVzaChzZWxlY3Rvcik7XG4gIC8vICAgfVxuICAvLyB9LFxuICBcbiAgLy8gZ2V0U2VsZWN0b3JzOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAvLyAgIHJldHVybiB0aGlzLm1vZHVsZVNlbGVjdG9ycy5qb2luKFwiLFwiKTtcbiAgLy8gfSxcblxuICBsaXN0ZW5NZXNzYWdlOiBmdW5jdGlvbihtZXNzYWdlLCBmdW4pIHtcbiAgICB0aGlzLnNvY2tldC5saXN0ZW4obWVzc2FnZSwgZnVuKTtcbiAgfSxcbiBcbiBjcmVhdGVTb2NrZXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgdGhpcy5zb2NrZXQuY3JlYXRlKGNvbmZpZyk7XG4gfSxcbiBcbiBkZXN0cm95U29ja2V0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgIGNvbnN0IHtuYW1lc3BhY2UsIHJvb219ID0gY29uZmlnO1xuICAgY29uc3Qga2V5ID0gdGhpcy5zb2NrZXQuZ2V0S2V5KG5hbWVzcGFjZSwgcm9vbSk7XG4gICBsZXQgc29ja2V0ID0gdGhpcy5zb2NrZXQuc29ja2V0cy5nZXQoa2V5KTtcbiAgIFxuICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgcmV0dXJuXG4gICB9XG4gICB0aGlzLnNvY2tldC5kZXN0cm95KHNvY2tldCwga2V5KTtcbiB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb3JlKHNvY2tldCkge1xuICBDb0NyZWF0ZUNvcmUuc2V0U29ja2V0KHNvY2tldCk7XG4gIHJldHVybiBDb0NyZWF0ZUNvcmU7XG59XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/core.js\n")},"../../CoCreateJS/src/crud.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = CRUD;\n\nvar _commonFun = __webpack_require__(/*! ./common-fun.js */ \"../../CoCreateJS/src/common-fun.js\");\n\nvar _utilsCrud = _interopRequireDefault(__webpack_require__(/*! ./utils.crud.js */ \"../../CoCreateJS/src/utils.crud.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// ***********   define variables end ***************** /// \nvar data = {\n  \"org_id\": \"xxx\",\n  \"customer.name\": \"Jin\",\n  \"customer.fristname\": \"Jin\",\n  \"customer.lastname\": \"CF\",\n  \"customer.address.line1\": \"line1\",\n  \"customer.address.line2\": \"line2\",\n  'scope[0]': 'testing',\n  'scope[1]': '---',\n  \"customer.orders[0]\": 123,\n  \"customer.orders[1]\": 243\n};\nvar obj = {\n  test: {\n    \"name\": '123',\n    \"address\": 'address',\n    \"customer\": {\n      \"name\": 'tttt'\n    },\n    \"orders\": [1, 2, 3]\n  }\n};\nconsole.log('----- convert object -----');\nconsole.log(_utilsCrud.default.decodeObject(data));\nconsole.log(_utilsCrud.default.encodeObject(obj));\nconst CoCreateCRUD = {\n  socket: null,\n  setSocket: function (socket) {\n    this.socket = socket;\n  },\n\n  /*\n   \n    CoCreate.crud.readDcoumentList {\n      collection: \"modules\",\n      element: \"xxxx\",\n      metadata: \"\",\n      operator: {\n        fetch: {\n          name: 'xxxx',\n          value: 'xxxxx'\n        },\n        filters: [{\n          name: 'field1',\n          operator: \"contain | range | eq | ne | lt | lte | gt | gte | in | nin\",\n          value: [v1, v2, ...]\n        }, {\n          name: \"_id\",\n          opreator: \"in\",\n          value: [\"id1\"]\n        }, {\n          ....\n        }],\n        orders: [{\n          name: 'field-x',\n          type: 1 | -1\n        }],\n        search: {\n          type: 'or | and',\n          value: [value1, value2]\n        },\n        \n        startIndex: 0 (integer),\n        count: 0 (integer)\n      },\n      \n      is_collection: true | false,\n      //. case fetch document case\n      created_ids : [id1, id2, ...],\n      \n      \n      -------- additional response data -----------\n      data: [] // array\n    }\n  */\n  readDocumentList(info) {\n    if (!info) return;\n    let request_data = (0, _commonFun.getCommonParams)();\n\n    if (!info.collection || !info.operator) {\n      return;\n    }\n\n    request_data = { ...request_data,\n      ...info\n    };\n    this.socket.send('readDocumentList', request_data);\n  },\n\n  /*\n  CoCreate.crud.createDocument({\n    namespace:'',\n    room:'',\n    broadcast: true/false, (default=ture)\n    broadcast_sender: true/false, (default=true) \n    \n    collection: \"test123\",\n    data:{\n    \tname1:“hello”,\n    \tname2:  “hello1”\n    },\n    element: “xxxx”,\n    metaData: \"xxxx\"\n  }),\n  */\n  // data param needs organization_id field added to pass security check\n  createDocument: function (info) {\n    if (info === null) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'] || 'module_activities';\n    let data = info.data || {};\n\n    if (!data['organization_id']) {\n      data['organization_id'] = config.organization_Id;\n    }\n\n    if (info['data']) {\n      data = { ...data,\n        ...info['data']\n      };\n    } //. rebuild data\n\n\n    request_data['data'] = data;\n\n    if (info['metadata']) {\n      request_data['metadata'] = info['metadata'];\n    }\n\n    request_data['element'] = info['element'];\n    /** socket parameters **/\n    // if (info['broadcast'] === undefined) {\n    //   request_data['broadcast'] = true;\n    // }\n    // if (info['broadcast_sender'] === undefined) {\n    //   request_data['broadcast_sender'] = true;\n    // }\n\n    const room = (0, _commonFun.generateSocketClient)(info.namespace, info.room);\n    this.socket.send('createDocument', request_data, room);\n  },\n\n  /*\n  CoCreate.crud.updateDocument({\n    namespace: '',\n    room: '',\n    broadcast: true/false,\n    broadcast_sender: true/false,\n    \n    collection: \"test123\",\n    document_id: \"document_id\",\n    data:{\n    \tname1:“hello”,\n    \tname2:  “hello1”\n    },\n    delete_fields:[\"name3\", \"name4\"],\n    element: “xxxx”,\n    metaData: \"xxxx\"\n  }),\n  */\n  updateDocument: function (info) {\n    if (!info || !info['document_id']) return;\n    let request_data = (0, _commonFun.getCommonParamsExtend)(info);\n    request_data['collection'] = info['collection'] || 'module_activities';\n    request_data['document_id'] = info['document_id'];\n\n    if (typeof info['data'] === 'object') {\n      request_data['set'] = info['data'];\n    }\n\n    if (Array.isArray(info['delete_fields'])) request_data['unset'] = info['delete_fields'];\n    if (!request_data['set'] && !request_data['unset']) return;\n    request_data['element'] = info['element'];\n    request_data['metadata'] = info['metadata'];\n\n    if (info.upsert) {\n      request_data['upsert'] = true;\n    }\n\n    if (info.broadcast === false) {\n      request_data['broadcast'] = false;\n    }\n    /** socket parameters **/\n    // if (info['broadcast'] === undefined) {\n    //   request_data['broadcast'] = true;\n    // }\n\n\n    request_data['broadcast_sender'] = info.broadcast_sender;\n\n    if (info['broadcast_sender'] === undefined) {\n      request_data['broadcast_sender'] = true;\n    }\n\n    const room = (0, _commonFun.generateSocketClient)(info.namespace, info.room);\n    this.socket.send('updateDocument', request_data, room);\n  },\n\n  /*\n  CoCreate.crud.readDocument({\n    collection: \"test123\",\n    document_id: \"document_id\",\n    element: “xxxx”,\n    metaData: \"xxxx\",\n    exclude_fields: [] \n  }),\n  */\n  readDocument: function (info) {\n    if (info === null) {\n      return;\n    }\n\n    if (!info['document_id'] || !info) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'];\n    request_data['document_id'] = info['document_id'];\n\n    if (info['exclude_fields']) {\n      request_data['exclude_fields'] = info['exclude_fields'];\n    }\n\n    if (info['element']) {\n      request_data['element'] = info['element'];\n    }\n\n    request_data['metadata'] = info['metadata'];\n    this.socket.send('readDocument', request_data);\n  },\n\n  /*\n  CoCreate.crud.deleteDocument({\n    namespace: '',\n    room: '',\n    broadcast: true/false,\n    broadcast_sender: true/false,\n    \n    collection: \"module\",\n    document_id: \"\",\n    element: “xxxx”,\n    metadata: \"xxxx\"\n  }),\n  */\n  deleteDocument: function (info) {\n    if (!info['document_id'] || !info) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'];\n    request_data['document_id'] = info['document_id'];\n\n    if (info['element']) {\n      request_data['element'] = info['element'];\n    }\n\n    request_data['metadata'] = info['metadata'];\n    /** socket parameters **/\n    // if (info['broadcast'] === undefined) {\n    //   request_data['broadcast'] = true;\n    // }\n    // if (info['broadcast_sender'] === undefined) {\n    //   request_data['broadcast_sender'] = true;\n    // }\n\n    const room = (0, _commonFun.generateSocketClient)(info.namespace, info.room);\n    this.socket.send('deleteDocument', request_data, room);\n  },\n\n  /** export / import db functions **/\n\n  /*\n  readDocument({\n   collection: \"test123\",\n   element: “xxxx”,\n   metaData: \"xxxx\",\n  }),\n  */\n  exportCollection: function (info) {\n    if (info === null) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'];\n    request_data['export_type'] = info['export_type'];\n    request_data['metadata'] = info['metadata'];\n    this.socket.send('exportDB', request_data);\n  },\n\n  /*\n  readDocument({\n    collection: \"test123\",\n    file: file\n  }),\n  */\n  importCollection: function (info) {\n    const {\n      file\n    } = info;\n\n    if (info === null || !(file instanceof File)) {\n      return;\n    }\n\n    const extension = file.name.split(\".\").pop();\n\n    if (!['json', 'csv'].some(item => item === extension)) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'];\n    request_data['import_type'] = extension;\n    this.socket.send('importDB', request_data);\n    this.socket.sendFile(file);\n  },\n  //. message listener\n  listenMessage: function (message, fun) {\n    this.socket.listen(message, fun);\n  },\n  listenerReadDocument: function (fun) {\n    this.socket.listen(\"readDocument\", fun);\n  },\n  listenerCreateDocument: function (fun) {\n    this.socket.listen(\"createDocument\", fun);\n  },\n  listenerDeleteDocument: function (fun) {\n    this.socket.listen(\"deleteDocument\", fun);\n  },\n  listenerUpdateDocument: function (fun) {\n    this.socket.listen(\"updateDocument\", fun);\n  },\n  listenerReadDocumentList: function (fun) {\n    this.socket.listen(\"readDocumentList\", fun);\n  }\n};\n\nfunction CRUD(socket) {\n  CoCreateCRUD.setSocket(socket);\n  return CoCreateCRUD;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlSlMvc3JjL2NydWQuanM/ODIxOSJdLCJuYW1lcyI6WyJkYXRhIiwib2JqIiwidGVzdCIsImNvbnNvbGUiLCJsb2ciLCJ1dGlsc0NydWQiLCJkZWNvZGVPYmplY3QiLCJlbmNvZGVPYmplY3QiLCJDb0NyZWF0ZUNSVUQiLCJzb2NrZXQiLCJzZXRTb2NrZXQiLCJyZWFkRG9jdW1lbnRMaXN0IiwiaW5mbyIsInJlcXVlc3RfZGF0YSIsImNvbGxlY3Rpb24iLCJvcGVyYXRvciIsInNlbmQiLCJjcmVhdGVEb2N1bWVudCIsImNvbmZpZyIsIm9yZ2FuaXphdGlvbl9JZCIsInJvb20iLCJuYW1lc3BhY2UiLCJ1cGRhdGVEb2N1bWVudCIsIkFycmF5IiwiaXNBcnJheSIsInVwc2VydCIsImJyb2FkY2FzdCIsImJyb2FkY2FzdF9zZW5kZXIiLCJ1bmRlZmluZWQiLCJyZWFkRG9jdW1lbnQiLCJkZWxldGVEb2N1bWVudCIsImV4cG9ydENvbGxlY3Rpb24iLCJpbXBvcnRDb2xsZWN0aW9uIiwiZmlsZSIsIkZpbGUiLCJleHRlbnNpb24iLCJuYW1lIiwic3BsaXQiLCJwb3AiLCJzb21lIiwiaXRlbSIsInNlbmRGaWxlIiwibGlzdGVuTWVzc2FnZSIsIm1lc3NhZ2UiLCJmdW4iLCJsaXN0ZW4iLCJsaXN0ZW5lclJlYWREb2N1bWVudCIsImxpc3RlbmVyQ3JlYXRlRG9jdW1lbnQiLCJsaXN0ZW5lckRlbGV0ZURvY3VtZW50IiwibGlzdGVuZXJVcGRhdGVEb2N1bWVudCIsImxpc3RlbmVyUmVhZERvY3VtZW50TGlzdCIsIkNSVUQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQTs7QUFDQTs7OztBQUhBO0FBS0EsSUFBSUEsSUFBSSxHQUFHO0FBQ1QsWUFBVSxLQUREO0FBRVQsbUJBQWlCLEtBRlI7QUFHVCx3QkFBc0IsS0FIYjtBQUlULHVCQUFxQixJQUpaO0FBS1QsNEJBQTBCLE9BTGpCO0FBTVQs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KioqKioqKiAgIGRlZmluZSB2YXJpYWJsZXMgZW5kICoqKioqKioqKioqKioqKioqIC8vLyBcblxuaW1wb3J0IHtnZXRDb21tb25QYXJhbXMsIGdldENvbW1vblBhcmFtc0V4dGVuZCwgZ2VuZXJhdGVTb2NrZXRDbGllbnR9IGZyb20gXCIuL2NvbW1vbi1mdW4uanNcIlxuaW1wb3J0IHV0aWxzQ3J1ZCBmcm9tIFwiLi91dGlscy5jcnVkLmpzXCJcblxudmFyIGRhdGEgPSB7XG4gIFwib3JnX2lkXCI6IFwieHh4XCIsXG4gIFwiY3VzdG9tZXIubmFtZVwiOiBcIkppblwiLFxuICBcImN1c3RvbWVyLmZyaXN0bmFtZVwiOiBcIkppblwiLFxuICBcImN1c3RvbWVyLmxhc3RuYW1lXCI6IFwiQ0ZcIixcbiAgXCJjdXN0b21lci5hZGRyZXNzLmxpbmUxXCI6IFwibGluZTFcIixcbiAgXCJjdXN0b21lci5hZGRyZXNzLmxpbmUyXCI6IFwibGluZTJcIixcbiAgJ3Njb3BlWzBdJzogJ3Rlc3RpbmcnLFxuICAnc2NvcGVbMV0nOiAnLS0tJyxcbiAgXCJjdXN0b21lci5vcmRlcnNbMF1cIjogMTIzLFxuICBcImN1c3RvbWVyLm9yZGVyc1sxXVwiOiAyNDMsXG59XG5cbnZhciBvYmogPSB7XG4gIHRlc3Q6IHtcbiAgICBcIm5hbWVcIjogJzEyMycsXG4gICAgXCJhZGRyZXNzXCI6ICdhZGRyZXNzJyxcbiAgICBcImN1c3RvbWVyXCI6IHtcbiAgICAgIFwibmFtZVwiOiAndHR0dCdcbiAgICB9LFxuICAgIFwib3JkZXJzXCI6IFsxLDIsM11cbiAgfVxufVxuY29uc29sZS5sb2coJy0tLS0tIGNvbnZlcnQgb2JqZWN0IC0tLS0tJylcbmNvbnNvbGUubG9nKHV0aWxzQ3J1ZC5kZWNvZGVPYmplY3QoZGF0YSkpO1xuY29uc29sZS5sb2codXRpbHNDcnVkLmVuY29kZU9iamVjdChvYmopKTtcblxuY29uc3QgQ29DcmVhdGVDUlVEID0ge1xuICBzb2NrZXQ6IG51bGwsXG4gIHNldFNvY2tldDogZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gIH0sXG4gIC8qXG4gICBcbiAgICBDb0NyZWF0ZS5jcnVkLnJlYWREY291bWVudExpc3Qge1xuICAgICAgY29sbGVjdGlvbjogXCJtb2R1bGVzXCIsXG4gICAgICBlbGVtZW50OiBcInh4eHhcIixcbiAgICAgIG1ldGFkYXRhOiBcIlwiLFxuICAgICAgb3BlcmF0b3I6IHtcbiAgICAgICAgZmV0Y2g6IHtcbiAgICAgICAgICBuYW1lOiAneHh4eCcsXG4gICAgICAgICAgdmFsdWU6ICd4eHh4eCdcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyczogW3tcbiAgICAgICAgICBuYW1lOiAnZmllbGQxJyxcbiAgICAgICAgICBvcGVyYXRvcjogXCJjb250YWluIHwgcmFuZ2UgfCBlcSB8IG5lIHwgbHQgfCBsdGUgfCBndCB8IGd0ZSB8IGluIHwgbmluXCIsXG4gICAgICAgICAgdmFsdWU6IFt2MSwgdjIsIC4uLl1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiX2lkXCIsXG4gICAgICAgICAgb3ByZWF0b3I6IFwiaW5cIixcbiAgICAgICAgICB2YWx1ZTogW1wiaWQxXCJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAuLi4uXG4gICAgICAgIH1dLFxuICAgICAgICBvcmRlcnM6IFt7XG4gICAgICAgICAgbmFtZTogJ2ZpZWxkLXgnLFxuICAgICAgICAgIHR5cGU6IDEgfCAtMVxuICAgICAgICB9XSxcbiAgICAgICAgc2VhcmNoOiB7XG4gICAgICAgICAgdHlwZTogJ29yIHwgYW5kJyxcbiAgICAgICAgICB2YWx1ZTogW3ZhbHVlMSwgdmFsdWUyXVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgc3RhcnRJbmRleDogMCAoaW50ZWdlciksXG4gICAgICAgIGNvdW50OiAwIChpbnRlZ2VyKVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgaXNfY29sbGVjdGlvbjogdHJ1ZSB8IGZhbHNlLFxuICAgICAgLy8uIGNhc2UgZmV0Y2ggZG9jdW1lbnQgY2FzZVxuICAgICAgY3JlYXRlZF9pZHMgOiBbaWQxLCBpZDIsIC4uLl0sXG4gICAgICBcbiAgICAgIFxuICAgICAgLS0tLS0tLS0gYWRkaXRpb25hbCByZXNwb25zZSBkYXRhIC0tLS0tLS0tLS0tXG4gICAgICBkYXRhOiBbXSAvLyBhcnJheVxuICAgIH1cbiAgKi9cbiAgXG4gIHJlYWREb2N1bWVudExpc3QoaW5mbyl7XG4gICAgaWYoICFpbmZvICkgcmV0dXJuO1xuICAgIGxldCByZXF1ZXN0X2RhdGEgPSBnZXRDb21tb25QYXJhbXMoKTtcbiAgICBcbiAgICBpZiAoIWluZm8uY29sbGVjdGlvbiB8fCAhaW5mby5vcGVyYXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICByZXF1ZXN0X2RhdGEgPSB7Li4ucmVxdWVzdF9kYXRhLCAuLi5pbmZvfTtcbiAgICBcbiAgICB0aGlzLnNvY2tldC5zZW5kKCdyZWFkRG9jdW1lbnRMaXN0JywgcmVxdWVzdF9kYXRhKTtcbiAgfSxcbiAgXG4gIFxuICAvKlxuICBDb0NyZWF0ZS5jcnVkLmNyZWF0ZURvY3VtZW50KHtcbiAgICBuYW1lc3BhY2U6JycsXG4gICAgcm9vbTonJyxcbiAgICBicm9hZGNhc3Q6IHRydWUvZmFsc2UsIChkZWZhdWx0PXR1cmUpXG4gICAgYnJvYWRjYXN0X3NlbmRlcjogdHJ1ZS9mYWxzZSwgKGRlZmF1bHQ9dHJ1ZSkgXG4gICAgXG4gICAgY29sbGVjdGlvbjogXCJ0ZXN0MTIzXCIsXG4gICAgZGF0YTp7XG4gICAgXHRuYW1lMTrigJxoZWxsb+KAnSxcbiAgICBcdG5hbWUyOiAg4oCcaGVsbG8x4oCdXG4gICAgfSxcbiAgICBlbGVtZW50OiDigJx4eHh44oCdLFxuICAgIG1ldGFEYXRhOiBcInh4eHhcIlxuICB9KSxcbiAgKi9cbiAgLy8gZGF0YSBwYXJhbSBuZWVkcyBvcmdhbml6YXRpb25faWQgZmllbGQgYWRkZWQgdG8gcGFzcyBzZWN1cml0eSBjaGVja1xuICBjcmVhdGVEb2N1bWVudDogZnVuY3Rpb24oaW5mbykge1xuICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZXF1ZXN0X2RhdGEgPSBnZXRDb21tb25QYXJhbXMoKVxuICAgIHJlcXVlc3RfZGF0YVsnY29sbGVjdGlvbiddID0gaW5mb1snY29sbGVjdGlvbiddIHx8ICdtb2R1bGVfYWN0aXZpdGllcyc7XG4gICAgXG4gICAgbGV0IGRhdGEgPSBpbmZvLmRhdGEgfHwge307XG4gICAgXG4gICAgaWYgKCFkYXRhWydvcmdhbml6YXRpb25faWQnXSkge1xuICAgICAgZGF0YVsnb3JnYW5pemF0aW9uX2lkJ10gPSBjb25maWcub3JnYW5pemF0aW9uX0lkXG4gICAgfVxuICAgIGlmIChpbmZvWydkYXRhJ10pIHtcbiAgICAgIGRhdGEgPSB7Li4uZGF0YSwgLi4uaW5mb1snZGF0YSddfVxuICAgIH1cbiAgICBcbiAgICAvLy4gcmVidWlsZCBkYXRhXG4gICAgXG4gICAgcmVxdWVzdF9kYXRhWydkYXRhJ10gPSBkYXRhO1xuICAgIGlmIChpbmZvWydtZXRhZGF0YSddKSB7XG4gICAgICByZXF1ZXN0X2RhdGFbJ21ldGFkYXRhJ10gPSBpbmZvWydtZXRhZGF0YSddXG4gICAgfVxuICAgIFxuICAgIHJlcXVlc3RfZGF0YVsnZWxlbWVudCddID0gaW5mb1snZWxlbWVudCddO1xuICAgIFxuICAgIC8qKiBzb2NrZXQgcGFyYW1ldGVycyAqKi9cbiAgICAvLyBpZiAoaW5mb1snYnJvYWRjYXN0J10gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3QnXSA9IHRydWU7XG4gICAgLy8gfVxuICAgIC8vIGlmIChpbmZvWydicm9hZGNhc3Rfc2VuZGVyJ10gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3Rfc2VuZGVyJ10gPSB0cnVlO1xuICAgIC8vIH1cbiAgICBcbiAgICBjb25zdCByb29tID0gZ2VuZXJhdGVTb2NrZXRDbGllbnQoaW5mby5uYW1lc3BhY2UsIGluZm8ucm9vbSk7XG4gICAgdGhpcy5zb2NrZXQuc2VuZCgnY3JlYXRlRG9jdW1lbnQnLCByZXF1ZXN0X2RhdGEsIHJvb20pO1xuICB9LFxuICBcblxuICBcblxuICAvKlxuICBDb0NyZWF0ZS5jcnVkLnVwZGF0ZURvY3VtZW50KHtcbiAgICBuYW1lc3BhY2U6ICcnLFxuICAgIHJvb206ICcnLFxuICAgIGJyb2FkY2FzdDogdHJ1ZS9mYWxzZSxcbiAgICBicm9hZGNhc3Rfc2VuZGVyOiB0cnVlL2ZhbHNlLFxuICAgIFxuICAgIGNvbGxlY3Rpb246IFwidGVzdDEyM1wiLFxuICAgIGRvY3VtZW50X2lkOiBcImRvY3VtZW50X2lkXCIsXG4gICAgZGF0YTp7XG4gICAgXHRuYW1lMTrigJxoZWxsb+KAnSxcbiAgICBcdG5hbWUyOiAg4oCcaGVsbG8x4oCdXG4gICAgfSxcbiAgICBkZWxldGVfZmllbGRzOltcIm5hbWUzXCIsIFwibmFtZTRcIl0sXG4gICAgZWxlbWVudDog4oCceHh4eOKAnSxcbiAgICBtZXRhRGF0YTogXCJ4eHh4XCJcbiAgfSksXG4gICovXG4gIHVwZGF0ZURvY3VtZW50OiBmdW5jdGlvbihpbmZvKSB7XG4gICAgaWYoICFpbmZvIHx8ICFpbmZvWydkb2N1bWVudF9pZCddICkgcmV0dXJuO1xuICAgIFxuICAgIGxldCByZXF1ZXN0X2RhdGEgPSBnZXRDb21tb25QYXJhbXNFeHRlbmQoaW5mbyk7XG4gICAgXG4gICAgcmVxdWVzdF9kYXRhWydjb2xsZWN0aW9uJ10gPSBpbmZvWydjb2xsZWN0aW9uJ10gfHwgJ21vZHVsZV9hY3Rpdml0aWVzJztcbiAgICByZXF1ZXN0X2RhdGFbJ2RvY3VtZW50X2lkJ10gPSBpbmZvWydkb2N1bWVudF9pZCddO1xuICAgIFxuICAgIGlmKCB0eXBlb2YgaW5mb1snZGF0YSddID09PSAnb2JqZWN0JyApIHtcbiAgICAgIHJlcXVlc3RfZGF0YVsnc2V0J10gPSBpbmZvWydkYXRhJ11cbiAgICB9XG4gICAgaWYoIEFycmF5LmlzQXJyYXkoaW5mb1snZGVsZXRlX2ZpZWxkcyddKSApIHJlcXVlc3RfZGF0YVsndW5zZXQnXSA9IGluZm9bJ2RlbGV0ZV9maWVsZHMnXTtcbiAgICBcbiAgICBpZighcmVxdWVzdF9kYXRhWydzZXQnXSAmJiAhcmVxdWVzdF9kYXRhWyd1bnNldCddKSByZXR1cm47XG4gICAgXG4gICAgcmVxdWVzdF9kYXRhWydlbGVtZW50J10gPSBpbmZvWydlbGVtZW50J107XG4gICAgcmVxdWVzdF9kYXRhWydtZXRhZGF0YSddID0gaW5mb1snbWV0YWRhdGEnXTtcbiAgICBcbiAgICBpZiAoaW5mby51cHNlcnQpIHtcbiAgICAgIHJlcXVlc3RfZGF0YVsndXBzZXJ0J10gPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaW5mby5icm9hZGNhc3QgPT09IGZhbHNlKSB7XG4gICAgICByZXF1ZXN0X2RhdGFbJ2Jyb2FkY2FzdCddID0gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8qKiBzb2NrZXQgcGFyYW1ldGVycyAqKi9cbiAgICAvLyBpZiAoaW5mb1snYnJvYWRjYXN0J10gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3QnXSA9IHRydWU7XG4gICAgLy8gfVxuICAgIHJlcXVlc3RfZGF0YVsnYnJvYWRjYXN0X3NlbmRlciddID0gaW5mby5icm9hZGNhc3Rfc2VuZGVyO1xuICAgIGlmIChpbmZvWydicm9hZGNhc3Rfc2VuZGVyJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3Rfc2VuZGVyJ10gPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByb29tID0gZ2VuZXJhdGVTb2NrZXRDbGllbnQoaW5mby5uYW1lc3BhY2UsIGluZm8ucm9vbSk7XG4gICAgdGhpcy5zb2NrZXQuc2VuZCgndXBkYXRlRG9jdW1lbnQnLCByZXF1ZXN0X2RhdGEsIHJvb20pO1xuICB9LFxuICBcbiAgXG4gIC8qXG4gIENvQ3JlYXRlLmNydWQucmVhZERvY3VtZW50KHtcbiAgICBjb2xsZWN0aW9uOiBcInRlc3QxMjNcIixcbiAgICBkb2N1bWVudF9pZDogXCJkb2N1bWVudF9pZFwiLFxuICAgIGVsZW1lbnQ6IOKAnHh4eHjigJ0sXG4gICAgbWV0YURhdGE6IFwieHh4eFwiLFxuICAgIGV4Y2x1ZGVfZmllbGRzOiBbXSBcbiAgfSksXG4gICovXG4gIHJlYWREb2N1bWVudDogZnVuY3Rpb24oaW5mbykge1xuICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaW5mb1snZG9jdW1lbnRfaWQnXSB8fCAhaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBsZXQgcmVxdWVzdF9kYXRhID0gZ2V0Q29tbW9uUGFyYW1zKCk7XG4gICAgcmVxdWVzdF9kYXRhWydjb2xsZWN0aW9uJ10gPSBpbmZvWydjb2xsZWN0aW9uJ107XG4gICAgcmVxdWVzdF9kYXRhWydkb2N1bWVudF9pZCddID0gaW5mb1snZG9jdW1lbnRfaWQnXTtcbiAgICBpZiAoaW5mb1snZXhjbHVkZV9maWVsZHMnXSkge1xuICAgICAgcmVxdWVzdF9kYXRhWydleGNsdWRlX2ZpZWxkcyddID0gaW5mb1snZXhjbHVkZV9maWVsZHMnXTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGluZm9bJ2VsZW1lbnQnXSkge1xuICAgICAgcmVxdWVzdF9kYXRhWydlbGVtZW50J10gPSBpbmZvWydlbGVtZW50J107XG4gICAgfVxuICAgIFxuICAgIHJlcXVlc3RfZGF0YVsnbWV0YWRhdGEnXSA9IGluZm9bJ21ldGFkYXRhJ11cbiAgICB0aGlzLnNvY2tldC5zZW5kKCdyZWFkRG9jdW1lbnQnLCByZXF1ZXN0X2RhdGEpO1xuICB9LFxuICBcbiAgXG4gIC8qXG4gIENvQ3JlYXRlLmNydWQuZGVsZXRlRG9jdW1lbnQoe1xuICAgIG5hbWVzcGFjZTogJycsXG4gICAgcm9vbTogJycsXG4gICAgYnJvYWRjYXN0OiB0cnVlL2ZhbHNlLFxuICAgIGJyb2FkY2FzdF9zZW5kZXI6IHRydWUvZmFsc2UsXG4gICAgXG4gICAgY29sbGVjdGlvbjogXCJtb2R1bGVcIixcbiAgICBkb2N1bWVudF9pZDogXCJcIixcbiAgICBlbGVtZW50OiDigJx4eHh44oCdLFxuICAgIG1ldGFkYXRhOiBcInh4eHhcIlxuICB9KSxcbiAgKi9cbiAgZGVsZXRlRG9jdW1lbnQ6IGZ1bmN0aW9uKGluZm8pIHtcbiAgICBpZiAoIWluZm9bJ2RvY3VtZW50X2lkJ10gfHwgIWluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgbGV0IHJlcXVlc3RfZGF0YSA9IGdldENvbW1vblBhcmFtcygpO1xuICAgIHJlcXVlc3RfZGF0YVsnY29sbGVjdGlvbiddID0gaW5mb1snY29sbGVjdGlvbiddO1xuICAgIHJlcXVlc3RfZGF0YVsnZG9jdW1lbnRfaWQnXSA9IGluZm9bJ2RvY3VtZW50X2lkJ107XG4gICAgXG4gICAgaWYgKGluZm9bJ2VsZW1lbnQnXSkge1xuICAgICAgcmVxdWVzdF9kYXRhWydlbGVtZW50J10gPSBpbmZvWydlbGVtZW50J107XG4gICAgfVxuICAgIFxuICAgIHJlcXVlc3RfZGF0YVsnbWV0YWRhdGEnXSA9IGluZm9bJ21ldGFkYXRhJ11cbiAgICBcbiAgICAvKiogc29ja2V0IHBhcmFtZXRlcnMgKiovXG4gICAgLy8gaWYgKGluZm9bJ2Jyb2FkY2FzdCddID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyAgIHJlcXVlc3RfZGF0YVsnYnJvYWRjYXN0J10gPSB0cnVlO1xuICAgIC8vIH1cbiAgICAvLyBpZiAoaW5mb1snYnJvYWRjYXN0X3NlbmRlciddID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyAgIHJlcXVlc3RfZGF0YVsnYnJvYWRjYXN0X3NlbmRlciddID0gdHJ1ZTtcbiAgICAvLyB9XG4gICAgXG4gICAgY29uc3Qgcm9vbSA9IGdlbmVyYXRlU29ja2V0Q2xpZW50KGluZm8ubmFtZXNwYWNlLCBpbmZvLnJvb20pO1xuICAgIHRoaXMuc29ja2V0LnNlbmQoJ2RlbGV0ZURvY3VtZW50JywgcmVxdWVzdF9kYXRhLCByb29tKTtcbiAgfSxcblxuXG4gLyoqIGV4cG9ydCAvIGltcG9ydCBkYiBmdW5jdGlvbnMgKiovXG4gXG4gICAvKlxuICByZWFkRG9jdW1lbnQoe1xuICAgIGNvbGxlY3Rpb246IFwidGVzdDEyM1wiLFxuICAgIGVsZW1lbnQ6IOKAnHh4eHjigJ0sXG4gICAgbWV0YURhdGE6IFwieHh4eFwiLFxuICB9KSxcbiAgKi9cbiAgZXhwb3J0Q29sbGVjdGlvbjogZnVuY3Rpb24oaW5mbykge1xuICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3RfZGF0YSA9IGdldENvbW1vblBhcmFtcygpO1xuICAgIHJlcXVlc3RfZGF0YVsnY29sbGVjdGlvbiddID0gaW5mb1snY29sbGVjdGlvbiddO1xuICAgIHJlcXVlc3RfZGF0YVsnZXhwb3J0X3R5cGUnXSA9IGluZm9bJ2V4cG9ydF90eXBlJ107XG5cbiAgICByZXF1ZXN0X2RhdGFbJ21ldGFkYXRhJ10gPSBpbmZvWydtZXRhZGF0YSddXG4gICAgdGhpcy5zb2NrZXQuc2VuZCgnZXhwb3J0REInLCByZXF1ZXN0X2RhdGEpO1xuICB9LFxuICBcbiAgLypcbiAgcmVhZERvY3VtZW50KHtcbiAgICBjb2xsZWN0aW9uOiBcInRlc3QxMjNcIixcbiAgICBmaWxlOiBmaWxlXG4gIH0pLFxuICAqL1xuICBpbXBvcnRDb2xsZWN0aW9uOiBmdW5jdGlvbihpbmZvKSB7XG4gICAgY29uc3Qge2ZpbGV9ID0gaW5mbztcbiAgICBpZiAoaW5mbyA9PT0gbnVsbCB8fCAhKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGZpbGUubmFtZS5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgXG4gICAgaWYgKCFbJ2pzb24nLCdjc3YnXS5zb21lKChpdGVtKSA9PiBpdGVtID09PSBleHRlbnNpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGxldCByZXF1ZXN0X2RhdGEgPSBnZXRDb21tb25QYXJhbXMoKVxuICAgIHJlcXVlc3RfZGF0YVsnY29sbGVjdGlvbiddID0gaW5mb1snY29sbGVjdGlvbiddXG4gICAgcmVxdWVzdF9kYXRhWydpbXBvcnRfdHlwZSddID0gZXh0ZW5zaW9uO1xuICAgIHRoaXMuc29ja2V0LnNlbmQoJ2ltcG9ydERCJywgcmVxdWVzdF9kYXRhKVxuICAgIHRoaXMuc29ja2V0LnNlbmRGaWxlKGZpbGUpO1xuICB9LFxuICBcbiAgXG4gIC8vLiBtZXNzYWdlIGxpc3RlbmVyXG4gIGxpc3Rlbk1lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UsIGZ1bikge1xuICAgIHRoaXMuc29ja2V0Lmxpc3RlbihtZXNzYWdlLCBmdW4pO1xuICB9LFxuICBcbiAgbGlzdGVuZXJSZWFkRG9jdW1lbnQ6IGZ1bmN0aW9uKGZ1bikge1xuICAgIHRoaXMuc29ja2V0Lmxpc3RlbihcInJlYWREb2N1bWVudFwiLCBmdW4pO1xuICB9LFxuICBsaXN0ZW5lckNyZWF0ZURvY3VtZW50OiBmdW5jdGlvbihmdW4pIHtcbiAgICB0aGlzLnNvY2tldC5saXN0ZW4oXCJjcmVhdGVEb2N1bWVudFwiLCBmdW4pO1xuICB9LFxuICBsaXN0ZW5lckRlbGV0ZURvY3VtZW50OiBmdW5jdGlvbihmdW4pIHtcbiAgICB0aGlzLnNvY2tldC5saXN0ZW4oXCJkZWxldGVEb2N1bWVudFwiLCBmdW4pO1xuICB9LFxuICBsaXN0ZW5lclVwZGF0ZURvY3VtZW50OiBmdW5jdGlvbihmdW4pIHtcbiAgICB0aGlzLnNvY2tldC5saXN0ZW4oXCJ1cGRhdGVEb2N1bWVudFwiLCBmdW4pO1xuICB9LFxuICBsaXN0ZW5lclJlYWREb2N1bWVudExpc3Q6IGZ1bmN0aW9uKGZ1bikge1xuICAgIHRoaXMuc29ja2V0Lmxpc3RlbihcInJlYWREb2N1bWVudExpc3RcIiwgZnVuKTtcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1JVRChzb2NrZXQpIHtcbiAgQ29DcmVhdGVDUlVELnNldFNvY2tldChzb2NrZXQpO1xuICByZXR1cm4gQ29DcmVhdGVDUlVEO1xufVxuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/crud.js\n")},"../../CoCreateJS/src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.addComponent = addComponent;\nexports.removeComponent = removeComponent;\nexports.utils = exports.message = exports.crud = exports.socketApi = exports.socket = exports.core = void 0;\n\nvar _socket = _interopRequireDefault(__webpack_require__(/*! ./socket.js */ "../../CoCreateJS/src/socket.js"));\n\nvar _crud = _interopRequireDefault(__webpack_require__(/*! ./crud.js */ "../../CoCreateJS/src/crud.js"));\n\nvar _core = _interopRequireDefault(__webpack_require__(/*! ./core.js */ "../../CoCreateJS/src/core.js"));\n\nvar utils = _interopRequireWildcard(__webpack_require__(/*! ./utils.js */ "../../CoCreateJS/src/utils.js"));\n\nexports.utils = utils;\n\nvar _message = _interopRequireDefault(__webpack_require__(/*! ./message.js */ "../../CoCreateJS/src/message.js"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*global window*/\n// import CRDT from "./crdt.js"\nlet socket = new _socket.default(\'ws\');\nexports.socket = socket;\nlet socketApi = new _socket.default(\'api\');\nexports.socketApi = socketApi;\nlet core = (0, _core.default)(socket);\nexports.core = core;\nlet crud = (0, _crud.default)(socket);\nexports.crud = crud;\nlet message = (0, _message.default)(socket);\nexports.message = message;\ncore.init(window.config.host ? window.config.host : \'server.cocreate.app\');\n\nfunction addComponent(key, component) {\n  this[key] = component;\n}\n\nfunction removeComponent(key) {\n  if (this[key]) {}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlSlMvc3JjL2luZGV4LmpzPzI4OWEiXSwibmFtZXMiOlsic29ja2V0IiwiQ29DcmVhdGVTb2NrZXQiLCJzb2NrZXRBcGkiLCJjb3JlIiwiY3J1ZCIsIm1lc3NhZ2UiLCJpbml0Iiwid2luZG93IiwiY29uZmlnIiwiaG9zdCIsImFkZENvbXBvbmVudCIsImtleSIsImNvbXBvbmVudCIsInJlbW92ZUNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFMQTtBQU9BO0FBQ0EsSUFBSUEsTUFBTSxHQUFHLElBQUlDLGVBQUosQ0FBbUIsSUFBbkIsQ0FBYjs7QUFDQSxJQUFJQyxTQUFTLEdBQUcsSUFBSUQsZUFBSixDQUFtQixLQUFuQixDQUFoQjs7QUFFQSxJQUFJRSxJQUFJLEdBQUcsbUJBQUtILE1BQUwsQ0FBWDs7QUFDQSxJQUFJSSxJQUFJLEdBQUcsbUJBQUtKLE1BQUwsQ0FBWDs7QUFDQSxJQUFJSyxPQUFPLEdBQUcsc0JBQVFMLE1BQVIsQ0FBZDs7QUFFQUcsSUFBSSxDQUFDRyxJQUFMLENBQVVDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjQyxJQUFkLEdBQXFCRixNQUFNLENBQUNDLE1BQVAsQ0FBY0MsSUFBbkMsR0FBMEMscUJBQXBEOztBQUVBLFNBQVNDLFlBQVQsQ0FBc0JDLEdBQXRCLEVBQTJCQyxTQUEzQixFQUFzQztBQUNsQyxPQUFLRCxHQUFMLElBQVlDLFNBQVo7QUFDSDs7QUFFRCxTQUFTQyxlQUFULENBQXlCRixHQUF6QixFQUE4QjtBQUMxQixNQUFJLEtBQUtBLEdBQUwsQ0FBSixFQUFlLENBRWQ7QUFDSiIsImZpbGUiOiIuLi8uLi9Db0NyZWF0ZUpTL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIHdpbmRvdyovXG5pbXBvcnQgQ29DcmVhdGVTb2NrZXQgZnJvbSBcIi4vc29ja2V0LmpzXCJcbmltcG9ydCBDUlVEIGZyb20gXCIuL2NydWQuanNcIlxuaW1wb3J0IENvcmUgZnJvbSBcIi4vY29yZS5qc1wiXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi91dGlscy5qc1wiXG5pbXBvcnQgTWVzc2FnZSBmcm9tIFwiLi9tZXNzYWdlLmpzXCJcblxuLy8gaW1wb3J0IENSRFQgZnJvbSBcIi4vY3JkdC5qc1wiXG5sZXQgc29ja2V0ID0gbmV3IENvQ3JlYXRlU29ja2V0KCd3cycpO1xubGV0IHNvY2tldEFwaSA9IG5ldyBDb0NyZWF0ZVNvY2tldCgnYXBpJyk7XG5cbmxldCBjb3JlID0gQ29yZShzb2NrZXQpXG5sZXQgY3J1ZCA9IENSVUQoc29ja2V0KVxubGV0IG1lc3NhZ2UgPSBNZXNzYWdlKHNvY2tldClcblxuY29yZS5pbml0KHdpbmRvdy5jb25maWcuaG9zdCA/IHdpbmRvdy5jb25maWcuaG9zdCA6ICdzZXJ2ZXIuY29jcmVhdGUuYXBwJyk7XG5cbmZ1bmN0aW9uIGFkZENvbXBvbmVudChrZXksIGNvbXBvbmVudCkge1xuICAgIHRoaXNba2V5XSA9IGNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ29tcG9uZW50KGtleSkge1xuICAgIGlmICh0aGlzW2tleV0pIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IHtcbiAgICBjb3JlLFxuICAgIHNvY2tldCxcbiAgICBzb2NrZXRBcGksXG4gICAgY3J1ZCxcbiAgICB1dGlscyxcbiAgICBtZXNzYWdlLFxuICAgIGFkZENvbXBvbmVudCxcbiAgICByZW1vdmVDb21wb25lbnRcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/index.js\n')},"../../CoCreateJS/src/message.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = Message;\n\nvar _commonFun = __webpack_require__(/*! ./common-fun.js */ \"../../CoCreateJS/src/common-fun.js\");\n\nconst CoCreateMessage = {\n  socket: null,\n  setSocket: function (socket) {\n    this.socket = socket;\n  },\n\n  /*\n  CoCreate.message.send({\n     namespace: '',\n     room: '',\n     broadcast: true/false,\n     broadcast_sender: true/false\n     \n     rooms: [r1, r2],\n     emit: {\n       message': 'nice game',\n       data': 'let's play a game ....'\n     }\n   })\n  */\n  send: function (data) {\n    let request_data = (0, _commonFun.getCommonParams)();\n\n    if (!data || !data.emit) {\n      return;\n    }\n\n    request_data = { ...request_data,\n      ...data\n    };\n    /** socket parameters **/\n    // if (data['broadcast'] === undefined) {\n    //   request_data['broadcast'] = true;\n    // }\n    // if (data['broadcast_sender'] === undefined) {\n    //   request_data['broadcast_sender'] = true;\n    // }\n\n    const room = (0, _commonFun.generateSocketClient)(data.namespace, data.room);\n    this.socket.send('sendMessage', request_data, room);\n  },\n  receive: function (message, fun) {\n    this.socket.listen(message, fun);\n  }\n};\n\nfunction Message(socket) {\n  CoCreateMessage.setSocket(socket);\n  return CoCreateMessage;\n}\n\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlSlMvc3JjL21lc3NhZ2UuanM/Nzg0MiJdLCJuYW1lcyI6WyJDb0NyZWF0ZU1lc3NhZ2UiLCJzb2NrZXQiLCJzZXRTb2NrZXQiLCJzZW5kIiwiZGF0YSIsInJlcXVlc3RfZGF0YSIsImVtaXQiLCJyb29tIiwibmFtZXNwYWNlIiwicmVjZWl2ZSIsIm1lc3NhZ2UiLCJmdW4iLCJsaXN0ZW4iLCJNZXNzYWdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUEsTUFBTUEsZUFBZSxHQUFHO0FBQ3RCQyxRQUFNLEVBQUUsSUFEYztBQUV0QkMsV0FBUyxFQUFFLFVBQVNELE1BQVQsRUFBaUI7QUFDMUIsU0FBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0QsR0FKcUI7O0FBS3ZCO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQ0UsTUFBSSxFQUFFLFVBQVNDLElBQVQsRUFBZTtBQUNsQixRQUFJQyxZQUFZLEdBQUcsaUNBQW5COztBQUVBLFFBQUksQ0FBQ0QsSUFBRCxJQUFTLENBQUNBLElBQUksQ0FBQ0UsSUFBbkIsRUFBeUI7QUFDdkI7QUFDRDs7QUFDREQsZ0JBQVksR0FBRyxFQUFDLEdBQUdBLFlBQUo7QUFBa0IsU0FBR0Q7QUFBckIsS0FBZjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFVBQU1HLElBQUksR0FBRyxxQ0FBcUJILElBQUksQ0FBQ0ksU0FBMUIsRUFBcUNKLElBQUksQ0FBQ0csSUFBMUMsQ0FBYjtBQUVBLFNBQUtOLE1BQUwsQ0FBWUUsSUFBWixDQUFpQixhQUFqQixFQUFnQ0UsWUFBaEMsRUFBOENFLElBQTlDO0FBQ0YsR0FyQ3NCO0FBdUN2QkUsU0FBTyxFQUFFLFVBQVNDLE9BQVQsRUFBa0JDLEdBQWxCLEVBQXVCO0FBQzlCLFNBQUtWLE1BQUwsQ0FBWVcsTUFBWixDQUFtQkYsT0FBbkIsRUFBNEJDLEdBQTVCO0FBQ0Q7QUF6Q3NCLENBQXhCOztBQTRDZSxTQUFTRSxPQUFULENBQWlCWixNQUFqQixFQUF5QjtBQUN0Q0QsaUJBQWUsQ0FBQ0UsU0FBaEIsQ0FBMEJELE1BQTFCO0FBQ0EsU0FBT0QsZUFBUDtBQUNEOztBQUFBIiwiZmlsZSI6Ii4uLy4uL0NvQ3JlYXRlSlMvc3JjL21lc3NhZ2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldENvbW1vblBhcmFtcywgZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kLCBnZW5lcmF0ZVNvY2tldENsaWVudH0gZnJvbSBcIi4vY29tbW9uLWZ1bi5qc1wiXG5cbmNvbnN0IENvQ3JlYXRlTWVzc2FnZSA9IHtcbiAgc29ja2V0OiBudWxsLFxuICBzZXRTb2NrZXQ6IGZ1bmN0aW9uKHNvY2tldCkge1xuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICB9LFxuIC8qXG4gQ29DcmVhdGUubWVzc2FnZS5zZW5kKHtcbiAgICBuYW1lc3BhY2U6ICcnLFxuICAgIHJvb206ICcnLFxuICAgIGJyb2FkY2FzdDogdHJ1ZS9mYWxzZSxcbiAgICBicm9hZGNhc3Rfc2VuZGVyOiB0cnVlL2ZhbHNlXG4gICAgXG4gICAgcm9vbXM6IFtyMSwgcjJdLFxuICAgIGVtaXQ6IHtcbiAgICAgIG1lc3NhZ2UnOiAnbmljZSBnYW1lJyxcbiAgICAgIGRhdGEnOiAnbGV0J3MgcGxheSBhIGdhbWUgLi4uLidcbiAgICB9XG4gIH0pXG4gKi9cbiBzZW5kOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgbGV0IHJlcXVlc3RfZGF0YSA9IGdldENvbW1vblBhcmFtcygpO1xuICAgIFxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5lbWl0KSB7XG4gICAgICByZXR1cm47ICAgICBcbiAgICB9XG4gICAgcmVxdWVzdF9kYXRhID0gey4uLnJlcXVlc3RfZGF0YSwgLi4uZGF0YX1cbiAgICBcbiAgICAvKiogc29ja2V0IHBhcmFtZXRlcnMgKiovXG4gICAgLy8gaWYgKGRhdGFbJ2Jyb2FkY2FzdCddID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyAgIHJlcXVlc3RfZGF0YVsnYnJvYWRjYXN0J10gPSB0cnVlO1xuICAgIC8vIH1cbiAgICAvLyBpZiAoZGF0YVsnYnJvYWRjYXN0X3NlbmRlciddID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyAgIHJlcXVlc3RfZGF0YVsnYnJvYWRjYXN0X3NlbmRlciddID0gdHJ1ZTtcbiAgICAvLyB9XG4gICAgY29uc3Qgcm9vbSA9IGdlbmVyYXRlU29ja2V0Q2xpZW50KGRhdGEubmFtZXNwYWNlLCBkYXRhLnJvb20pO1xuICAgIFxuICAgIHRoaXMuc29ja2V0LnNlbmQoJ3NlbmRNZXNzYWdlJywgcmVxdWVzdF9kYXRhLCByb29tKVxuIH0sXG4gXG4gcmVjZWl2ZTogZnVuY3Rpb24obWVzc2FnZSwgZnVuKSB7XG4gICB0aGlzLnNvY2tldC5saXN0ZW4obWVzc2FnZSwgZnVuKTtcbiB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNZXNzYWdlKHNvY2tldCkge1xuICBDb0NyZWF0ZU1lc3NhZ2Uuc2V0U29ja2V0KHNvY2tldClcbiAgcmV0dXJuIENvQ3JlYXRlTWVzc2FnZTtcbn07XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/message.js\n")},"../../CoCreateJS/src/socket.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nclass CoCreateSocket {\n  constructor(prefix = \"crud\") {\n    this.prefix = prefix || \"crud\";\n    this.sockets = new Map();\n    this.listeners = new Map();\n    this.messageQueue = new Map();\n    this.saveFileName = '';\n    this.globalScope = \"\";\n  }\n\n  setGlobalScope(scope) {\n    this.globalScope = `${this.prefix}/${scope}`;\n  }\n\n  getGlobalScope() {\n    return this.globalScope;\n  }\n  /**\n   * config: {namespace, room, host}\n   */\n\n\n  create(config) {\n    const {\n      namespace,\n      room\n    } = config;\n    const key = this.getKey(namespace, room);\n\n    let _this = this;\n\n    let socket;\n\n    if (this.sockets.get(key)) {\n      socket = this.sockets.get(key);\n      console.log('SOcket already has been register');\n      return;\n    }\n\n    let w_protocol = window.location.protocol;\n\n    if (window.location.protocol === \"about:\") {\n      w_protocol = window.parent.location.protocol;\n    }\n\n    let protocol = w_protocol === 'http:' ? 'ws' : 'wss';\n    const port = config.port ? config.port : 8088;\n    let socket_url = `${protocol}://${window.location.host}:${port}/${key}`;\n\n    if (config.host) {\n      if (config.host.includes(\"://\")) {\n        socket_url = `${config.host}/${key}`;\n      } else {\n        socket_url = `${protocol}://${config.host}:${port}/${key}`;\n      }\n    }\n\n    socket = new WebSocket(socket_url);\n\n    socket.onopen = function (event) {\n      console.log('created socket: ' + key);\n      const messages = _this.messageQueue.get(key) || [];\n      console.log(messages);\n      messages.forEach(msg => socket.send(JSON.stringify(msg)));\n\n      _this.sockets.set(key, socket);\n\n      _this.messageQueue.set(key, []);\n    };\n\n    socket.onclose = function (event) {\n      switch (event.code) {\n        case 1000:\n          // close normal\n          console.log(\"websocket: closed\");\n          break;\n\n        default:\n          _this.destroy(socket, key);\n\n          _this.reconnect(socket, config);\n\n          break;\n      }\n    };\n\n    socket.onerror = function (err) {\n      console.log('Socket error');\n\n      _this.destroy(socket, key);\n\n      _this.reconnect(socket, config);\n    };\n\n    socket.onmessage = function (data) {\n      try {\n        if (data.data instanceof Blob) {\n          _this.saveFile(data.data);\n\n          return;\n        }\n\n        let rev_data = JSON.parse(data.data);\n\n        if (rev_data.data.metadata && rev_data.data.metadata.event) {\n          var event = new CustomEvent(rev_data.data.metadata.event, {\n            detail: rev_data.data\n          });\n          document.dispatchEvent(event);\n          return;\n        }\n\n        let action = rev_data.action;\n\n        const listeners = _this.listeners.get(rev_data.action);\n\n        if (!listeners) {\n          return;\n        }\n\n        listeners.forEach(listener => {\n          listener(rev_data.data, key);\n        });\n      } catch (e) {\n        console.log(e);\n      }\n    };\n  }\n  /**\n   * \n   */\n\n\n  send(action, data, room) {\n    const obj = {\n      action: action,\n      data: data\n    };\n    const key = this.getKeyByRoom(room);\n    const socket = this.getByRoom(room);\n\n    if (socket) {\n      socket.send(JSON.stringify(obj));\n    } else {\n      if (this.messageQueue.get(key)) {\n        this.messageQueue.get(key).push(obj);\n      } else {\n        this.messageQueue.set(key, [obj]);\n      }\n    }\n  }\n\n  sendFile(file, room) {\n    const socket = this.getByRoom(room);\n\n    if (socket) {\n      socket.send(file);\n    }\n  }\n  /**\n   * scope: ns/room\n   */\n\n\n  listen(type, callback) {\n    if (!this.listeners.get(type)) {\n      this.listeners.set(type, [callback]);\n    } else {\n      this.listeners.get(type).push(callback);\n    }\n  }\n\n  reconnect(socket, config) {\n    let _this = this;\n\n    setTimeout(function () {\n      _this.create(config);\n    }, 1000);\n  }\n\n  destroy(socket, key) {\n    if (socket) {\n      socket.onerror = socket.onopen = socket.onclose = null;\n      socket.close();\n      socket = null;\n    }\n\n    if (this.sockets.get(key)) {\n      this.sockets.delete(key);\n    }\n  }\n\n  getKey(namespace, room) {\n    let key = `${this.prefix}`;\n\n    if (namespace && namespace != '') {\n      if (room && room != '') {\n        key += `/${namespace}/${room}`;\n      } else {\n        key += `/${namespace}`;\n      }\n    }\n\n    return key;\n  }\n\n  getByRoom(room) {\n    let key = this.getKeyByRoom(room);\n    return this.sockets.get(key);\n  }\n\n  getKeyByRoom(room) {\n    let key = this.globalScope;\n\n    if (room) {\n      key = `${this.prefix}/${room}`;\n    }\n\n    return key;\n  }\n\n  saveFile(blob) {\n    // const {filename} = window.saveFileInfo;\n    const file_name = this.saveFileName || 'downloadFile';\n    var a = document.createElement(\"a\");\n    document.body.appendChild(a);\n    a.style = \"display: none\";\n    let url = window.URL.createObjectURL(blob);\n    a.href = url;\n    a.download = file_name;\n    a.click();\n    window.URL.revokeObjectURL(url);\n    this.saveFileName = '';\n  }\n\n}\n\nvar _default = CoCreateSocket;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlSlMvc3JjL3NvY2tldC5qcz8xN2JkIl0sIm5hbWVzIjpbIkNvQ3JlYXRlU29ja2V0IiwiY29uc3RydWN0b3IiLCJwcmVmaXgiLCJzb2NrZXRzIiwiTWFwIiwibGlzdGVuZXJzIiwibWVzc2FnZVF1ZXVlIiwic2F2ZUZpbGVOYW1lIiwiZ2xvYmFsU2NvcGUiLCJzZXRHbG9iYWxTY29wZSIsInNjb3BlIiwiZ2V0R2xvYmFsU2NvcGUiLCJjcmVhdGUiLCJjb25maWciLCJuYW1lc3BhY2UiLCJyb29tIiwia2V5IiwiZ2V0S2V5IiwiX3RoaXMiLCJzb2NrZXQiLCJnZXQiLCJjb25zb2xlIiwibG9nIiwid19wcm90b2NvbCIsIndpbmRvdyIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJwYXJlbnQiLCJwb3J0Iiwic29ja2V0X3VybCIsImhvc3QiLCJpbmNsdWRlcyIsIldlYlNvY2tldCIsIm9ub3BlbiIsImV2ZW50IiwibWVzc2FnZXMiLCJmb3JFYWNoIiwibXNnIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXQiLCJvbmNsb3NlIiwiY29kZSIsImRlc3Ryb3kiLCJyZWNvbm5lY3QiLCJvbmVycm9yIiwiZXJyIiwib25tZXNzYWdlIiwiZGF0YSIsIkJsb2IiLCJzYXZlRmlsZSIsInJldl9kYXRhIiwicGFyc2UiLCJtZXRhZGF0YSIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiZG9jdW1lbnQiLCJkaXNwYXRjaEV2ZW50IiwiYWN0aW9uIiwibGlzdGVuZXIiLCJlIiwib2JqIiwiZ2V0S2V5QnlSb29tIiwiZ2V0QnlSb29tIiwicHVzaCIsInNlbmRGaWxlIiwiZmlsZSIsImxpc3RlbiIsInR5cGUiLCJjYWxsYmFjayIsInNldFRpbWVvdXQiLCJjbG9zZSIsImRlbGV0ZSIsImJsb2IiLCJmaWxlX25hbWUiLCJhIiwiY3JlYXRlRWxlbWVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN0eWxlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiaHJlZiIsImRvd25sb2FkIiwiY2xpY2siLCJyZXZva2VPYmplY3RVUkwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxNQUFNQSxjQUFOLENBQ0E7QUFDQ0MsYUFBVyxDQUFDQyxNQUFNLEdBQUcsTUFBVixFQUFrQjtBQUM1QixTQUFLQSxNQUFMLEdBQWNBLE1BQU0sSUFBSSxNQUF4QjtBQUNBLFNBQUtDLE9BQUwsR0FBZSxJQUFJQyxHQUFKLEVBQWY7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLElBQUlELEdBQUosRUFBakI7QUFDQSxTQUFLRSxZQUFMLEdBQXFCLElBQUlGLEdBQUosRUFBckI7QUFDQSxTQUFLRyxZQUFMLEdBQXFCLEVBQXJCO0FBQ0EsU0FBS0MsV0FBTCxHQUFvQixFQUFwQjtBQUNBOztBQUVEQyxnQkFBYyxDQUFDQyxLQUFELEVBQVE7QUFDckIsU0FBS0YsV0FBTCxHQUFvQixHQUFFLEtBQUtOLE1BQU8sSUFBR1EsS0FBTSxFQUEzQztBQUNBOztBQUVEQyxnQkFBYyxHQUFHO0FBQ2hCLFdBQU8sS0FBS0gsV0FBWjtBQUNBO0FBRUQ7QUFDRDtBQUNBOzs7QUFDQ0ksUUFBTSxDQUFFQyxNQUFGLEVBQVU7QUFDZixVQUFNO0FBQUNDLGVBQUQ7QUFBWUM7QUFBWixRQUFvQkYsTUFBMUI7QUFDQSxVQUFNRyxHQUFHLEdBQUcsS0FBS0MsTUFBTCxDQUFZSCxTQUFaLEVBQXVCQyxJQUF2QixDQUFaOztBQUNBLFFBQUlHLEtBQUssR0FBRyxJQUFaOztBQUNBLFFBQUlDLE1BQUo7O0FBQ0EsUUFBSSxLQUFLaEIsT0FBTCxDQUFhaUIsR0FBYixDQUFpQkosR0FBakIsQ0FBSixFQUEyQjtBQUMxQkcsWUFBTSxHQUFHLEtBQUtoQixPQUFMLENBQWFpQixHQUFiLENBQWlCSixHQUFqQixDQUFUO0FBQ0FLLGFBQU8sQ0FBQ0MsR0FBUixDQUFZLGtDQUFaO0FBQ0E7QUFDQTs7QUFFRCxRQUFJQyxVQUFVLEdBQUdDLE1BQU0sQ0FBQ0MsUUFB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QUNBOztBQUdEbUMsVUFBUSxDQUFDdUIsSUFBRCxFQUFPO0FBQ2Q7QUFFQSxVQUFNQyxTQUFTLEdBQUcsS0FBS3BFLFlBQUwsSUFBcUIsY0FBdkM7QUFDQSxRQUFJcUUsQ0FBQyxHQUFHbkIsUUFBUSxDQUFDb0IsYUFBVCxDQUF1QixHQUF2QixDQUFSO0FBQ01wQixZQUFRLENBQUNxQixJQUFULENBQWNDLFdBQWQsQ0FBMEJILENBQTFCO0FBQ0FBLEtBQUMsQ0FBQ0ksS0FBRixHQUFVLGVBQVY7QUFFQSxRQUFJQyxHQUFHLEdBQUd6RCxNQUFNLENBQUMwRCxHQUFQLENBQVdDLGVBQVgsQ0FBMkJULElBQTNCLENBQVY7QUFDQUUsS0FBQyxDQUFDUSxJQUFGLEdBQVNILEdBQVQ7QUFDQUwsS0FBQyxDQUFDUyxRQUFGLEdBQWFWLFNBQWI7QUFDQUMsS0FBQyxDQUFDVSxLQUFGO0FBQ0E5RCxVQUFNLENBQUMwRCxHQUFQLENBQVdLLGVBQVgsQ0FBMkJOLEdBQTNCO0FBRUEsU0FBSzFFLFlBQUwsR0FBb0IsRUFBcEI7QUFDTjs7QUFsTkY7O2VBcU5lUCxjIiwiZmlsZSI6Ii4uLy4uL0NvQ3JlYXRlSlMvc3JjL3NvY2tldC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzIENvQ3JlYXRlU29ja2V0XG57XG5cdGNvbnN0cnVjdG9yKHByZWZpeCA9IFwiY3J1ZFwiKSB7XG5cdFx0dGhpcy5wcmVmaXggPSBwcmVmaXggfHwgXCJjcnVkXCI7XG5cdFx0dGhpcy5zb2NrZXRzID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMubGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMubWVzc2FnZVF1ZXVlID0gIG5ldyBNYXAoKTtcblx0XHR0aGlzLnNhdmVGaWxlTmFtZSA9ICAnJztcblx0XHR0aGlzLmdsb2JhbFNjb3BlID0gIFwiXCI7XG5cdH1cblxuXHRzZXRHbG9iYWxTY29wZShzY29wZSkge1xuXHRcdHRoaXMuZ2xvYmFsU2NvcGUgPSBgJHt0aGlzLnByZWZpeH0vJHtzY29wZX1gO1xuXHR9XG5cdFxuXHRnZXRHbG9iYWxTY29wZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5nbG9iYWxTY29wZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIGNvbmZpZzoge25hbWVzcGFjZSwgcm9vbSwgaG9zdH1cblx0ICovXG5cdGNyZWF0ZSAoY29uZmlnKSB7XG5cdFx0Y29uc3Qge25hbWVzcGFjZSwgcm9vbX0gPSBjb25maWc7XG5cdFx0Y29uc3Qga2V5ID0gdGhpcy5nZXRLZXkobmFtZXNwYWNlLCByb29tKTtcblx0XHRsZXQgX3RoaXMgPSB0aGlzO1xuXHRcdGxldCBzb2NrZXQ7XG5cdFx0aWYgKHRoaXMuc29ja2V0cy5nZXQoa2V5KSkge1xuXHRcdFx0c29ja2V0ID0gdGhpcy5zb2NrZXRzLmdldChrZXkpO1xuXHRcdFx0Y29uc29sZS5sb2coJ1NPY2tldCBhbHJlYWR5IGhhcyBiZWVuIHJlZ2lzdGVyJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdGxldCB3X3Byb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1x0XHRcblx0XHRpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSBcImFib3V0OlwiKSB7XG5cdFx0XHR3X3Byb3RvY29sID0gd2luZG93LnBhcmVudC5sb2NhdGlvbi5wcm90b2NvbDtcblx0XHR9XG5cdFx0bGV0IHByb3RvY29sID0gd19wcm90b2NvbCA9PT0gJ2h0dHA6JyA/ICd3cycgOiAnd3NzJztcblx0XHRcblx0XHRjb25zdCBwb3J0ID0gY29uZmlnLnBvcnQgPyBjb25maWcucG9ydCA6IDgwODg7XG5cdFx0XG5cdFx0bGV0IHNvY2tldF91cmwgPSBgJHtwcm90b2NvbH06Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fToke3BvcnR9LyR7a2V5fWA7XG5cdFx0XG5cdFx0aWYgKGNvbmZpZy5ob3N0KSB7XG5cdFx0XHRpZiAoY29uZmlnLmhvc3QuaW5jbHVkZXMoXCI6Ly9cIikpIHtcblx0XHRcdFx0c29ja2V0X3VybCA9IGAke2NvbmZpZy5ob3N0fS8ke2tleX1gO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c29ja2V0X3VybCA9IGAke3Byb3RvY29sfTovLyR7Y29uZmlnLmhvc3R9OiR7cG9ydH0vJHtrZXl9YDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0c29ja2V0ID0gbmV3IFdlYlNvY2tldChzb2NrZXRfdXJsKTtcblx0XHRcblx0XHRzb2NrZXQub25vcGVuID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdjcmVhdGVkIHNvY2tldDogJyArIGtleSk7XG5cdFx0XHRjb25zdCBtZXNzYWdlcyA9IF90aGlzLm1lc3NhZ2VRdWV1ZS5nZXQoa2V5KSB8fCBbXTtcblx0XHRcdGNvbnNvbGUubG9nKG1lc3NhZ2VzKVxuXHRcdFx0bWVzc2FnZXMuZm9yRWFjaChtc2cgPT4gc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobXNnKSkpO1xuXHRcdFx0XG5cdFx0XHRfdGhpcy5zb2NrZXRzLnNldChrZXksIHNvY2tldCk7XG5cdFx0XHRfdGhpcy5tZXNzYWdlUXVldWUuc2V0KGtleSwgW10pO1xuXHRcdH1cblx0XHRcblx0XHRzb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRzd2l0Y2goZXZlbnQuY29kZSkge1xuXHRcdFx0XHRjYXNlIDEwMDA6IC8vIGNsb3NlIG5vcm1hbFxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwid2Vic29ja2V0OiBjbG9zZWRcIik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6IFxuXHRcdFx0XHRcdF90aGlzLmRlc3Ryb3koc29ja2V0LCBrZXkpO1xuXHRcdFx0XHRcdF90aGlzLnJlY29ubmVjdChzb2NrZXQsIGNvbmZpZyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnU29ja2V0IGVycm9yJyk7XG5cdFx0XHRfdGhpcy5kZXN0cm95KHNvY2tldCwga2V5KTtcblx0XHRcdF90aGlzLnJlY29ubmVjdChzb2NrZXQsIGNvbmZpZyk7XG5cdFx0fVxuXG5cdFx0c29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKGRhdGEuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHRfdGhpcy5zYXZlRmlsZShkYXRhLmRhdGEpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgcmV2X2RhdGEgPSBKU09OLnBhcnNlKGRhdGEuZGF0YSk7XG5cdFx0XHRcdGlmIChyZXZfZGF0YS5kYXRhLm1ldGFkYXRhICYmIHJldl9kYXRhLmRhdGEubWV0YWRhdGEuZXZlbnQpIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQocmV2X2RhdGEuZGF0YS5tZXRhZGF0YS5ldmVudCwge1xuXHRcdFx0XHRcdFx0ZGV0YWlsOiByZXZfZGF0YS5kYXRhXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IGFjdGlvbiA9IHJldl9kYXRhLmFjdGlvbjtcblx0XHRcdFx0Y29uc3QgbGlzdGVuZXJzID0gX3RoaXMubGlzdGVuZXJzLmdldChyZXZfZGF0YS5hY3Rpb24pO1xuXHRcdFx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG5cdFx0XHRcdFx0bGlzdGVuZXIocmV2X2RhdGEuZGF0YSwga2V5KTtcblx0XHRcdFx0fSlcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogXG5cdCAqL1xuXHRzZW5kIChhY3Rpb24sIGRhdGEsIHJvb20pIHtcblx0XHRjb25zdCBvYmogPSB7XG5cdFx0XHRhY3Rpb246IGFjdGlvbixcblx0XHRcdGRhdGE6IGRhdGFcblx0XHR9XG5cdFx0Y29uc3Qga2V5ID0gdGhpcy5nZXRLZXlCeVJvb20ocm9vbSk7XG5cdFx0Y29uc3Qgc29ja2V0ID0gdGhpcy5nZXRCeVJvb20ocm9vbSk7XG5cdFx0XG5cdFx0aWYgKHNvY2tldCkge1xuXHRcdFx0c29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLm1lc3NhZ2VRdWV1ZS5nZXQoa2V5KSkge1xuXHRcdFx0XHR0aGlzLm1lc3NhZ2VRdWV1ZS5nZXQoa2V5KS5wdXNoKG9iaik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1lc3NhZ2VRdWV1ZS5zZXQoa2V5LCBbb2JqXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRzZW5kRmlsZSAoZmlsZSwgcm9vbSkge1xuXHRcdGNvbnN0IHNvY2tldCA9IHRoaXMuZ2V0QnlSb29tKHJvb20pO1xuXHRcdGlmIChzb2NrZXQpIHtcblx0XHRcdHNvY2tldC5zZW5kKGZpbGUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBzY29wZTogbnMvcm9vbVxuXHQgKi9cblx0bGlzdGVuKHR5cGUsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKCF0aGlzLmxpc3RlbmVycy5nZXQodHlwZSkpIHtcblx0XHRcdHRoaXMubGlzdGVuZXJzLnNldCh0eXBlLCBbY2FsbGJhY2tdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5saXN0ZW5lcnMuZ2V0KHR5cGUpLnB1c2goY2FsbGJhY2spO1xuXHRcdH1cblx0fVxuXHRcblx0cmVjb25uZWN0KHNvY2tldCwgY29uZmlnKSB7XG5cdFx0bGV0IF90aGlzID0gdGhpcztcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMuY3JlYXRlKGNvbmZpZyk7XG5cdFx0fSwgMTAwMClcblx0fVxuXHRcblx0ZGVzdHJveShzb2NrZXQsIGtleSkge1xuXHRcdGlmIChzb2NrZXQpIHtcblx0XHRcdHNvY2tldC5vbmVycm9yID0gc29ja2V0Lm9ub3BlbiA9IHNvY2tldC5vbmNsb3NlID0gbnVsbDtcblx0XHRcdHNvY2tldC5jbG9zZSgpO1xuXHRcdFx0c29ja2V0ID0gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHRoaXMuc29ja2V0cy5nZXQoa2V5KSkge1xuXHRcdFx0dGhpcy5zb2NrZXRzLmRlbGV0ZShrZXkpO1xuXHRcdH1cblx0fVxuXHRcblx0Z2V0S2V5KG5hbWVzcGFjZSwgcm9vbSkge1xuXHRcdGxldCBrZXkgPSBgJHt0aGlzLnByZWZpeH1gO1xuXHRcdGlmIChuYW1lc3BhY2UgJiYgbmFtZXNwYWNlICE9ICcnKSB7XG5cdFx0XHRpZiAocm9vbSAmJiAgcm9vbSAhPSAnJykge1xuXHRcdFx0XHRrZXkgKz0gYC8ke25hbWVzcGFjZX0vJHtyb29tfWA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgKz1gLyR7bmFtZXNwYWNlfWA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBrZXk7XG5cdH1cblx0XG5cdGdldEJ5Um9vbShyb29tKSB7XG5cdFx0bGV0IGtleSA9IHRoaXMuZ2V0S2V5QnlSb29tKHJvb20pXG5cdFx0cmV0dXJuIHRoaXMuc29ja2V0cy5nZXQoa2V5KTtcdFxuXHR9XG5cdFxuXHRnZXRLZXlCeVJvb20ocm9vbSkge1xuXHRcdGxldCBrZXkgPSB0aGlzLmdsb2JhbFNjb3BlO1xuXHRcdGlmIChyb29tKSB7XG5cdFx0XHRrZXkgPSBgJHt0aGlzLnByZWZpeH0vJHtyb29tfWA7XG5cdFx0fVxuXHRcdHJldHVybiBrZXk7XHRcdFxuXHR9XG5cdFxuXHRcblx0c2F2ZUZpbGUoYmxvYikge1xuXHRcdC8vIGNvbnN0IHtmaWxlbmFtZX0gPSB3aW5kb3cuc2F2ZUZpbGVJbmZvO1xuXHRcdFxuXHRcdGNvbnN0IGZpbGVfbmFtZSA9IHRoaXMuc2F2ZUZpbGVOYW1lIHx8ICdkb3dubG9hZEZpbGUnO1xuXHRcdHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgIGEuc3R5bGUgPSBcImRpc3BsYXk6IG5vbmVcIjtcblxuICAgICAgICBsZXQgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgICAgYS5kb3dubG9hZCA9IGZpbGVfbmFtZTtcbiAgICAgICAgYS5jbGljaygpO1xuICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuXG4gICAgICAgIHRoaXMuc2F2ZUZpbGVOYW1lID0gJydcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb0NyZWF0ZVNvY2tldDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/socket.js\n")},"../../CoCreateJS/src/utils.crud.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nfunction __mergeObject(target, source) {\n  target = target || {};\n\n  for (let key of Object.keys(source)) {\n    if (source[key] instanceof Object) {\n      Object.assign(source[key], __mergeObject(target[key], source[key]));\n    }\n  }\n\n  Object.assign(target || {}, source);\n  return target;\n}\n\nfunction __createObject(data, path) {\n  if (!path) return data;\n  let keys = path.split('.');\n  let newObject = data;\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    newObject = {\n      [keys[i]]: newObject\n    };\n  }\n\n  return newObject;\n}\n\nfunction __createArray(key, data) {\n  try {\n    let item = /([\\w\\W]+)\\[(\\d+)\\]/gm.exec(key);\n\n    if (item && item.length == 3) {\n      let arrayKey = item[1];\n      let index = parseInt(item[2]);\n\n      if (!data[arrayKey] || !Array.isArray(data[arrayKey])) {\n        data[arrayKey] = [];\n      }\n\n      data[arrayKey][index] = data[key];\n      delete data[key];\n      key = arrayKey;\n    }\n  } catch {\n    console.log('create array error');\n  }\n\n  return key;\n}\n\nfunction isObject(item) {\n  return !!item && item.constructor === Object;\n}\n\nfunction isArray(item) {\n  return !!item && item.constructor === Array;\n}\n\nfunction decodeObject(data) {\n  let keys = Object.keys(data);\n  let objectData = {};\n  keys.forEach(k => {\n    k = __createArray(k, data);\n\n    if (k.split('.').length > 1) {\n      let newData = __createObject(data[k], k);\n\n      delete data[k];\n      objectData = __mergeObject(objectData, newData);\n    } else {\n      objectData[k] = data[k];\n    }\n  });\n  return objectData;\n}\n\nfunction encodeObject(data) {\n  let keys = Object.keys(data);\n  let newData = {};\n  keys.forEach(k => {\n    let data_value = data[k];\n\n    if (isObject(data[k])) {\n      let new_obj = encodeObject(data[k]);\n      let newKeys = Object.keys(new_obj);\n      newKeys.forEach(newKey => {\n        let value = new_obj[newKey];\n        newKey = k + \".\" + newKey;\n        newData[newKey] = value;\n      });\n    } else if (isArray(data_value)) {\n      data_value.forEach((v, index) => {\n        newData[`${k}[${index}]`] = v;\n      });\n    } else {\n      newData[k] = data[k];\n    }\n  });\n  return newData;\n}\n\nvar _default = {\n  decodeObject,\n  encodeObject\n};\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlSlMvc3JjL3V0aWxzLmNydWQuanM/YTYwYyJdLCJuYW1lcyI6WyJfX21lcmdlT2JqZWN0IiwidGFyZ2V0Iiwic291cmNlIiwia2V5IiwiT2JqZWN0Iiwia2V5cyIsImFzc2lnbiIsIl9fY3JlYXRlT2JqZWN0IiwiZGF0YSIsInBhdGgiLCJzcGxpdCIsIm5ld09iamVjdCIsImkiLCJsZW5ndGgiLCJfX2NyZWF0ZUFycmF5IiwiaXRlbSIsImV4ZWMiLCJhcnJheUtleSIsImluZGV4IiwicGFyc2VJbnQiLCJBcnJheSIsImlzQXJyYXkiLCJjb25zb2xlIiwibG9nIiwiaXNPYmplY3QiLCJjb25zdHJ1Y3RvciIsImRlY29kZU9iamVjdCIsIm9iamVjdERhdGEiLCJmb3JFYWNoIiwiayIsIm5ld0RhdGEiLCJlbmNvZGVPYmplY3QiLCJkYXRhX3ZhbHVlIiwibmV3X29iaiIsIm5ld0tleXMiLCJuZXdLZXkiLCJ2YWx1ZSIsInYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxTQUFVQSxhQUFWLENBQXdCQyxNQUF4QixFQUFnQ0MsTUFBaEMsRUFDQTtBQUNDRCxRQUFNLEdBQUdBLE1BQU0sSUFBSSxFQUFuQjs7QUFDQSxPQUFLLElBQUlFLEdBQVQsSUFBZ0JDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSCxNQUFaLENBQWhCLEVBQXFDO0FBQ3BDLFFBQUlBLE1BQU0sQ0FBQ0MsR0FBRCxDQUFOLFlBQXVCQyxNQUEzQixFQUFtQztBQUNsQ0EsWUFBTSxDQUFDRSxNQUFQLENBQWNKLE1BQU0sQ0FBQ0MsR0FBRCxDQUFwQixFQUEyQkgsYUFBYSxDQUFDQyxNQUFNLENBQUNFLEdBQUQsQ0FBUCxFQUFjRCxNQUFNLENBQUNDLEdBQUQsQ0FBcEIsQ0FBeEM7QUFDQTtBQUNEOztBQUVEQyxRQUFNLENBQUNFLE1BQVAsQ0FBY0wsTUFBTSxJQUFJLEVBQXhCLEVBQTRCQyxNQUE1QjtBQUNBLFNBQU9ELE1B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bnQiOlsiZnVuY3Rpb24gXHRfX21lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlKSBcbntcblx0dGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuXHRmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoc291cmNlKSkge1xuXHRcdGlmIChzb3VyY2Vba2V5XSBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0T2JqZWN0LmFzc2lnbihzb3VyY2Vba2V5XSwgX19tZXJnZU9iamVjdCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pKVxuXHRcdH1cblx0fVxuXHRcblx0T2JqZWN0LmFzc2lnbih0YXJnZXQgfHwge30sIHNvdXJjZSlcblx0cmV0dXJuIHRhcmdldFxufVxuXG5mdW5jdGlvbiBfX2NyZWF0ZU9iamVjdChkYXRhLCBwYXRoKSBcbntcblx0aWYgKCFwYXRoKSByZXR1cm4gZGF0YTtcblx0XG5cdGxldCBrZXlzID0gcGF0aC5zcGxpdCgnLicpXG5cdGxldCBuZXdPYmplY3QgPSBkYXRhO1xuXG5cdGZvciAodmFyICBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdG5ld09iamVjdCA9IHtba2V5c1tpXV06IG5ld09iamVjdH1cdFx0XHRcdFxuXHR9XG5cdHJldHVybiBuZXdPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIF9fY3JlYXRlQXJyYXkoa2V5LCBkYXRhKVxue1xuICB0cnkge1xuICAgIGxldCBpdGVtID0gLyhbXFx3XFxXXSspXFxbKFxcZCspXFxdL2dtLmV4ZWMoa2V5KVxuICAgIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoID09IDMpIHtcbiAgICAgIGxldCBhcnJheUtleSA9IGl0ZW1bMV07XG4gICAgICBsZXQgaW5kZXggPSBwYXJzZUludChpdGVtWzJdKTtcbiAgICAgIFxuICAgICAgaWYgKCFkYXRhW2FycmF5S2V5XSB8fCAhQXJyYXkuaXNBcnJheShkYXRhW2FycmF5S2V5XSkpIHtcbiAgICAgICAgZGF0YVthcnJheUtleV0gPSBbXTtcbiAgICAgIH0gXG4gICAgICBkYXRhW2FycmF5S2V5XVtpbmRleF0gPSBkYXRhW2tleV07XG4gICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAga2V5ID0gYXJyYXlLZXk7XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICBjb25zb2xlLmxvZygnY3JlYXRlIGFycmF5IGVycm9yJyk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cblxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGl0ZW0pIHtcbiAgcmV0dXJuICghIWl0ZW0pICYmIChpdGVtLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xufVxuZnVuY3Rpb24gaXNBcnJheShpdGVtKSB7XG4gIHJldHVybiAoISFpdGVtKSAmJiAoaXRlbS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVPYmplY3QoZGF0YSkge1xuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gIGxldCBvYmplY3REYXRhID0ge307XG4gIFxuICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICBrID0gX19jcmVhdGVBcnJheShrLCBkYXRhKTtcbiAgICBpZiAoay5zcGxpdCgnLicpLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBuZXdEYXRhID0gX19jcmVhdGVPYmplY3QoZGF0YVtrXSwgayk7XG4gICAgICBkZWxldGUgZGF0YVtrXTtcbiAgICAgIFxuICAgICAgb2JqZWN0RGF0YSA9IF9fbWVyZ2VPYmplY3Qob2JqZWN0RGF0YSwgbmV3RGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdERhdGFba10gPSBkYXRhW2tdO1xuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG9iamVjdERhdGE7XG59XG5cbmZ1bmN0aW9uIGVuY29kZU9iamVjdChkYXRhKSB7XG4gIGxldCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGxldCBuZXdEYXRhID0ge307XG4gIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgIGxldCBkYXRhX3ZhbHVlID0gZGF0YVtrXTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YVtrXSkpIHtcbiAgICAgIGxldCBuZXdfb2JqID0gZW5jb2RlT2JqZWN0KGRhdGFba10pO1xuICAgICAgXG4gICAgICBsZXQgbmV3S2V5cyA9IE9iamVjdC5rZXlzKG5ld19vYmopO1xuICAgICAgbmV3S2V5cy5mb3JFYWNoKChuZXdLZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gbmV3X29ialtuZXdLZXldO1xuICAgICAgICBuZXdLZXkgPSBrICsgXCIuXCIgKyBuZXdLZXk7XG4gICAgICAgIG5ld0RhdGFbbmV3S2V5XSA9IHZhbHVlO1xuICAgICAgfSlcbiAgICAgIFxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhX3ZhbHVlKSl7XG4gICAgICBkYXRhX3ZhbHVlLmZvckVhY2goKHYsIGluZGV4KSA9PiB7XG4gICAgICAgIG5ld0RhdGFbYCR7a31bJHtpbmRleH1dYF0gPSB2O1xuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RGF0YVtrXSA9IGRhdGFba107XG4gICAgfVxuICB9KVxuICByZXR1cm4gbmV3RGF0YTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBkZWNvZGVPYmplY3QsXG4gIGVuY29kZU9iamVjdFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/utils.crud.js\n")},"../../CoCreateJS/src/utils.js":(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.generateUUID = generateUUID;\nexports.isRealTime = isRealTime;\nexports.getParentFromElement = getParentFromElement;\nexports.isReadValue = isReadValue;\nexports.isUpdateValue = isUpdateValue;\nexports.isJsonString = isJsonString;\nexports.getAttributes = getAttributes;\nexports.checkValue = checkValue;\nexports.allFrame = allFrame;\nexports.cssPath = cssPath;\nexports.getTopMostWindow = getTopMostWindow;\nexports.findIframeFromElement = findIframeFromElement;\nexports.getIframeFromPath = getIframeFromPath;\nexports.configMatch2 = configMatch2;\nexports.configExecuter = configExecuter;\nexports.UUID = UUID;\nexports.parseTextToHtml = parseTextToHtml;\nexports.splitBydelimiter = splitBydelimiter;\nexports.joinBydelimiter = joinBydelimiter;\nexports.isValidSelector = isValidSelector;\nexports.getElementPath = getElementPath;\nexports.isUsageY = isUsageY;\nexports.default = void 0;\n\n/**\n * Created by jin\n * 2020-04-03\n */\nfunction generateUUID(length = 36) {\n  // if (length == 10) {\n  //   var result           = \'\';\n  //   var characters       = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\';\n  //   var charactersLength = characters.length;\n  //   for ( var i = 0; i < length; i++ ) {\n  //     result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  //   }\n  //   var dd = new Date().toTimeString();\n  //   var random = dd.replace(/[\\W_]+/g, "").substr(0,6);\n  //   result += random;\n  //   return result;\n  // }\n  let d = new Date().getTime();\n  let d2 = window.performance && window.performance.now && window.performance.now() * 1000 || 0;\n  let pattern = "uxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";\n\n  if (length <= pattern.length) {\n    pattern = pattern.substr(0, length);\n  } else {\n    let add_len = length - pattern.length;\n    let sub_pattern = "-xxxyyxxx";\n    let group_n = Math.floor(add_len / sub_pattern.length);\n\n    for (let i = 0; i < group_n; i++) {\n      pattern += sub_pattern;\n    }\n\n    group_n = add_len - group_n * sub_pattern.length;\n    pattern += sub_pattern.substr(0, group_n);\n  }\n\n  let uuid = pattern.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16;\n\n    if (d > 0) {\n      var r = (d + r) % 16 | 0;\n      d = Math.floor(d / 16);\n    } else {\n      var r = (d2 + r) % 16 | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n\n    return (c == "x" ? r : r & 0x7 | 0x8).toString(16);\n  });\n  return uuid;\n}\n\nfunction isRealTime(element, parent_realTime) {\n  let realtime = element.getAttribute("data-realtime") || parent_realTime;\n\n  if (realtime === "false") {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getParentFromElement(element, parent_class, attributes) {\n  if (parent_class) {\n    if (element.classList.contains(parent_class)) {\n      return element;\n    }\n\n    let node = element.parentNode;\n\n    while (node != null && node.classList) {\n      if (node.classList.contains(parent_class)) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n  } else if (attributes) {\n    if (attributes.every(attr => element.attributes.hasOwnProperty(attr))) {\n      return element;\n    }\n\n    let node = element.parentNode;\n\n    while (node != null && node.attributes) {\n      if (attributes.every(attr => node.attributes.hasOwnProperty(attr))) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n  }\n\n  return false;\n}\n\nfunction isReadValue(element) {\n  return element.getAttribute("data-read_value") != "false";\n}\n\nfunction isUpdateValue(element) {\n  return element.getAttribute("data-update_value") != "false";\n}\n\nfunction isJsonString(str_data) {\n  try {\n    let json_data = JSON.parse(str_data);\n\n    if (typeof json_data === "object" && json_data != null) {\n      return true;\n    } else {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction getAttributes(element) {\n  return element.getAttributeNames().reduce((attrMap, name) => {\n    attrMap[name] = element.getAttribute(name);\n    return attrMap;\n  }, {});\n}\n\nfunction checkValue(value) {\n  if (!value) return false;\n\n  if (/{{\\s*([\\w\\W]+)\\s*}}/g.test(value)) {\n    return false;\n  }\n\n  return true;\n} // hosseins utills\n// function to go through all frames\n\n\nfunction allFrame(callback) {\n  let allFrames = [{\n    document,\n    window\n  }];\n\n  for (let frame of document.querySelectorAll("iframe")) {\n    let frameDocument = frame.contentDocument || frame.contentWindow.document;\n    let frameWindow = frame.contentWindow;\n    allFrames.push({\n      document: frameDocument,\n      window: frameWindow,\n      frameElement: frame\n    });\n  }\n\n  let result = new Set();\n\n  for (let frame of allFrames) {\n    let callbackResult = callback(frame);\n    if (callbackResult && typeof callbackResult[Symbol.iterator] === "function") callbackResult.forEach(el => result.add(el));else if (callbackResult) result.add(callbackResult);\n  }\n\n  return Array.from(result);\n}\n\nfunction cssPath(node) {\n  let pathSplits = [];\n\n  do {\n    if (!node || !node.tagName) return false;\n    let pathSplit = node.tagName.toLowerCase();\n    if (node.id && node.tagName !== "BODY") pathSplit += "#" + node.id;\n\n    if (node.classList.length && node.tagName !== "BODY") {\n      node.classList.forEach(item => {\n        if (item.indexOf(":") === -1) pathSplit += "." + item;\n      });\n    }\n\n    if (node.tagName !== "BODY" && node.parentNode) {\n      let index = Array.prototype.indexOf.call(node.parentNode.children, node);\n      pathSplit += `:nth-child(${index + 1})`;\n    }\n\n    pathSplits.unshift(pathSplit);\n    node = node.parentNode;\n  } while (node.tagName !== "HTML");\n\n  return pathSplits.join(" > ");\n}\n\nfunction getTopMostWindow() {\n  let parentWindow = window;\n\n  while (parentWindow !== window.parent) parentWindow = window.parent;\n\n  return parentWindow;\n}\n\nfunction findIframeFromElement(windowObject, element) {\n  let frameElement;\n  allFrame(frame => {\n    if (frame.document.contains(element)) frameElement = frame.frameElement; // window.cc.findIframeFromElement(frame.window, element);\n  });\n  return frameElement;\n}\n\nfunction getIframeFromPath(path) {\n  let topWindow = getTopMostWindow;\n  path.forEach(selector => {\n    if (topWindow) topWindow = topWindow.querySelector(selector);\n  });\n  return topWindow;\n} // DO NOT REMOVE\n// configMatch: function* configMatch(elementConfig, element) {\n//   for (let config of elementConfig) {\n//     // if (!Array.isArray(config.selector))\n//     //   config.selector = [config.selector];\n//     if (config.selector && element.matches(config.selector)) yield config;\n//   }\n//   return;\n// },\n\n\nfunction configMatch2(elementConfig, element) {\n  let result = [];\n\n  for (let config of elementConfig) {\n    if (config.selector && element.matches(config.selector)) result.push(config);\n  }\n\n  return result;\n} // DO NOT REMOVE\n// an opiniated function uses configMatch2 to read configs\n// WARNING: the config iterated from top to bottom. for deseired effect elementConfig should be reveresed\n// typeof elementConfig: array of objects and every objects containing keys as false, true or a selector \n// element: the element to read attributes\n// key: the key in which is in elementConfig and on match onSuccess callback will be called\n\n\nfunction configExecuter(element, key, onSuccess, elementConfig) {\n  for (let config of configMatch2(elementConfig || window.elementConfig, element)) if (config[key] === true) return onSuccess(element, config);else if (config[key] === false) return false;else if (config[key] === undefined) continue;else if (isValidSelector(config[key])) return onSuccess(element, config, true);else console.warn("builder: wrong element config ", config);\n\n  return false;\n}\n\nfunction UUID(length = 10) {\n  var result = "";\n  var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";\n  var charactersLength = characters.length;\n\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  var d = new Date().toTimeString();\n  var random = d.replace(/[\\W_]+/g, "").substr(0, 6);\n  result += random;\n  return result;\n}\n\nfunction parseTextToHtml(text) {\n  let doc = new DOMParser().parseFromString(text, "text/html");\n  if (doc.head.children[0]) return doc.head.children[0];else return doc.body.children[0];\n}\n\nfunction splitBydelimiter(str, delimiter) {\n  return str.split(delimiter).map(s => s.trim());\n}\n\nfunction joinBydelimiter(str, delimiter) {\n  return str.map(s => s.trim()).join(delimiter);\n}\n\nfunction isValidSelector(selector) {\n  try {\n    document.createDocumentFragment().querySelector(selector);\n  } catch (error) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getElementPath(element, returnContext) {\n  let path = [];\n  let topWindow = window;\n  let iframeElement = findIframeFromElement(topWindow, element);\n  let p = cssPath(iframeElement);\n  if (p) path.unshift(p);\n  return returnContext ? {\n    path,\n    document: iframeElement || document\n  } : path; //todo: support for nested iframe\n  // while(iframeElement !== findIframeFromElement(topWindow,iframeElement))\n  // {\n  //   iframeElement = findIframeFromElement(topWindow,iframeElement);\n  //   path.unshift(cssPath(iframeElement))\n  // }\n}\n\nfunction isUsageY(input) {\n  if (this.isJsonString(input.getAttribute(\'data-collection\'))) {\n    return false;\n  }\n\n  if (this.isJsonString(input.getAttribute(\'name\'))) {\n    return false;\n  }\n\n  if (input.tagName === "INPUT" && ["text", "email", "tel", "url"].includes(input.type) || input.tagName === "TEXTAREA") {\n    if (!input.getAttribute(\'name\')) {\n      return false;\n    }\n\n    if (input.getAttribute("data-realtime") == "false") {\n      return false;\n    }\n\n    if (input.getAttribute("data-unique") === "true") {\n      return false;\n    }\n\n    if (input.type === \'password\') {\n      return false;\n    }\n\n    if (!this.isReadValue(input)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar _default = {\n  isUsageY,\n  getElementPath,\n  isValidSelector,\n  joinBydelimiter,\n  splitBydelimiter,\n  parseTextToHtml,\n  UUID,\n  configExecuter,\n  configMatch2,\n  getIframeFromPath,\n  findIframeFromElement,\n  getTopMostWindow,\n  cssPath,\n  allFrame,\n  checkValue,\n  getAttributes,\n  isJsonString,\n  isUpdateValue,\n  isReadValue,\n  getParentFromElement,\n  isRealTime,\n  generateUUID\n};\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vcmdhbml6YXRpb25zLy4uL0NvQ3JlYXRlSlMvc3JjL3V0aWxzLmpzPzMyNDUiXSwibmFtZXMiOlsiZ2VuZXJhdGVVVUlEIiwibGVuZ3RoIiwiZCIsIkRhdGUiLCJnZXRUaW1lIiwiZDIiLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZSIsIm5vdyIsInBhdHRlcm4iLCJzdWJzdHIiLCJhZGRfbGVuIiwic3ViX3BhdHRlcm4iLCJncm91cF9uIiwiTWF0aCIsImZsb29yIiwiaSIsInV1aWQiLCJyZXBsYWNlIiwiYyIsInIiLCJyYW5kb20iLCJ0b1N0cmluZyIsImlzUmVhbFRpbWUiLCJlbGVtZW50IiwicGFyZW50X3JlYWxUaW1lIiwicmVhbHRpbWUiLCJnZXRBdHRyaWJ1dGUiLCJnZXRQYXJlbnRGcm9tRWxlbWVudCIsInBhcmVudF9jbGFzcyIsImF0dHJpYnV0ZXMiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsIm5vZGUiLCJwYXJlbnROb2RlIiwiZXZlcnkiLCJhdHRyIiwiaGFzT3duUHJvcGVydHkiLCJpc1JlYWRWYWx1ZSIsImlzVXBkYXRlVmFsdWUiLCJpc0pzb25TdHJpbmciLCJzdHJfZGF0YSIsImpzb25fZGF0YSIsIkpTT04iLCJwYXJzZSIsImUiLCJnZXRBdHRyaWJ1dGVzIiwiZ2V0QXR0cmlidXRlTmFtZXMiLCJyZWR1Y2UiLCJhdHRyTWFwIiwibmFtZSIsImNoZWNrVmFsdWUiLCJ2YWx1ZSIsInRlc3QiLCJhbGxGcmFtZSIsImNhbGxiYWNrIiwiYWxsRnJhbWVzIiwiZG9jdW1lbnQiLCJmcmFtZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmcmFtZURvY3VtZW50IiwiY29udGVudERvY3VtZW50IiwiY29udGVudFdpbmRvdyIsImZyYW1lV2luZG93IiwicHVzaCIsImZyYW1lRWxlbWVudCIsInJlc3VsdCIsIlNldCIsImNhbGxiYWNrUmVzdWx0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJmb3JFYWNoIiwiZWwiLCJhZGQiLCJBcnJheSIsImZyb20iLCJjc3NQYXRoIiwicGF0aFNwbGl0cyIsInRhZ05hbWUiLCJwYXRoU3BsaXQiLCJ0b0xvd2VyQ2FzZSIsImlkIiwiaXRlbSIsImluZGV4T2YiLCJpbmRleCIsInByb3RvdHlwZSIsImNhbGwiLCJjaGlsZHJlbiIsInVuc2hpZnQiLCJqb2luIiwiZ2V0VG9wTW9zdFdpbmRvdyIsInBhcmVudFdpbmRvdyIsInBhcmVudCIsImZpbmRJZnJhbWVGcm9tRWxlbWVudCIsIndpbmRvd09iamVjdCIsImdldElmcmFtZUZyb21QYXRoIiwicGF0aCIsInRvcFdpbmRvdyIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsImNvbmZpZ01hdGNoMiIsImVsZW1lbnRDb25maWciLCJjb25maWciLCJtYXRjaGVzIiwiY29uZmlnRXhlY3V0ZXIiLCJrZXkiLCJvblN1Y2Nlc3MiLCJ1bmRlZmluZWQiLCJpc1ZhbGlkU2VsZWN0b3IiLCJjb25zb2xlIiwid2FybiIsIlVVSUQiLCJjaGFyYWN0ZXJzIiwiY2hhcmFjdGVyc0xlbmd0aCIsImNoYXJBdCIsInRvVGltZVN0cmluZyIsInBhcnNlVGV4dFRvSHRtbCIsInRleHQiLCJkb2MiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJoZWFkIiwiYm9keSIsInNwbGl0QnlkZWxpbWl0ZXIiLCJzdHIiLCJkZWxpbWl0ZXIiLCJzcGxpdCIsIm1hcCIsInMiLCJ0cmltIiwiam9pbkJ5ZGVsaW1pdGVyIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImVycm9yIiwiZ2V0RWxlbWVudFBhdGgiLCJyZXR1cm5Db250ZXh0IiwiaWZyYW1lRWxlbWVudCIsInAiLCJpc1VzYWdlWSIsImlucHV0IiwiaW5jbHVkZXMiLCJ0eXBlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR08sU0FBU0EsWUFBVCxDQUFzQkMsTUFBTSxHQUFHLEVBQS9CLEVBQW1DO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FB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QUFPLEtBQVA7QUFDRDs7ZUFFYztBQUNiRCxVQURhO0FBRWJKLGdCQUZhO0FBR2J6QixpQkFIYTtBQUlic0IsaUJBSmE7QUFLYlAsa0JBTGE7QUFNYlAsaUJBTmE7QUFPYkwsTUFQYTtBQVFiUCxnQkFSYTtBQVNiSixjQVRhO0FBVWJMLG1CQVZhO0FBV2JGLHVCQVhhO0FBWWJILGtCQVphO0FBYWJkLFNBYmE7QUFjYnRCLFVBZGE7QUFlYkgsWUFmYTtBQWdCYkwsZUFoQmE7QUFpQmJOLGNBakJhO0FBa0JiRCxlQWxCYTtBQW1CYkQsYUFuQmE7QUFvQmJWLHNCQXBCYTtBQXFCYkwsWUFyQmE7QUFzQmJ2QjtBQXRCYSxDIiwiZmlsZSI6Ii4uLy4uL0NvQ3JlYXRlSlMvc3JjL3V0aWxzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IGppblxuICogMjAyMC0wNC0wM1xuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVVVJRChsZW5ndGggPSAzNikge1xuICAvLyBpZiAobGVuZ3RoID09IDEwKSB7XG4gIC8vICAgdmFyIHJlc3VsdCAgICAgICAgICAgPSAnJztcbiAgLy8gICB2YXIgY2hhcmFjdGVycyAgICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XG4gIC8vICAgdmFyIGNoYXJhY3RlcnNMZW5ndGggPSBjaGFyYWN0ZXJzLmxlbmd0aDtcbiAgLy8gICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgLy8gICAgIHJlc3VsdCArPSBjaGFyYWN0ZXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSk7XG4gIC8vICAgfVxuXG4gIC8vICAgdmFyIGRkID0gbmV3IERhdGUoKS50b1RpbWVTdHJpbmcoKTtcbiAgLy8gICB2YXIgcmFuZG9tID0gZGQucmVwbGFjZSgvW1xcV19dKy9nLCBcIlwiKS5zdWJzdHIoMCw2KTtcbiAgLy8gICByZXN1bHQgKz0gcmFuZG9tO1xuICAvLyAgIHJldHVybiByZXN1bHQ7XG4gIC8vIH1cblxuICBsZXQgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBsZXQgZDIgPVxuICAgICh3aW5kb3cucGVyZm9ybWFuY2UgJiZcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgJiZcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAqIDEwMDApIHx8XG4gICAgMDtcbiAgbGV0IHBhdHRlcm4gPSBcInV4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiO1xuXG4gIGlmIChsZW5ndGggPD0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIoMCwgbGVuZ3RoKTtcbiAgfVxuICBlbHNlIHtcbiAgICBsZXQgYWRkX2xlbiA9IGxlbmd0aCAtIHBhdHRlcm4ubGVuZ3RoO1xuICAgIGxldCBzdWJfcGF0dGVybiA9IFwiLXh4eHl5eHh4XCI7XG5cbiAgICBsZXQgZ3JvdXBfbiA9IE1hdGguZmxvb3IoYWRkX2xlbiAvIHN1Yl9wYXR0ZXJuLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwX247IGkrKykge1xuICAgICAgcGF0dGVybiArPSBzdWJfcGF0dGVybjtcbiAgICB9XG5cbiAgICBncm91cF9uID0gYWRkX2xlbiAtIGdyb3VwX24gKiBzdWJfcGF0dGVybi5sZW5ndGg7XG4gICAgcGF0dGVybiArPSBzdWJfcGF0dGVybi5zdWJzdHIoMCwgZ3JvdXBfbik7XG4gIH1cblxuICBsZXQgdXVpZCA9IHBhdHRlcm4ucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTY7XG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICB2YXIgciA9IChkICsgcikgJSAxNiB8IDA7XG4gICAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciByID0gKGQyICsgcikgJSAxNiB8IDA7XG4gICAgICBkMiA9IE1hdGguZmxvb3IoZDIgLyAxNik7XG4gICAgfVxuICAgIHJldHVybiAoYyA9PSBcInhcIiA/IHIgOiAociAmIDB4NykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgfSk7XG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFsVGltZShlbGVtZW50LCBwYXJlbnRfcmVhbFRpbWUpIHtcbiAgbGV0IHJlYWx0aW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlYWx0aW1lXCIpIHx8IHBhcmVudF9yZWFsVGltZTtcbiAgaWYgKHJlYWx0aW1lID09PSBcImZhbHNlXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmVudEZyb21FbGVtZW50KGVsZW1lbnQsIHBhcmVudF9jbGFzcywgYXR0cmlidXRlcykge1xuICBpZiAocGFyZW50X2NsYXNzKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHBhcmVudF9jbGFzcykpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGxldCBub2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlICE9IG51bGwgJiYgbm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgIGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyhwYXJlbnRfY2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYXR0cmlidXRlcykge1xuICAgIGlmIChhdHRyaWJ1dGVzLmV2ZXJ5KChhdHRyKSA9PiBlbGVtZW50LmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAobm9kZSAhPSBudWxsICYmIG5vZGUuYXR0cmlidXRlcykge1xuICAgICAgaWYgKGF0dHJpYnV0ZXMuZXZlcnkoKGF0dHIpID0+IG5vZGUuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhZFZhbHVlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWFkX3ZhbHVlXCIpICE9IFwiZmFsc2VcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVXBkYXRlVmFsdWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVwZGF0ZV92YWx1ZVwiKSAhPSBcImZhbHNlXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0pzb25TdHJpbmcoc3RyX2RhdGEpIHtcbiAgdHJ5IHtcbiAgICBsZXQganNvbl9kYXRhID0gSlNPTi5wYXJzZShzdHJfZGF0YSk7XG4gICAgaWYgKHR5cGVvZiBqc29uX2RhdGEgPT09IFwib2JqZWN0XCIgJiYganNvbl9kYXRhICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGVOYW1lcygpLnJlZHVjZSgoYXR0ck1hcCwgbmFtZSkgPT4ge1xuICAgIGF0dHJNYXBbbmFtZV0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gYXR0ck1hcDtcbiAgfSwge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2U7XG4gIGlmICgve3tcXHMqKFtcXHdcXFddKylcXHMqfX0vZy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLy8gaG9zc2VpbnMgdXRpbGxzXG5cbi8vIGZ1bmN0aW9uIHRvIGdvIHRocm91Z2ggYWxsIGZyYW1lc1xuZXhwb3J0IGZ1bmN0aW9uIGFsbEZyYW1lKGNhbGxiYWNrKSB7XG4gIGxldCBhbGxGcmFtZXMgPSBbeyBkb2N1bWVudCwgd2luZG93IH1dO1xuICBmb3IgKGxldCBmcmFtZSBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaWZyYW1lXCIpKSB7XG4gICAgbGV0IGZyYW1lRG9jdW1lbnQgPSBmcmFtZS5jb250ZW50RG9jdW1lbnQgfHwgZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICBsZXQgZnJhbWVXaW5kb3cgPSBmcmFtZS5jb250ZW50V2luZG93O1xuICAgIGFsbEZyYW1lcy5wdXNoKHtcbiAgICAgIGRvY3VtZW50OiBmcmFtZURvY3VtZW50LFxuICAgICAgd2luZG93OiBmcmFtZVdpbmRvdyxcbiAgICAgIGZyYW1lRWxlbWVudDogZnJhbWUsXG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgZm9yIChsZXQgZnJhbWUgb2YgYWxsRnJhbWVzKSB7XG4gICAgbGV0IGNhbGxiYWNrUmVzdWx0ID0gY2FsbGJhY2soZnJhbWUpO1xuICAgIGlmIChcbiAgICAgIGNhbGxiYWNrUmVzdWx0ICYmXG4gICAgICB0eXBlb2YgY2FsbGJhY2tSZXN1bHRbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiXG4gICAgKVxuICAgICAgY2FsbGJhY2tSZXN1bHQuZm9yRWFjaCgoZWwpID0+IHJlc3VsdC5hZGQoZWwpKTtcbiAgICBlbHNlIGlmIChjYWxsYmFja1Jlc3VsdCkgcmVzdWx0LmFkZChjYWxsYmFja1Jlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzUGF0aChub2RlKSB7XG4gIGxldCBwYXRoU3BsaXRzID0gW107XG4gIGRvIHtcbiAgICBpZiAoIW5vZGUgfHwgIW5vZGUudGFnTmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwYXRoU3BsaXQgPSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9kZS5pZCAmJiBub2RlLnRhZ05hbWUgIT09IFwiQk9EWVwiKSBwYXRoU3BsaXQgKz0gXCIjXCIgKyBub2RlLmlkO1xuXG4gICAgaWYgKG5vZGUuY2xhc3NMaXN0Lmxlbmd0aCAmJiBub2RlLnRhZ05hbWUgIT09IFwiQk9EWVwiKSB7XG4gICAgICBub2RlLmNsYXNzTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLmluZGV4T2YoXCI6XCIpID09PSAtMSkgcGF0aFNwbGl0ICs9IFwiLlwiICsgaXRlbTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRhZ05hbWUgIT09IFwiQk9EWVwiICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbGV0IGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLmNoaWxkcmVuLFxuICAgICAgICBub2RlXG4gICAgICApO1xuICAgICAgcGF0aFNwbGl0ICs9IGA6bnRoLWNoaWxkKCR7aW5kZXggKyAxfSlgO1xuICAgIH1cblxuICAgIHBhdGhTcGxpdHMudW5zaGlmdChwYXRoU3BsaXQpO1xuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH0gd2hpbGUgKG5vZGUudGFnTmFtZSAhPT0gXCJIVE1MXCIpO1xuXG4gIHJldHVybiBwYXRoU3BsaXRzLmpvaW4oXCIgPiBcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BNb3N0V2luZG93KCkge1xuICBsZXQgcGFyZW50V2luZG93ID0gd2luZG93O1xuICB3aGlsZSAocGFyZW50V2luZG93ICE9PSB3aW5kb3cucGFyZW50KSBwYXJlbnRXaW5kb3cgPSB3aW5kb3cucGFyZW50O1xuICByZXR1cm4gcGFyZW50V2luZG93O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZElmcmFtZUZyb21FbGVtZW50KHdpbmRvd09iamVjdCwgZWxlbWVudCkge1xuICBsZXQgZnJhbWVFbGVtZW50O1xuICBhbGxGcmFtZSgoZnJhbWUpID0+IHtcbiAgICBpZiAoZnJhbWUuZG9jdW1lbnQuY29udGFpbnMoZWxlbWVudCkpIGZyYW1lRWxlbWVudCA9IGZyYW1lLmZyYW1lRWxlbWVudDtcbiAgICAvLyB3aW5kb3cuY2MuZmluZElmcmFtZUZyb21FbGVtZW50KGZyYW1lLndpbmRvdywgZWxlbWVudCk7XG4gIH0pO1xuICByZXR1cm4gZnJhbWVFbGVtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWZyYW1lRnJvbVBhdGgocGF0aCkge1xuICBsZXQgdG9wV2luZG93ID0gZ2V0VG9wTW9zdFdpbmRvdztcblxuICBwYXRoLmZvckVhY2goKHNlbGVjdG9yKSA9PiB7XG4gICAgaWYgKHRvcFdpbmRvdykgdG9wV2luZG93ID0gdG9wV2luZG93LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9KTtcbiAgcmV0dXJuIHRvcFdpbmRvdztcbn1cbi8vIERPIE5PVCBSRU1PVkVcblxuLy8gY29uZmlnTWF0Y2g6IGZ1bmN0aW9uKiBjb25maWdNYXRjaChlbGVtZW50Q29uZmlnLCBlbGVtZW50KSB7XG4vLyAgIGZvciAobGV0IGNvbmZpZyBvZiBlbGVtZW50Q29uZmlnKSB7XG4vLyAgICAgLy8gaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5zZWxlY3RvcikpXG4vLyAgICAgLy8gICBjb25maWcuc2VsZWN0b3IgPSBbY29uZmlnLnNlbGVjdG9yXTtcblxuLy8gICAgIGlmIChjb25maWcuc2VsZWN0b3IgJiYgZWxlbWVudC5tYXRjaGVzKGNvbmZpZy5zZWxlY3RvcikpIHlpZWxkIGNvbmZpZztcbi8vICAgfVxuLy8gICByZXR1cm47XG4vLyB9LFxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ01hdGNoMihlbGVtZW50Q29uZmlnLCBlbGVtZW50KSB7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgY29uZmlnIG9mIGVsZW1lbnRDb25maWcpIHtcbiAgICBpZiAoY29uZmlnLnNlbGVjdG9yICYmIGVsZW1lbnQubWF0Y2hlcyhjb25maWcuc2VsZWN0b3IpKSByZXN1bHQucHVzaChjb25maWcpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIERPIE5PVCBSRU1PVkVcblxuLy8gYW4gb3BpbmlhdGVkIGZ1bmN0aW9uIHVzZXMgY29uZmlnTWF0Y2gyIHRvIHJlYWQgY29uZmlnc1xuLy8gV0FSTklORzogdGhlIGNvbmZpZyBpdGVyYXRlZCBmcm9tIHRvcCB0byBib3R0b20uIGZvciBkZXNlaXJlZCBlZmZlY3QgZWxlbWVudENvbmZpZyBzaG91bGQgYmUgcmV2ZXJlc2VkXG4vLyB0eXBlb2YgZWxlbWVudENvbmZpZzogYXJyYXkgb2Ygb2JqZWN0cyBhbmQgZXZlcnkgb2JqZWN0cyBjb250YWluaW5nIGtleXMgYXMgZmFsc2UsIHRydWUgb3IgYSBzZWxlY3RvciBcbi8vIGVsZW1lbnQ6IHRoZSBlbGVtZW50IHRvIHJlYWQgYXR0cmlidXRlc1xuLy8ga2V5OiB0aGUga2V5IGluIHdoaWNoIGlzIGluIGVsZW1lbnRDb25maWcgYW5kIG9uIG1hdGNoIG9uU3VjY2VzcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0V4ZWN1dGVyKGVsZW1lbnQsIGtleSwgb25TdWNjZXNzLCBlbGVtZW50Q29uZmlnKSB7XG4gIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdNYXRjaDIoZWxlbWVudENvbmZpZyB8fCB3aW5kb3cuZWxlbWVudENvbmZpZywgZWxlbWVudCkpXG4gICAgaWYgKGNvbmZpZ1trZXldID09PSB0cnVlKSByZXR1cm4gb25TdWNjZXNzKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgZWxzZSBpZiAoY29uZmlnW2tleV0gPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIGVsc2UgaWYgKGNvbmZpZ1trZXldID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICBlbHNlIGlmIChpc1ZhbGlkU2VsZWN0b3IoY29uZmlnW2tleV0pKVxuICAgIHJldHVybiBvblN1Y2Nlc3MoZWxlbWVudCwgY29uZmlnLCB0cnVlKTtcbiAgZWxzZSBjb25zb2xlLndhcm4oXCJidWlsZGVyOiB3cm9uZyBlbGVtZW50IGNvbmZpZyBcIiwgY29uZmlnKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBVVUlEKGxlbmd0aCA9IDEwKSB7XG4gIHZhciByZXN1bHQgPSBcIlwiO1xuICB2YXIgY2hhcmFjdGVycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuXG4gIHZhciBjaGFyYWN0ZXJzTGVuZ3RoID0gY2hhcmFjdGVycy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gY2hhcmFjdGVycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcmFjdGVyc0xlbmd0aCkpO1xuICB9XG5cbiAgdmFyIGQgPSBuZXcgRGF0ZSgpLnRvVGltZVN0cmluZygpO1xuICB2YXIgcmFuZG9tID0gZC5yZXBsYWNlKC9bXFxXX10rL2csIFwiXCIpLnN1YnN0cigwLCA2KTtcbiAgcmVzdWx0ICs9IHJhbmRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVGV4dFRvSHRtbCh0ZXh0KSB7XG4gIGxldCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHRleHQsIFwidGV4dC9odG1sXCIpO1xuICBpZiAoZG9jLmhlYWQuY2hpbGRyZW5bMF0pIHJldHVybiBkb2MuaGVhZC5jaGlsZHJlblswXTtcbiAgZWxzZSByZXR1cm4gZG9jLmJvZHkuY2hpbGRyZW5bMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEJ5ZGVsaW1pdGVyKHN0ciwgZGVsaW1pdGVyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoZGVsaW1pdGVyKS5tYXAoKHMpID0+IHMudHJpbSgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpvaW5CeWRlbGltaXRlcihzdHIsIGRlbGltaXRlcikge1xuICByZXR1cm4gc3RyLm1hcCgocykgPT4gcy50cmltKCkpLmpvaW4oZGVsaW1pdGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRTZWxlY3RvcihzZWxlY3Rvcikge1xuICB0cnkge1xuICAgIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50UGF0aChlbGVtZW50LCByZXR1cm5Db250ZXh0KSB7XG4gIGxldCBwYXRoID0gW107XG5cbiAgbGV0IHRvcFdpbmRvdyA9IHdpbmRvdztcbiAgbGV0IGlmcmFtZUVsZW1lbnQgPSBmaW5kSWZyYW1lRnJvbUVsZW1lbnQodG9wV2luZG93LCBlbGVtZW50KTtcbiAgbGV0IHAgPSBjc3NQYXRoKGlmcmFtZUVsZW1lbnQpO1xuICBpZiAocCkgcGF0aC51bnNoaWZ0KHApO1xuXG4gIHJldHVybiByZXR1cm5Db250ZXh0ID8geyBwYXRoLCBkb2N1bWVudDogaWZyYW1lRWxlbWVudCB8fCBkb2N1bWVudCB9IDogcGF0aDtcbiAgLy90b2RvOiBzdXBwb3J0IGZvciBuZXN0ZWQgaWZyYW1lXG4gIC8vIHdoaWxlKGlmcmFtZUVsZW1lbnQgIT09IGZpbmRJZnJhbWVGcm9tRWxlbWVudCh0b3BXaW5kb3csaWZyYW1lRWxlbWVudCkpXG4gIC8vIHtcbiAgLy8gICBpZnJhbWVFbGVtZW50ID0gZmluZElmcmFtZUZyb21FbGVtZW50KHRvcFdpbmRvdyxpZnJhbWVFbGVtZW50KTtcbiAgLy8gICBwYXRoLnVuc2hpZnQoY3NzUGF0aChpZnJhbWVFbGVtZW50KSlcbiAgLy8gfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVc2FnZVkoaW5wdXQpIHtcbiAgaWYgKHRoaXMuaXNKc29uU3RyaW5nKGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJykpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuaXNKc29uU3RyaW5nKGlucHV0LmdldEF0dHJpYnV0ZSgnbmFtZScpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgoaW5wdXQudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIFtcInRleHRcIiwgXCJlbWFpbFwiLCBcInRlbFwiLCBcInVybFwiXS5pbmNsdWRlcyhpbnB1dC50eXBlKSkgfHwgaW5wdXQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG5cbiAgICBpZiAoIWlucHV0LmdldEF0dHJpYnV0ZSgnbmFtZScpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlYWx0aW1lXCIpID09IFwiZmFsc2VcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVuaXF1ZVwiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1JlYWRWYWx1ZShpbnB1dCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzVXNhZ2VZLFxuICBnZXRFbGVtZW50UGF0aCxcbiAgaXNWYWxpZFNlbGVjdG9yLFxuICBqb2luQnlkZWxpbWl0ZXIsXG4gIHNwbGl0QnlkZWxpbWl0ZXIsXG4gIHBhcnNlVGV4dFRvSHRtbCxcbiAgVVVJRCxcbiAgY29uZmlnRXhlY3V0ZXIsXG4gIGNvbmZpZ01hdGNoMixcbiAgZ2V0SWZyYW1lRnJvbVBhdGgsXG4gIGZpbmRJZnJhbWVGcm9tRWxlbWVudCxcbiAgZ2V0VG9wTW9zdFdpbmRvdyxcbiAgY3NzUGF0aCxcbiAgYWxsRnJhbWUsXG4gIGNoZWNrVmFsdWUsXG4gIGdldEF0dHJpYnV0ZXMsXG4gIGlzSnNvblN0cmluZyxcbiAgaXNVcGRhdGVWYWx1ZSxcbiAgaXNSZWFkVmFsdWUsXG4gIGdldFBhcmVudEZyb21FbGVtZW50LFxuICBpc1JlYWxUaW1lLFxuICBnZW5lcmF0ZVVVSURcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/utils.js\n')}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}__webpack_require__.d=(n,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},__webpack_require__.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.js");return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()}));